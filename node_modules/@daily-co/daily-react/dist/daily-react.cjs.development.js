'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var recoil = require('recoil');
var throttle = _interopDefault(require('lodash.throttle'));
var Daily = _interopDefault(require('@daily-co/daily-js'));
var deepEqual = _interopDefault(require('fast-deep-equal'));

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function () {
    var self = this,
      args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(undefined);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var DailyContext = /*#__PURE__*/React.createContext(null);

/**
 * Returns callObject instance passed to or created by closest <DailyProvider>.
 */
var useDaily = function useDaily() {
  var daily = React.useContext(DailyContext);
  React.useDebugValue(daily);
  return daily;
};

var DailyEventContext = /*#__PURE__*/React.createContext({
  on: function on() {},
  off: function off() {}
});

var priorityCounter = -1;
var getPriorityUnique = function getPriorityUnique() {
  return priorityCounter--;
};
var uniqueCounter = 1;
var getUnique = function getUnique() {
  return uniqueCounter++;
};
/**
 * Sets up a daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.
 * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).
 *
 * Warning: callback has to be a memoized reference (e.g. via [useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)).
 * Otherwise a console error might be thrown indicating a re-render loop issue.
 *
 * @param ev The DailyEvent to register.
 * @param callback A memoized callback reference to run when the event is emitted.
 */
var useDailyEvent = function useDailyEvent(ev, callback, INTERNAL_priority) {
  if (INTERNAL_priority === void 0) {
    INTERNAL_priority = false;
  }
  var _useContext = React.useContext(DailyEventContext),
    off = _useContext.off,
    on = _useContext.on;
  var _useState = React.useState(false),
    isBlocked = _useState[0],
    setIsBlocked = _useState[1];
  var reassignCount = React.useRef(0);
  var eventId = React.useMemo(function () {
    return INTERNAL_priority ? getPriorityUnique() : getUnique();
  }, [INTERNAL_priority]);
  React.useEffect(function () {
    if (!ev || isBlocked) return;
    /**
     * Check if callback has been reassigned often enough without hitting the 50ms timeout.
     */
    if (reassignCount.current > 100000) {
      console.error("useDailyEvent called with potentially non-memoized event callback or due to too many re-renders.\n        Memoize using useCallback to avoid re-render loop or reduce the amount of state transitions the callback depends on.\n        Passed callback for '" + ev + "' event is NOT registered.", callback);
      setIsBlocked(true);
      return;
    }
    reassignCount.current++;
    var timeout = setTimeout(function () {
      reassignCount.current = 0;
    }, 50);
    on(ev, callback, eventId);
    return function () {
      clearTimeout(timeout);
      off(ev, eventId);
    };
  }, [callback, ev, eventId, isBlocked, off, on]);
  React.useDebugValue({
    event: ev,
    eventId: eventId,
    isBlocked: isBlocked,
    callback: callback
  });
};

var RECOIL_PREFIX = 'daily-react-';

/**
 * Stores all property paths for a given participant.
 */
var participantPropertyPathsState = /*#__PURE__*/recoil.atomFamily({
  key: RECOIL_PREFIX + 'participant-property-paths',
  "default": []
});
/**
 * Stores resolved values for each participant and property path.
 */
var participantPropertyState = /*#__PURE__*/recoil.atomFamily({
  key: RECOIL_PREFIX + 'participant-property',
  "default": null,
  dangerouslyAllowMutability: true
});
/**
 * Stores resolved values for each participant and property path.
 */
var participantPropertiesState = /*#__PURE__*/recoil.selectorFamily({
  key: RECOIL_PREFIX + 'participant-properties',
  get: function get(_ref) {
    var id = _ref.id,
      properties = _ref.properties;
    return function (_ref2) {
      var get = _ref2.get;
      return properties.map(function (path) {
        return get(participantPropertyState({
          id: id,
          property: path
        }));
      });
    };
  },
  dangerouslyAllowMutability: true
});
/**
 * Returns a participant's property that you subscribe to.
 * @param participantId The participant's session_id.
 * @param propertyPaths the array of participant property that you want to subscribe to.
 */
var useParticipantProperty = function useParticipantProperty(participantId, propertyPaths) {
  var _ref3;
  var properties = recoil.useRecoilValue(Array.isArray(propertyPaths) ? participantPropertiesState({
    id: participantId,
    properties: propertyPaths
  }) : participantPropertyState({
    id: participantId,
    property: propertyPaths
  }));
  React.useDebugValue(Array.isArray(propertyPaths) ? propertyPaths.reduce(function (o, path, i) {
    o[path] = properties[i];
    return o;
  }, {}) : (_ref3 = {}, _ref3[propertyPaths] = properties, _ref3));
  return properties;
};

/**
 * Sets up a throttled daily event listener using [on](https://docs.daily.co/reference/daily-js/instance-methods/on) method.
 * When this hook is unmounted the event listener is unregistered using [off](https://docs.daily.co/reference/daily-js/instance-methods/off).
 *
 * In comparison to useDailyEvent the callback passed here will be called with an array of event objects.
 *
 * You can pass an array of DailyEvents to register multiple daily events with a single callback handler.
 * The events returned in the callback parameter are guaranteed to be in the same order as they were emitted.
 *
 * @param ev The DailyEvent to register or an array of DailyEvent to register.
 * @param callback A memoized callback reference to run when throttled events are emitted.
 * @param throttleTimeout The minimum waiting time until the callback is called again. Default: 500
 */
var useThrottledDailyEvent = function useThrottledDailyEvent(ev, callback, throttleTimeout, INTERNAL_priority) {
  if (throttleTimeout === void 0) {
    throttleTimeout = 500;
  }
  if (INTERNAL_priority === void 0) {
    INTERNAL_priority = false;
  }
  var _useContext = React.useContext(DailyEventContext),
    off = _useContext.off,
    on = _useContext.on;
  var eventId = React.useMemo(function () {
    var _ref;
    if (Array.isArray(ev)) return ev.reduce(function (r, e) {
      r[e] = INTERNAL_priority ? getPriorityUnique() : getUnique();
      return r;
    }, {});
    return _ref = {}, _ref[ev] = INTERNAL_priority ? getPriorityUnique() : getUnique(), _ref;
  }, [ev, INTERNAL_priority]);
  var throttledEvents = React.useRef([]);
  useDailyEvent('call-instance-destroyed', React.useCallback(function () {
    throttledEvents.current.length = 0;
  }, []));
  var emitEvents = React.useMemo(function () {
    return throttle(function () {
      if (throttledEvents.current.length === 0) return;
      callback(throttledEvents.current);
      throttledEvents.current.length = 0;
    }, throttleTimeout, {
      trailing: true
    });
  }, [callback, throttleTimeout]);
  React.useEffect(function () {
    if (!ev) return;
    var addEvent = function addEvent(ev) {
      throttledEvents.current.push(ev);
      emitEvents();
    };
    if (Array.isArray(ev)) {
      ev.forEach(function (e) {
        return on(e, addEvent, eventId[e]);
      });
    } else {
      on(ev, addEvent, eventId[ev]);
    }
    return function () {
      if (Array.isArray(ev)) {
        ev.forEach(function (e) {
          return off(e, eventId[e]);
        });
      } else {
        off(ev, eventId[ev]);
      }
    };
  }, [emitEvents, ev, eventId, off, on]);
  React.useDebugValue({
    event: ev,
    eventId: eventId
  });
};

/**
 * Compares two variables for deep equality.
 * Gracefully handles equality checks on MediaStreamTracks by comparing their ids.
 */
function customDeepEqual(a, b) {
  if (a === b) return true;
  // Handle special case for MediaStream
  if (a instanceof MediaStream && b instanceof MediaStream) {
    return a.id === b.id && a.active === b.active && a.getTracks().length === b.getTracks().length && a.getTracks().every(function (track, idx) {
      return customDeepEqual(track, b.getTracks()[idx]);
    });
  }
  // Handle special case for MediaStreamTrack
  if (a instanceof MediaStreamTrack && b instanceof MediaStreamTrack) {
    return a.id === b.id && a.kind === b.kind && a.readyState === b.readyState;
  }
  // Handle special case for Date
  if (a instanceof Date && b instanceof Date) {
    return a.getTime() === b.getTime();
  }
  // Handle special case for RegExp
  if (a instanceof RegExp && b instanceof RegExp) {
    return a.source === b.source && a.flags === b.flags;
  }
  // Handle special case for Set
  if (a instanceof Set && b instanceof Set) {
    if (a.size !== b.size) {
      return false;
    }
    for (var _iterator = _createForOfIteratorHelperLoose(a.values()), _step; !(_step = _iterator()).done;) {
      var value = _step.value;
      if (!b.has(value)) {
        return false;
      }
    }
    return true;
  }
  // Handle special case for Map
  if (a instanceof Map && b instanceof Map) {
    if (a.size !== b.size) {
      return false;
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(a.entries()), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
        key = _step2$value[0],
        _value = _step2$value[1];
      if (!b.has(key)) {
        return false;
      }
      if (!customDeepEqual(_value, b.get(key))) {
        return false;
      }
    }
    return true;
  }
  // If a or b are not objects or null, they can't be deeply equal
  if (typeof a !== 'object' || a === null || typeof b !== 'object' || b === null) {
    return false;
  }
  // Get the keys of a and b. This handles both arrays and objects, since arrays are technically objects.
  var keysA = Object.keys(a);
  var keysB = Object.keys(b);
  // If the number of keys are different, the objects are not equal
  if (keysA.length !== keysB.length) return false;
  for (var _i = 0, _keysA = keysA; _i < _keysA.length; _i++) {
    var _key = _keysA[_i];
    if (
    // If key exists in a, but not in b -> not equal
    !(_key in b) ||
    // Both keys exist in both object -> run nested equality check
    !customDeepEqual(a[_key], b[_key])) return false;
  }
  // All keys and values match -> the objects are deeply equal
  return true;
}

/**
 * Same API as [selector](https://recoiljs.org/docs/api-reference/core/selector), but with an additional `equals` key.
 * Allows to run custom equality checks before returning a new calculated value.
 * Use this, when returning non-primitive types from state.
 * Resource: https://github.com/facebookexperimental/Recoil/issues/1416#issuecomment-1044953271
 */
function equalSelector(options) {
  var inner = recoil.selector({
    key: options.key + "_inner",
    get: options.get
  });
  var prior;
  return recoil.selector({
    key: options.key,
    get: function get(_ref) {
      var _get = _ref.get;
      var latest = _get(inner);
      if (prior != null && options.equals(latest, prior)) {
        return prior;
      }
      prior = latest;
      return latest;
    }
  });
}
/**
 * Same API as [selectorFamily](https://recoiljs.org/docs/api-reference/utils/selectorFamily/), but with an additional `equals` key.
 * Allows to run custom equality checks before returning a new calculated value.
 * Use this, when returning non-primitive types from state.
 * Resource: https://github.com/facebookexperimental/Recoil/issues/1416#issuecomment-1168603409
 */
function equalSelectorFamily(options) {
  var inner = recoil.selectorFamily({
    key: options.key + "_inner",
    get: options.get
  });
  var priorValues = new Map();
  return recoil.selectorFamily(_extends({}, options, {
    key: options.key,
    get: function get(param) {
      return function (_ref2) {
        var get = _ref2.get;
        var latest = get(inner(param));
        var prior = priorValues.get(param);
        if (prior != null && options.equals(latest, prior)) {
          return prior;
        }
        priorValues.set(param, latest);
        return latest;
      };
    }
  }));
}

/**
 * Returns all property paths for an object.
 */
var getPaths = function getPaths(o, currentPath, visited) {
  if (currentPath === void 0) {
    currentPath = '';
  }
  if (visited === void 0) {
    visited = new Set();
  }
  if (typeof o !== 'object' || o === null || visited.has(o)) {
    return [currentPath];
  }
  visited.add(o);
  var paths = [];
  for (var key in o) {
    if (Object.prototype.hasOwnProperty.call(o, key)) {
      var newPath = currentPath ? currentPath + "." + key : key;
      paths.push.apply(paths, [newPath].concat(getPaths(o[key], newPath, visited)));
    }
  }
  visited["delete"](o);
  return paths;
};
/**
 * Returns all property paths for a given participant object.
 */
var getParticipantPaths = function getParticipantPaths(p) {
  return getPaths(p);
};

var resolvePath = function resolvePath(participant, path) {
  return String(path).split('.').filter(function (key) {
    return key.length;
  }).reduce(function (p, key) {
    return p && p[key];
  }, participant);
};
var resolveParticipantPaths = function resolveParticipantPaths(participant, paths) {
  return paths.map(function (path) {
    return resolvePath(participant, path);
  });
};

/**
 * Stores the most recent peerId as reported from [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.
 */
var activeIdState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'active-id',
  "default": null
});
var localIdState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'local-id',
  "default": ''
});
var localJoinDateState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'local-joined-date',
  "default": null
});
var participantIdsState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'participant-ids',
  "default": []
});
var participantState = /*#__PURE__*/recoil.atomFamily({
  key: RECOIL_PREFIX + 'participant-state',
  "default": null,
  dangerouslyAllowMutability: true
});
/**
 * Holds all participants in the waiting room.
 */
var waitingParticipantsState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'waiting-participants',
  "default": []
});
/**
 * Holds each invidiual waiting participant's information.
 */
var waitingParticipantState = /*#__PURE__*/recoil.atomFamily({
  key: RECOIL_PREFIX + 'waiting-participant',
  "default": {
    awaitingAccess: {
      level: 'full'
    },
    id: '',
    name: ''
  }
});
/**
 * Returns all waiting participant objects in an array.
 */
var allWaitingParticipantsSelector = /*#__PURE__*/equalSelector({
  key: RECOIL_PREFIX + 'waitingParticipantsSelector',
  equals: customDeepEqual,
  get: function get(_ref2) {
    var _get2 = _ref2.get;
    var ids = _get2(waitingParticipantsState);
    return ids.map(function (id) {
      return _get2(waitingParticipantState(id));
    });
  }
});
var DailyParticipants = function DailyParticipants(_ref3) {
  var children = _ref3.children;
  var daily = useDaily();
  var _useState = React.useState(false),
    initialized = _useState[0],
    setInitialized = _useState[1];
  var initParticipants = recoil.useRecoilCallback(function (_ref4) {
    var transact_UNSTABLE = _ref4.transact_UNSTABLE;
    return function (participants) {
      transact_UNSTABLE(function (_ref5) {
        var set = _ref5.set;
        set(localIdState, participants.local.session_id);
        var participantsArray = Object.values(participants);
        var ids = participantsArray.map(function (p) {
          return p.session_id;
        });
        set(participantIdsState, ids);
        participantsArray.forEach(function (p) {
          set(participantState(p.session_id), p);
          var paths = getParticipantPaths(p);
          // Set list of property paths
          set(participantPropertyPathsState(p.session_id), paths);
          // Set all property path values
          paths.forEach(function (property) {
            var _resolveParticipantPa = resolveParticipantPaths(p, [property]),
              value = _resolveParticipantPa[0];
            set(participantPropertyState({
              id: p.session_id,
              property: property
            }), value);
          });
        });
        setInitialized(true);
      });
    };
  }, []);
  /**
   * Initialize participants state based on daily.participants().
   * Retries every 100ms to initialize the state, until daily is ready.
   */
  React.useEffect(function () {
    if (!daily || initialized) return;
    var interval = setInterval(function () {
      var participants = daily.participants();
      if (!('local' in participants)) return;
      initParticipants(participants);
      clearInterval(interval);
    }, 100);
    return function () {
      clearInterval(interval);
    };
  }, [daily, initialized, initParticipants]);
  var handleInitEvent = React.useCallback(function () {
    if (!daily) return;
    var participants = daily == null ? void 0 : daily.participants();
    if (!participants.local) return;
    initParticipants(participants);
  }, [daily, initParticipants]);
  useDailyEvent('started-camera', handleInitEvent, true);
  useDailyEvent('access-state-updated', handleInitEvent, true);
  useDailyEvent('joining-meeting', recoil.useRecoilCallback(function (_ref6) {
    var set = _ref6.set;
    return function () {
      set(localJoinDateState, new Date());
      handleInitEvent();
    };
  }, [handleInitEvent]), true);
  useDailyEvent('joined-meeting', React.useCallback(function (ev) {
    initParticipants(ev.participants);
  }, [initParticipants]), true);
  /**
   * Reset stored participants, when meeting has ended.
   */
  var handleCleanup = recoil.useRecoilCallback(function (_ref7) {
    var reset = _ref7.reset,
      snapshot = _ref7.snapshot;
    return /*#__PURE__*/_asyncToGenerator(function* () {
      reset(localIdState);
      reset(activeIdState);
      var ids = yield snapshot.getPromise(participantIdsState);
      if (Array.isArray(ids)) ids.forEach(function (id) {
        return reset(participantState(id));
      });
      reset(participantIdsState);
    });
  }, []);
  useDailyEvent('call-instance-destroyed', handleCleanup, true);
  useDailyEvent('left-meeting', handleCleanup, true);
  useThrottledDailyEvent(['active-speaker-change', 'participant-joined', 'participant-updated', 'participant-left'], recoil.useRecoilCallback(function (_ref9) {
    var transact_UNSTABLE = _ref9.transact_UNSTABLE;
    return function (evts) {
      if (!evts.length) return;
      transact_UNSTABLE(function (_ref10) {
        var get = _ref10.get,
          reset = _ref10.reset,
          set = _ref10.set;
        evts.forEach(function (ev) {
          switch (ev.action) {
            case 'active-speaker-change':
              {
                set(activeIdState, ev.activeSpeaker.peerId);
                set(participantState(ev.activeSpeaker.peerId), function (prev) {
                  if (!prev) return null;
                  return _extends({}, prev, {
                    last_active: new Date()
                  });
                });
                break;
              }
            case 'participant-joined':
              {
                // Update list of ids
                set(participantIdsState, function (prevIds) {
                  return prevIds.includes(ev.participant.session_id) ? prevIds : [].concat(prevIds, [ev.participant.session_id]);
                });
                // Store entire object
                set(participantState(ev.participant.session_id), ev.participant);
                var paths = getParticipantPaths(ev.participant);
                // Set list of property paths
                set(participantPropertyPathsState(ev.participant.session_id), paths);
                // Set all property path values
                paths.forEach(function (property) {
                  var _resolveParticipantPa2 = resolveParticipantPaths(ev.participant, [property]),
                    value = _resolveParticipantPa2[0];
                  set(participantPropertyState({
                    id: ev.participant.session_id,
                    property: property
                  }), value);
                });
                break;
              }
            case 'participant-updated':
              {
                // Update entire object
                set(participantState(ev.participant.session_id), function (prev) {
                  return _extends({}, prev, ev.participant);
                });
                // Update local session_id
                if (ev.participant.local) {
                  set(localIdState, function (prevId) {
                    return prevId !== ev.participant.session_id ? ev.participant.session_id : prevId;
                  });
                }
                var _paths = getParticipantPaths(ev.participant);
                var oldPaths = get(participantPropertyPathsState(ev.participant.session_id));
                // Set list of property paths
                set(participantPropertyPathsState(ev.participant.session_id), function (prev) {
                  return customDeepEqual(prev, _paths) ? prev : _paths;
                });
                // Reset old path values
                oldPaths.filter(function (p) {
                  return !_paths.includes(p);
                }).forEach(function (property) {
                  reset(participantPropertyState({
                    id: ev.participant.session_id,
                    property: property
                  }));
                });
                // Set all property path values
                _paths.forEach(function (property) {
                  var _resolveParticipantPa3 = resolveParticipantPaths(ev.participant, [property]),
                    value = _resolveParticipantPa3[0];
                  set(participantPropertyState({
                    id: ev.participant.session_id,
                    property: property
                  }), function (prev) {
                    return customDeepEqual(prev, value) ? prev : value;
                  });
                });
                break;
              }
            case 'participant-left':
              {
                // Remove from list of ids
                set(participantIdsState, function (prevIds) {
                  return prevIds.includes(ev.participant.session_id) ? [].concat(prevIds.filter(function (id) {
                    return id !== ev.participant.session_id;
                  })) : prevIds;
                });
                // Remove entire object
                reset(participantState(ev.participant.session_id));
                var _oldPaths = get(participantPropertyPathsState(ev.participant.session_id));
                // Remove property path values
                _oldPaths.forEach(function (property) {
                  reset(participantPropertyState({
                    id: ev.participant.session_id,
                    property: property
                  }));
                });
                // Remove all property paths
                reset(participantPropertyPathsState(ev.participant.session_id));
                break;
              }
          }
        });
      });
    };
  }, []), 100, true);
  useThrottledDailyEvent(['waiting-participant-added', 'waiting-participant-updated', 'waiting-participant-removed'], recoil.useRecoilCallback(function (_ref11) {
    var transact_UNSTABLE = _ref11.transact_UNSTABLE;
    return function (evts) {
      transact_UNSTABLE(function (_ref12) {
        var reset = _ref12.reset,
          set = _ref12.set;
        evts.forEach(function (ev) {
          switch (ev.action) {
            case 'waiting-participant-added':
              set(waitingParticipantsState, function (wps) {
                if (!wps.includes(ev.participant.id)) {
                  return [].concat(wps, [ev.participant.id]);
                }
                return wps;
              });
              set(waitingParticipantState(ev.participant.id), ev.participant);
              break;
            case 'waiting-participant-updated':
              set(waitingParticipantState(ev.participant.id), ev.participant);
              break;
            case 'waiting-participant-removed':
              set(waitingParticipantsState, function (wps) {
                return wps.filter(function (wp) {
                  return wp !== ev.participant.id;
                });
              });
              reset(waitingParticipantState(ev.participant.id));
              break;
          }
        });
      });
    };
  }, []), 100, true);
  return React__default.createElement(React__default.Fragment, null, children);
};

/**
 * Returns the local participant's session_id or empty string '',
 * if the local participant doesn't exist.
 */
var useLocalSessionId = function useLocalSessionId() {
  var localId = recoil.useRecoilValue(localIdState);
  React.useDebugValue(localId);
  return localId;
};

var noopFilter = function noopFilter() {
  return true;
};
/**
 * Returns the most recent speaker id mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.
 */
var useActiveSpeakerId = function useActiveSpeakerId(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    _ref$filter = _ref.filter,
    filter = _ref$filter === void 0 ? noopFilter : _ref$filter,
    _ref$ignoreLocal = _ref.ignoreLocal,
    ignoreLocal = _ref$ignoreLocal === void 0 ? false : _ref$ignoreLocal;
  var localSessionId = useLocalSessionId();
  var recentActiveId = recoil.useRecoilValue(activeIdState);
  var isIgnoredLocalId = ignoreLocal && recentActiveId === localSessionId;
  var isFilteredOut = !(filter != null && filter(recentActiveId));
  var isRecentIdRelevant = !isIgnoredLocalId && !isFilteredOut;
  var _useState = React.useState(isRecentIdRelevant ? recentActiveId : null),
    activeId = _useState[0],
    setActiveId = _useState[1];
  React.useEffect(function () {
    if (isIgnoredLocalId || isFilteredOut) return;
    setActiveId(recentActiveId);
  }, [isFilteredOut, isIgnoredLocalId, recentActiveId]);
  React.useDebugValue(activeId);
  return activeId;
};

var isTrackOff = function isTrackOff(trackState) {
  return ['blocked', 'off'].includes(trackState);
};

/**
 * Short-cut state selector for useParticipantIds({ filter: 'local' })
 */
var participantIdsFilteredAndSortedState = /*#__PURE__*/equalSelectorFamily({
  key: RECOIL_PREFIX + 'participant-ids-filtered-sorted',
  equals: customDeepEqual,
  get: function get(_ref) {
    var filter = _ref.filter,
      sort = _ref.sort;
    return function (_ref2) {
      var get = _ref2.get;
      var ids = get(participantIdsState);
      return ids.filter(function (id) {
        switch (filter) {
          /**
           * Simple boolean fields first.
           */
          case 'local':
          case 'owner':
          case 'record':
            {
              return get(participantPropertyState({
                id: id,
                property: filter
              }));
            }
          case 'remote':
            {
              return !get(participantPropertyState({
                id: id,
                property: 'local'
              }));
            }
          case 'screen':
            {
              var _get = get(participantPropertiesState({
                  id: id,
                  properties: ['tracks.screenAudio.state', 'tracks.screenVideo.state']
                })),
                screenAudioState = _get[0],
                screenVideoState = _get[1];
              return !isTrackOff(screenAudioState) || !isTrackOff(screenVideoState);
            }
          default:
            return true;
        }
      }).sort(function (idA, idB) {
        switch (sort) {
          case 'joined_at':
          case 'session_id':
          case 'user_id':
          case 'user_name':
            {
              var _get2 = get(participantPropertiesState({
                  id: idA,
                  properties: [sort]
                })),
                aSort = _get2[0];
              var _get3 = get(participantPropertiesState({
                  id: idB,
                  properties: [sort]
                })),
                bSort = _get3[0];
              if (aSort !== undefined || bSort !== undefined) {
                if (aSort === undefined) return -1;
                if (bSort === undefined) return 1;
                if (aSort > bSort) return 1;
                if (aSort < bSort) return -1;
              }
              return 0;
            }
          default:
            return 0;
        }
      });
    };
  }
});
/**
 * Returns a list of participant ids (= session_id).
 * The list can optionally be filtered and sorted, using the filter and sort options.
 */
var useParticipantIds = function useParticipantIds(_temp) {
  var _ref3 = _temp === void 0 ? {} : _temp,
    filter = _ref3.filter,
    onActiveSpeakerChange = _ref3.onActiveSpeakerChange,
    onParticipantJoined = _ref3.onParticipantJoined,
    onParticipantLeft = _ref3.onParticipantLeft,
    onParticipantUpdated = _ref3.onParticipantUpdated,
    sort = _ref3.sort;
  /**
   * For instances of useParticipantIds with string-based filter and sort,
   * we can immediately return the correct ids from Recoil's state.
   */
  var preFilteredSortedIds = recoil.useRecoilValue(participantIdsFilteredAndSortedState({
    filter: typeof filter === 'string' ? filter : null,
    sort: typeof sort === 'string' ? sort : null
  }));
  var shouldUseCustomIds = typeof filter === 'function' || typeof sort === 'function';
  var getCustomFilteredIds = React.useCallback(function (snapshot) {
    if (
    // Ignore if both filter and sort are not functions.
    typeof filter !== 'function' && typeof sort !== 'function') return [];
    var participants = preFilteredSortedIds.map(function (id) {
      return snapshot.getLoadable(participantState(id)).contents;
    });
    return participants
    // Make sure we don't accidentally try to filter/sort `null` participants
    // This can happen when a participant's id is already present in store
    // but the participant object is not stored, yet.
    .filter(Boolean)
    // Run custom filter, if it's a function. Otherwise don't filter any participants.
    .filter(typeof filter === 'function' ? filter : function () {
      return true;
    })
    // Run custom sort, if it's a function. Otherwise don't sort.
    .sort(typeof sort === 'function' ? sort : function () {
      return 0;
    })
    // Map back to session_id.
    .map(function (p) {
      return p.session_id;
    })
    // Filter any potential null/undefined ids.
    // This shouldn't really happen, but better safe than sorry.
    .filter(Boolean);
  }, [filter, preFilteredSortedIds, sort]);
  var _useState = React.useState([]),
    customIds = _useState[0],
    setCustomIds = _useState[1];
  var maybeUpdateCustomIds = recoil.useRecoilCallback(function (_ref4) {
    var snapshot = _ref4.snapshot;
    return function () {
      if (!shouldUseCustomIds) return;
      var newIds = getCustomFilteredIds(snapshot);
      if (customDeepEqual(newIds, customIds)) return;
      setCustomIds(newIds);
    };
  }, [customIds, getCustomFilteredIds, shouldUseCustomIds]);
  React.useEffect(function () {
    maybeUpdateCustomIds();
  }, [maybeUpdateCustomIds]);
  useThrottledDailyEvent(['participant-joined', 'participant-updated', 'active-speaker-change', 'participant-left'], React.useCallback(function (evts) {
    if (!evts.length) return;
    evts.forEach(function (ev) {
      switch (ev.action) {
        case 'participant-joined':
          onParticipantJoined == null ? void 0 : onParticipantJoined(ev);
          break;
        case 'participant-updated':
          onParticipantUpdated == null ? void 0 : onParticipantUpdated(ev);
          break;
        case 'active-speaker-change':
          onActiveSpeakerChange == null ? void 0 : onActiveSpeakerChange(ev);
          break;
        case 'participant-left':
          onParticipantLeft == null ? void 0 : onParticipantLeft(ev);
          break;
      }
    });
    maybeUpdateCustomIds();
  }, [maybeUpdateCustomIds, onActiveSpeakerChange, onParticipantJoined, onParticipantLeft, onParticipantUpdated]));
  var result = typeof filter === 'function' || typeof sort === 'function' ? customIds : preFilteredSortedIds;
  React.useDebugValue(result);
  return result;
};

var screenSharesState = /*#__PURE__*/equalSelector({
  key: RECOIL_PREFIX + 'screen-shares',
  equals: customDeepEqual,
  get: function get(_ref) {
    var _get = _ref.get;
    var screenIds = _get(participantIdsFilteredAndSortedState({
      filter: 'screen',
      sort: null
    }));
    return screenIds.map(function (id) {
      return {
        local: _get(participantPropertyState({
          id: id,
          property: 'local'
        })),
        screenAudio: _get(participantPropertyState({
          id: id,
          property: 'tracks.screenAudio'
        })),
        screenVideo: _get(participantPropertyState({
          id: id,
          property: 'tracks.screenVideo'
        })),
        screenId: id + "-screen",
        session_id: id
      };
    });
  }
});
/**
 * Allows access to information about shared screens, and methods to start or stop a local screen share.
 */
var useScreenShare = function useScreenShare(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp,
    onError = _ref2.onError,
    onLocalScreenShareStarted = _ref2.onLocalScreenShareStarted,
    onLocalScreenShareStopped = _ref2.onLocalScreenShareStopped;
  var daily = useDaily();
  var startScreenShare = React.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    daily == null ? void 0 : daily.startScreenShare.apply(daily, args);
  }, [daily]);
  var stopScreenShare = React.useCallback(function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    daily == null ? void 0 : daily.stopScreenShare.apply(daily, args);
  }, [daily]);
  useDailyEvent('local-screen-share-started', React.useCallback(function () {
    return onLocalScreenShareStarted == null ? void 0 : onLocalScreenShareStarted();
  }, [onLocalScreenShareStarted]));
  useDailyEvent('local-screen-share-stopped', React.useCallback(function () {
    return onLocalScreenShareStopped == null ? void 0 : onLocalScreenShareStopped();
  }, [onLocalScreenShareStopped]));
  useDailyEvent('nonfatal-error', React.useCallback(function (ev) {
    if (ev.type !== 'screen-share-error') return;
    onError == null ? void 0 : onError(ev);
  }, [onError]));
  var screens = recoil.useRecoilValue(screenSharesState);
  var result = {
    isSharingScreen: screens.some(function (s) {
      return s.local;
    }),
    screens: screens,
    startScreenShare: startScreenShare,
    stopScreenShare: stopScreenShare
  };
  React.useDebugValue(result);
  return result;
};

/**
 * Returns a participant's track and state, based on the given MediaType.
 *
 * Equivalent to daily.participants()[participantId].tracks[type].
 *
 * @param participantId The participant's session_id.
 * @param type The track type. Default: "video"
 */
var useMediaTrack = function useMediaTrack(participantId, type) {
  if (type === void 0) {
    type = 'video';
  }
  var trackState = useParticipantProperty(participantId, "tracks." + type);
  var result = trackState ? _extends({}, trackState, {
    isOff: isTrackOff(trackState.state)
  }) : {
    isOff: true,
    persistentTrack: undefined,
    state: 'off',
    subscribed: false
  };
  React.useDebugValue(result);
  return result;
};

/**
 * Original source: https://github.com/jaredLunde/react-hook/blob/master/packages/merged-ref/src/index.tsx
 * Original author: Jared Lunde (https://github.com/jaredLunde)
 * Originally published under the MIT license: https://github.com/jaredLunde/react-hook/blob/master/LICENSE
 */
function useMergedRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return React.useCallback(function (element) {
    for (var i = 0; i < refs.length; i++) {
      var ref = refs[i];
      if (typeof ref === 'function') ref(element);else if (ref && typeof ref === 'object') ref.current = element;
    }
  },
  // eslint-disable-next-line react-hooks/exhaustive-deps
  refs);
}

var _excluded = ["onPlayFailed", "sessionId", "type"];
var DailyAudioTrack = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var onPlayFailed = _ref.onPlayFailed,
    sessionId = _ref.sessionId,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'audio' : _ref$type,
    props = _objectWithoutPropertiesLoose(_ref, _excluded);
  var audioEl = React.useRef(null);
  var audio = useMediaTrack(sessionId, type);
  var audioRef = useMergedRef(audioEl, ref);
  var subscribedState = audio == null ? void 0 : audio.subscribed;
  /**
   * Setup audio tag.
   */
  React.useEffect(function () {
    var audioTag = audioEl.current;
    if (!audioTag || !(audio != null && audio.persistentTrack)) return;
    var playTimeout;
    var handleCanPlay = function handleCanPlay() {
      audioTag.play()["catch"](function (e) {
        onPlayFailed == null ? void 0 : onPlayFailed({
          sessionId: sessionId,
          target: audioTag,
          type: type,
          message: e.message,
          name: e.name
        });
      });
    };
    var handlePlay = function handlePlay() {
      clearTimeout(playTimeout);
    };
    audioTag.addEventListener('canplay', handleCanPlay);
    audioTag.addEventListener('play', handlePlay);
    audioTag.srcObject = new MediaStream([audio == null ? void 0 : audio.persistentTrack]);
    return function () {
      audioTag == null ? void 0 : audioTag.removeEventListener('canplay', handleCanPlay);
      audioTag == null ? void 0 : audioTag.removeEventListener('play', handlePlay);
    };
  }, [audio == null ? void 0 : audio.persistentTrack, onPlayFailed, sessionId, type]);
  return React__default.createElement("audio", Object.assign({
    autoPlay: true,
    ref: audioRef
  }, props, {
    "data-session-id": sessionId,
    "data-audio-type": type,
    "data-subscribed": subscribedState
  }));
}));
DailyAudioTrack.displayName = 'DailyAudioTrack';

var DailyAudio = /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$autoSubscribeAct = _ref.autoSubscribeActiveSpeaker,
    autoSubscribeActiveSpeaker = _ref$autoSubscribeAct === void 0 ? false : _ref$autoSubscribeAct,
    _ref$maxSpeakers = _ref.maxSpeakers,
    maxSpeakers = _ref$maxSpeakers === void 0 ? 5 : _ref$maxSpeakers,
    onPlayFailed = _ref.onPlayFailed,
    _ref$playLocalScreenA = _ref.playLocalScreenAudio,
    playLocalScreenAudio = _ref$playLocalScreenA === void 0 ? false : _ref$playLocalScreenA;
  var daily = useDaily();
  var _useState = React.useState(new Array(maxSpeakers).fill('')),
    speakers = _useState[0],
    setSpeakers = _useState[1];
  var _useScreenShare = useScreenShare(),
    screens = _useScreenShare.screens;
  var localSessionId = useLocalSessionId();
  var activeSpeakerId = useActiveSpeakerId({
    ignoreLocal: true
  });
  var containerRef = React.useRef(null);
  React.useImperativeHandle(ref, function () {
    return {
      getActiveSpeakerAudio: function getActiveSpeakerAudio() {
        var _containerRef$current, _containerRef$current2;
        return (_containerRef$current = (_containerRef$current2 = containerRef.current) == null ? void 0 : _containerRef$current2.querySelector("audio[data-session-id=\"" + activeSpeakerId + "\"][data-audio-type=\"audio\"]")) != null ? _containerRef$current : null;
      },
      getAllAudio: function getAllAudio() {
        var _containerRef$current3, _containerRef$current4;
        return Array.from((_containerRef$current3 = (_containerRef$current4 = containerRef.current) == null ? void 0 : _containerRef$current4.querySelectorAll('audio')) != null ? _containerRef$current3 : []);
      },
      getAudioBySessionId: function getAudioBySessionId(id) {
        var _containerRef$current5, _containerRef$current6;
        return (_containerRef$current5 = (_containerRef$current6 = containerRef.current) == null ? void 0 : _containerRef$current6.querySelector("audio[data-session-id=\"" + id + "\"][data-audio-type=\"audio\"]")) != null ? _containerRef$current5 : null;
      },
      getRmpAudio: function getRmpAudio() {
        var _containerRef$current7, _containerRef$current8;
        return Array.from((_containerRef$current7 = (_containerRef$current8 = containerRef.current) == null ? void 0 : _containerRef$current8.querySelectorAll('audio[data-audio-type="rmpAudio"]')) != null ? _containerRef$current7 : []);
      },
      getScreenAudio: function getScreenAudio() {
        var _containerRef$current9, _containerRef$current10;
        return Array.from((_containerRef$current9 = (_containerRef$current10 = containerRef.current) == null ? void 0 : _containerRef$current10.querySelectorAll('audio[data-audio-type="screenAudio"]')) != null ? _containerRef$current9 : []);
      },
      getRmpAudioBySessionId: function getRmpAudioBySessionId(id) {
        var _containerRef$current11, _containerRef$current12;
        return (_containerRef$current11 = (_containerRef$current12 = containerRef.current) == null ? void 0 : _containerRef$current12.querySelector("audio[data-session-id=\"" + id + "\"][data-audio-type=\"rmpAudio\"]")) != null ? _containerRef$current11 : null;
      },
      getScreenAudioBySessionId: function getScreenAudioBySessionId(id) {
        var _containerRef$current13, _containerRef$current14;
        return (_containerRef$current13 = (_containerRef$current14 = containerRef.current) == null ? void 0 : _containerRef$current14.querySelector("audio[data-session-id=\"" + id + "\"][data-audio-type=\"screenAudio\"]")) != null ? _containerRef$current13 : null;
      }
    };
  }, [activeSpeakerId]);
  var assignSpeaker = recoil.useRecoilCallback(function (_ref2) {
    var snapshot = _ref2.snapshot;
    return /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (sessionId) {
        var _daily$participants;
        /**
         * Only consider remote participants with subscribed or staged audio.
         */
        var subscribedParticipants = Object.values((_daily$participants = daily == null ? void 0 : daily.participants()) != null ? _daily$participants : {}).filter(function (p) {
          return !p.local && Boolean(p.tracks.audio.subscribed);
        });
        var isSubscribed = function isSubscribed(id) {
          return subscribedParticipants.some(function (p) {
            return p.session_id === id;
          });
        };
        if (!isSubscribed(sessionId)) {
          if (daily && !daily.isDestroyed() && autoSubscribeActiveSpeaker && !daily.subscribeToTracksAutomatically()) {
            daily.updateParticipant(sessionId, {
              setSubscribedTracks: {
                audio: true
              }
            });
          } else {
            return;
          }
        }
        setSpeakers(function (prevSpeakers) {
          var _speakerObjects$;
          // New speaker is already present
          if (prevSpeakers.includes(sessionId)) return prevSpeakers;
          // Try to find a free slot: either unassigned or unsubscribed
          var freeSlotCheck = function freeSlotCheck(id) {
            return !id || !isSubscribed(id);
          };
          if (prevSpeakers.some(freeSlotCheck)) {
            var idx = prevSpeakers.findIndex(freeSlotCheck);
            prevSpeakers[idx] = sessionId;
            return [].concat(prevSpeakers);
          }
          // From here on we can assume that all assigned audio tracks are subscribed.
          // Try to find muted recent speaker
          var mutedIdx = prevSpeakers.findIndex(function (id) {
            return subscribedParticipants.some(function (p) {
              return p.session_id === id && isTrackOff(p.tracks.audio.state);
            });
          });
          if (mutedIdx >= 0) {
            prevSpeakers[mutedIdx] = sessionId;
            return [].concat(prevSpeakers);
          }
          // Find least recent non-active speaker and replace with new speaker
          var speakerObjects = subscribedParticipants.filter(function (p) {
            return (
              // Only consider participants currently assigned to speaker slots
              prevSpeakers.includes(p.session_id) &&
              // Don't replace current active participant, to avoid audio drop-outs
              p.session_id !== activeSpeakerId
            );
          }).sort(function (a, b) {
            var _snapshot$getLoadable, _snapshot$getLoadable2;
            var lastActiveA = (_snapshot$getLoadable = snapshot.getLoadable(participantPropertyState({
              id: a.session_id,
              property: 'last_active'
            })).contents) != null ? _snapshot$getLoadable : new Date('1970-01-01');
            var lastActiveB = (_snapshot$getLoadable2 = snapshot.getLoadable(participantPropertyState({
              id: b.session_id,
              property: 'last_active'
            })).contents) != null ? _snapshot$getLoadable2 : new Date('1970-01-01');
            if (lastActiveA > lastActiveB) return 1;
            if (lastActiveA < lastActiveB) return -1;
            return 0;
          });
          // No previous speaker in call anymore. Assign first free slot.
          if (!speakerObjects.length) {
            // Don't replace the active speaker. Instead find first non-active speaker slot.
            var _replaceIdx = prevSpeakers.findIndex(function (id) {
              return id !== activeSpeakerId;
            });
            prevSpeakers[_replaceIdx] = sessionId;
            return [].concat(prevSpeakers);
          }
          // Replace least recent speaker with new speaker
          var replaceIdx = prevSpeakers.indexOf((_speakerObjects$ = speakerObjects[0]) == null ? void 0 : _speakerObjects$.session_id);
          prevSpeakers[replaceIdx] = sessionId;
          return [].concat(prevSpeakers);
        });
      });
      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }();
  }, [activeSpeakerId, autoSubscribeActiveSpeaker, daily]);
  /**
   * Unassigns speaker from speaker slot, e.g. because participant left the call.
   */
  var removeSpeaker = React.useCallback(function (sessionId) {
    setSpeakers(function (prevSpeakers) {
      if (!prevSpeakers.includes(sessionId)) return prevSpeakers;
      var newSpeakers = [].concat(prevSpeakers);
      var idx = newSpeakers.indexOf(sessionId);
      newSpeakers[idx] = '';
      return newSpeakers;
    });
  }, []);
  useThrottledDailyEvent(['active-speaker-change', 'track-started', 'participant-left'], React.useCallback(function (evts) {
    evts.forEach(function (ev) {
      switch (ev.action) {
        case 'active-speaker-change':
          if (ev.activeSpeaker.peerId === localSessionId) return;
          assignSpeaker(ev.activeSpeaker.peerId);
          break;
        case 'track-started':
          if (ev.track.kind === 'audio' && ev.participant && !ev.participant.local) {
            assignSpeaker(ev.participant.session_id);
          }
          break;
        case 'participant-left':
          removeSpeaker(ev.participant.session_id);
          break;
      }
    });
  }, [assignSpeaker, localSessionId, removeSpeaker]), 200);
  var rmpAudioIds = useParticipantIds({
    filter: React.useCallback(function (p) {
      var _p$tracks;
      return Boolean(p == null ? void 0 : (_p$tracks = p.tracks) == null ? void 0 : _p$tracks.rmpAudio);
    }, [])
  });
  return React__default.createElement("div", {
    ref: containerRef
  }, speakers.map(function (sessionId, idx) {
    return React__default.createElement(DailyAudioTrack, {
      key: "speaker-slot-" + idx,
      onPlayFailed: onPlayFailed,
      sessionId: sessionId,
      type: "audio"
    });
  }), screens.filter(function (screen) {
    return playLocalScreenAudio ? true : !screen.local;
  }).map(function (screen) {
    return React__default.createElement(DailyAudioTrack, {
      key: screen.screenId,
      onPlayFailed: onPlayFailed,
      sessionId: screen.session_id,
      type: "screenAudio"
    });
  }), rmpAudioIds.map(function (id) {
    return React__default.createElement(DailyAudioTrack, {
      key: id + "-rmp",
      onPlayFailed: onPlayFailed,
      sessionId: id,
      type: "rmpAudio"
    });
  }));
}));
DailyAudio.displayName = 'DailyAudio';

var _excluded$1 = ["automirror", "fit", "mirror", "onResize", "playableStyle", "sessionId", "style", "type"];
var DailyVideo = /*#__PURE__*/React.forwardRef(function DailyVideo(_ref, ref) {
  var automirror = _ref.automirror,
    _ref$fit = _ref.fit,
    fit = _ref$fit === void 0 ? 'contain' : _ref$fit,
    mirror = _ref.mirror,
    onResize = _ref.onResize,
    _ref$playableStyle = _ref.playableStyle,
    playableStyle = _ref$playableStyle === void 0 ? {} : _ref$playableStyle,
    sessionId = _ref.sessionId,
    _ref$style = _ref.style,
    style = _ref$style === void 0 ? {} : _ref$style,
    _ref$type = _ref.type,
    type = _ref$type === void 0 ? 'video' : _ref$type,
    props = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  var localSessionId = useLocalSessionId();
  var isLocal = localSessionId === sessionId;
  var isScreen = type === 'screenVideo';
  var isLocalCam = isLocal && !isScreen;
  var videoEl = React.useRef(null);
  var videoRef = useMergedRef(videoEl, ref);
  var videoState = useMediaTrack(sessionId, type);
  var videoTrack = videoState.persistentTrack;
  /**
   * Considered as playable video:
   * - local cam feed
   * - any screen share
   * - remote cam feed that is subscribed and reported as playable
   */
  var isPlayable = isLocalCam || isScreen || !videoState.isOff;
  var trackState = useParticipantProperty(sessionId, "tracks." + type);
  var subscribedState = trackState == null ? void 0 : trackState.subscribed;
  /**
   * Determine if video needs to be mirrored.
   */
  var isMirrored = React.useMemo(function () {
    if (typeof mirror === 'boolean') return mirror;
    if (!automirror) return false;
    if (!videoTrack) return isLocalCam;
    var videoTrackSettings = videoTrack.getSettings();
    var isUsersFrontCamera = 'facingMode' in videoTrackSettings ? isLocalCam && videoTrackSettings.facingMode === 'user' : isLocalCam;
    // only apply mirror effect to user facing camera
    return isUsersFrontCamera;
  }, [automirror, isLocalCam, mirror, videoTrack]);
  /**
   * Handle canplay & picture-in-picture events.
   */
  React.useEffect(function setupVideoEvents() {
    var video = videoEl.current;
    if (!video) return;
    var playVideo = function playVideo() {
      var promise = video.play();
      if (promise !== undefined) {
        promise.then(function () {
          // All good, playback started.
          video.controls = false;
        })["catch"](function (error) {
          // Auto-play was prevented. Show video controls, so user can play video manually.
          video.controls = true;
          console.warn('Failed to play video', error);
        });
      }
    };
    var handleCanPlay = function handleCanPlay() {
      if (!video.paused) return;
      playVideo();
    };
    var handleEnterPIP = function handleEnterPIP() {
      video.style.transform = 'scale(1)';
    };
    var handleLeavePIP = function handleLeavePIP() {
      video.style.transform = '';
      setTimeout(function () {
        if (video.paused) playVideo();
      }, 100);
    };
    var handleVisibilityChange = function handleVisibilityChange() {
      if (document.visibilityState === 'hidden') return;
      if (!video.paused) return;
      playVideo();
    };
    video.addEventListener('canplay', handleCanPlay);
    video.addEventListener('enterpictureinpicture', handleEnterPIP);
    video.addEventListener('leavepictureinpicture', handleLeavePIP);
    // Videos can be paused if media was played in another app on iOS.
    // Resuming here, when returning back to Daily call.
    document.addEventListener('visibilitychange', handleVisibilityChange);
    return function () {
      video.removeEventListener('canplay', handleCanPlay);
      video.removeEventListener('enterpictureinpicture', handleEnterPIP);
      video.removeEventListener('leavepictureinpicture', handleLeavePIP);
      document.removeEventListener('visibilitychange', handleVisibilityChange);
    };
  }, []);
  /**
   * Update srcObject.
   */
  React.useEffect(function updateSrcObject() {
    var video = videoEl.current;
    if (!video || !videoTrack) return;
    video.srcObject = new MediaStream([videoTrack]);
    video.load();
    return function () {
      // clean up when unmounted
      video.srcObject = null;
      video.load();
    };
  }, [videoTrack, videoTrack == null ? void 0 : videoTrack.id]);
  /**
   * Add optional event listener for resize event so the parent component
   * can know the video's native aspect ratio.
   */
  React.useEffect(function reportVideoDimensions() {
    var video = videoEl.current;
    if (!onResize || !video) return;
    var frame;
    function handleResize() {
      if (frame) cancelAnimationFrame(frame);
      frame = requestAnimationFrame(function () {
        var video = videoEl.current;
        if (!video || document.hidden) return;
        var videoWidth = video.videoWidth;
        var videoHeight = video.videoHeight;
        if (videoWidth && videoHeight) {
          onResize == null ? void 0 : onResize({
            aspectRatio: videoWidth / videoHeight,
            height: videoHeight,
            width: videoWidth
          });
        }
      });
    }
    handleResize();
    video.addEventListener('loadedmetadata', handleResize);
    video.addEventListener('resize', handleResize);
    return function () {
      if (frame) cancelAnimationFrame(frame);
      video.removeEventListener('loadedmetadata', handleResize);
      video.removeEventListener('resize', handleResize);
    };
  }, [onResize]);
  return React__default.createElement("video", Object.assign({
    autoPlay: true,
    muted: true,
    playsInline: true,
    ref: videoRef,
    "data-local": isLocal,
    "data-mirrored": isMirrored || undefined,
    "data-playable": isPlayable || undefined,
    "data-session-id": sessionId,
    "data-subscribed": subscribedState,
    "data-video-type": type,
    style: _extends({
      objectFit: fit,
      transform: isMirrored ? 'scale(-1, 1)' : ''
    }, style, isPlayable ? playableStyle : {})
  }, props));
});
DailyVideo.displayName = 'DailyVideo';

var DailyDevicesContext = /*#__PURE__*/React.createContext({
  refreshDevices: function refreshDevices() {
    return Promise.resolve();
  }
});

var generalCameraState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'general-camera-state',
  "default": 'idle'
});
var generalMicrophoneState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'general-microphone-state',
  "default": 'idle'
});
var cameraDevicesState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'camera-devices',
  "default": []
});
var microphoneDevicesState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'microphone-devices',
  "default": []
});
var speakerDevicesState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'speaker-devices',
  "default": []
});
var lastCameraErrorState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'last-camera-error',
  "default": null
});
var DailyDevices = function DailyDevices(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  /**
   * Refreshes list of available devices using enumerateDevices.
   * Previous device states are kept in place, otherwise states are initialized as 'granted'.
   */
  var refreshDevices = recoil.useRecoilCallback(function (_ref2) {
    var transact_UNSTABLE = _ref2.transact_UNSTABLE;
    return /*#__PURE__*/_asyncToGenerator(function* () {
      var _navigator, _navigator$mediaDevic, _navigator2, _navigator2$mediaDevi;
      /**
       * Check for legacy browsers.
       */
      if (typeof ((_navigator = navigator) == null ? void 0 : (_navigator$mediaDevic = _navigator.mediaDevices) == null ? void 0 : _navigator$mediaDevic.getUserMedia) === 'undefined' || typeof ((_navigator2 = navigator) == null ? void 0 : (_navigator2$mediaDevi = _navigator2.mediaDevices) == null ? void 0 : _navigator2$mediaDevi.enumerateDevices) === 'undefined') {
        transact_UNSTABLE(function (_ref4) {
          var set = _ref4.set;
          set(generalCameraState, 'not-supported');
          set(generalMicrophoneState, 'not-supported');
        });
        return;
      }
      if (!daily) return;
      try {
        var _yield$daily$enumerat = yield daily.enumerateDevices(),
          devices = _yield$daily$enumerat.devices;
        /**
         * Filter out "empty" devices for when device access has not been granted (yet).
         */
        var cams = devices.filter(function (d) {
          return d.kind === 'videoinput' && d.deviceId !== '';
        });
        var mics = devices.filter(function (d) {
          return d.kind === 'audioinput' && d.deviceId !== '';
        });
        var speakers = devices.filter(function (d) {
          return d.kind === 'audiooutput' && d.deviceId !== '';
        });
        var _yield$daily$getInput = yield daily.getInputDevices(),
          camera = _yield$daily$getInput.camera,
          mic = _yield$daily$getInput.mic,
          speaker = _yield$daily$getInput.speaker;
        var mapDevice = function mapDevice(device, d, prevDevices) {
          var _prevDevices$find$sta, _prevDevices$find;
          return {
            device: d,
            selected: 'deviceId' in device && d.deviceId === device.deviceId,
            state: (_prevDevices$find$sta = (_prevDevices$find = prevDevices.find(function (p) {
              return p.device.deviceId === d.deviceId;
            })) == null ? void 0 : _prevDevices$find.state) != null ? _prevDevices$find$sta : 'granted'
          };
        };
        var sortDeviceByLabel = function sortDeviceByLabel(a, b) {
          if (a.device.deviceId === 'default') return -1;
          if (b.device.deviceId === 'default') return 1;
          if (a.device.label < b.device.label) return -1;
          if (a.device.label > b.device.label) return 1;
          return 0;
        };
        transact_UNSTABLE(function (_ref5) {
          var set = _ref5.set;
          set(cameraDevicesState, function (prevCams) {
            return cams.filter(Boolean).map(function (d) {
              return mapDevice(camera, d, prevCams);
            }).sort(sortDeviceByLabel);
          });
          set(microphoneDevicesState, function (prevMics) {
            return mics.filter(Boolean).map(function (d) {
              return mapDevice(mic, d, prevMics);
            }).sort(sortDeviceByLabel);
          });
          set(speakerDevicesState, function (prevSpeakers) {
            return speakers.filter(Boolean).map(function (d) {
              return mapDevice(speaker, d, prevSpeakers);
            }).sort(sortDeviceByLabel);
          });
        });
      } catch (e) {
        transact_UNSTABLE(function (_ref6) {
          var set = _ref6.set;
          set(generalCameraState, 'not-supported');
          set(generalMicrophoneState, 'not-supported');
        });
      }
    });
  }, [daily]);
  /**
   * Updates general and specific device states, based on blocked status.
   */
  var updateDeviceStates = recoil.useRecoilCallback(function (_ref7) {
    var set = _ref7.set,
      snapshot = _ref7.snapshot,
      transact_UNSTABLE = _ref7.transact_UNSTABLE;
    return /*#__PURE__*/_asyncToGenerator(function* () {
      var _tracks$video$off, _tracks$audio$off, _tracks$audio, _tracks$audio$blocked, _tracks$audio2, _tracks$audio2$blocke, _tracks$audio3, _tracks$audio3$blocke, _tracks$video, _tracks$video$blocked, _tracks$video2, _tracks$video2$blocke, _tracks$video3, _tracks$video3$blocke;
      if (!daily) return;
      var currentCamState = yield snapshot.getPromise(generalCameraState);
      var currentMicState = yield snapshot.getPromise(generalMicrophoneState);
      var participants = daily.participants();
      // Guard against potentially uninitialized local participant
      if (!participants.local) return;
      var tracks = participants.local.tracks;
      var camPermissionState = 'prompt';
      var micPermissionState = 'prompt';
      if (navigator.permissions) {
        try {
          var camPermission = yield navigator.permissions.query({
            // @ts-ignore
            name: 'camera'
          });
          camPermissionState = camPermission.state;
          var micPermission = yield navigator.permissions.query({
            // @ts-ignore
            name: 'microphone'
          });
          micPermissionState = micPermission.state;
        } catch (_unused) {
          // Permissions query not available
        }
      }
      var awaitingCamAccess = camPermissionState === 'prompt' && ['idle', 'pending'].includes(currentCamState) && tracks.video.state === 'interrupted' && !tracks.video.persistentTrack;
      var initialCamOff = ['idle', 'pending'].includes(currentCamState) && !tracks.video.persistentTrack && Boolean((_tracks$video$off = tracks.video.off) == null ? void 0 : _tracks$video$off.byUser);
      var awaitingMicAccess = micPermissionState === 'prompt' && ['idle', 'pending'].includes(currentMicState) && tracks.audio.state === 'interrupted' && !tracks.audio.persistentTrack;
      var initialMicOff = ['idle', 'pending'].includes(currentMicState) && !tracks.audio.persistentTrack && Boolean((_tracks$audio$off = tracks.audio.off) == null ? void 0 : _tracks$audio$off.byUser);
      if ((_tracks$audio = tracks.audio) != null && (_tracks$audio$blocked = _tracks$audio.blocked) != null && _tracks$audio$blocked.byDeviceInUse) {
        transact_UNSTABLE(function (_ref9) {
          var set = _ref9.set;
          set(generalMicrophoneState, 'in-use');
          set(microphoneDevicesState, function (mics) {
            return mics.map(function (m) {
              return m.selected ? _extends({}, m, {
                state: 'in-use'
              }) : m;
            });
          });
        });
      } else if ((_tracks$audio2 = tracks.audio) != null && (_tracks$audio2$blocke = _tracks$audio2.blocked) != null && _tracks$audio2$blocke.byDeviceMissing) {
        set(generalMicrophoneState, 'not-found');
      } else if ((_tracks$audio3 = tracks.audio) != null && (_tracks$audio3$blocke = _tracks$audio3.blocked) != null && _tracks$audio3$blocke.byPermissions || micPermissionState === 'denied') {
        set(generalMicrophoneState, 'blocked');
      } else if (awaitingMicAccess) {
        set(generalMicrophoneState, 'pending');
      } else if (initialMicOff) {
        set(generalMicrophoneState, 'idle');
      } else {
        transact_UNSTABLE(function (_ref10) {
          var set = _ref10.set;
          set(generalMicrophoneState, 'granted');
          set(microphoneDevicesState, function (mics) {
            return mics.map(function (m) {
              return m.selected ? _extends({}, m, {
                state: 'granted'
              }) : m;
            });
          });
        });
      }
      if ((_tracks$video = tracks.video) != null && (_tracks$video$blocked = _tracks$video.blocked) != null && _tracks$video$blocked.byDeviceInUse) {
        transact_UNSTABLE(function (_ref11) {
          var set = _ref11.set;
          set(generalCameraState, 'in-use');
          set(cameraDevicesState, function (cams) {
            return cams.map(function (m) {
              return m.selected ? _extends({}, m, {
                state: 'in-use'
              }) : m;
            });
          });
        });
      } else if ((_tracks$video2 = tracks.video) != null && (_tracks$video2$blocke = _tracks$video2.blocked) != null && _tracks$video2$blocke.byDeviceMissing) {
        set(generalCameraState, 'not-found');
      } else if ((_tracks$video3 = tracks.video) != null && (_tracks$video3$blocke = _tracks$video3.blocked) != null && _tracks$video3$blocke.byPermissions || camPermissionState === 'denied') {
        set(generalCameraState, 'blocked');
      } else if (awaitingCamAccess) {
        set(generalCameraState, 'pending');
      } else if (initialCamOff) {
        set(generalCameraState, 'idle');
      } else {
        transact_UNSTABLE(function (_ref12) {
          var set = _ref12.set;
          set(generalCameraState, 'granted');
          set(cameraDevicesState, function (cams) {
            return cams.map(function (m) {
              return m.selected ? _extends({}, m, {
                state: 'granted'
              }) : m;
            });
          });
        });
      }
      refreshDevices();
    });
  }, [daily, refreshDevices]);
  useDailyEvent('participant-updated', React.useCallback(function (ev) {
    if (!ev.participant.local) return;
    updateDeviceStates();
  }, [updateDeviceStates]));
  useDailyEvent('available-devices-updated', refreshDevices);
  useDailyEvent('selected-devices-updated', refreshDevices);
  useDailyEvent('camera-error', recoil.useRecoilCallback(function (_ref13) {
    var transact_UNSTABLE = _ref13.transact_UNSTABLE;
    return function (ev) {
      transact_UNSTABLE(function (_ref14) {
        var _ev$error, _ev$error2, _ev$error3, _ev$error4, _ev$error5, _ev$error6, _ev$error7;
        var set = _ref14.set;
        set(lastCameraErrorState, ev.error);
        switch ((_ev$error = ev.error) == null ? void 0 : _ev$error.type) {
          case 'cam-in-use':
            set(generalCameraState, 'in-use');
            break;
          case 'mic-in-use':
            set(generalMicrophoneState, 'in-use');
            break;
          case 'cam-mic-in-use':
            set(generalCameraState, 'in-use');
            set(generalMicrophoneState, 'in-use');
            break;
          case 'not-found':
            if ((_ev$error2 = ev.error) != null && _ev$error2.missingMedia.includes('video')) set(generalCameraState, 'not-found');
            if ((_ev$error3 = ev.error) != null && _ev$error3.missingMedia.includes('audio')) set(generalMicrophoneState, 'not-found');
            break;
          case 'permissions':
            if ((_ev$error4 = ev.error) != null && _ev$error4.blockedMedia.includes('video')) set(generalCameraState, 'blocked');
            if ((_ev$error5 = ev.error) != null && _ev$error5.blockedMedia.includes('audio')) set(generalMicrophoneState, 'blocked');
            break;
          case 'constraints':
            if (((_ev$error6 = ev.error) == null ? void 0 : _ev$error6.reason) === 'invalid') {
              set(generalCameraState, 'constraints-invalid');
              set(generalMicrophoneState, 'constraints-invalid');
            } else if (((_ev$error7 = ev.error) == null ? void 0 : _ev$error7.reason) === 'none-specified') {
              set(generalCameraState, 'constraints-none-specified');
              set(generalMicrophoneState, 'constraints-none-specified');
            }
            break;
          case 'undefined-mediadevices':
            set(generalCameraState, 'undefined-mediadevices');
            set(generalMicrophoneState, 'undefined-mediadevices');
            break;
          case 'unknown':
          default:
            set(generalCameraState, 'unknown');
            set(generalMicrophoneState, 'unknown');
            break;
        }
      });
    };
  }, []));
  /**
   * Update all device state, when camera is started.
   */
  useDailyEvent('started-camera', recoil.useRecoilCallback(function (_ref15) {
    var transact_UNSTABLE = _ref15.transact_UNSTABLE;
    return function () {
      transact_UNSTABLE(function (_ref16) {
        var set = _ref16.set;
        set(generalCameraState, 'granted');
        set(generalMicrophoneState, 'granted');
      });
      updateDeviceStates();
    };
  }, [updateDeviceStates]));
  return React__default.createElement(DailyDevicesContext.Provider, {
    value: {
      refreshDevices: refreshDevices
    }
  }, children);
};

var liveStreamingState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'live-streaming',
  "default": {
    errorMsg: undefined,
    isLiveStreaming: false,
    layout: undefined
  }
});
var DailyLiveStreaming = function DailyLiveStreaming(_ref) {
  var children = _ref.children;
  useDailyEvent('live-streaming-started', recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function (ev) {
      set(liveStreamingState, {
        isLiveStreaming: true,
        layout: ev == null ? void 0 : ev.layout
      });
    };
  }, []));
  useDailyEvent('live-streaming-stopped', recoil.useRecoilCallback(function (_ref3) {
    var set = _ref3.set;
    return function () {
      set(liveStreamingState, function (prevState) {
        return _extends({}, prevState, {
          isLiveStreaming: false,
          layout: undefined
        });
      });
    };
  }, []));
  useDailyEvent('live-streaming-error', recoil.useRecoilCallback(function (_ref4) {
    var set = _ref4.set;
    return function (ev) {
      set(liveStreamingState, function (prevState) {
        return _extends({}, prevState, {
          errorMsg: ev.errorMsg
        });
      });
    };
  }, []));
  useDailyEvent('left-meeting', recoil.useRecoilCallback(function (_ref5) {
    var reset = _ref5.reset;
    return function () {
      reset(liveStreamingState);
    };
  }, []));
  return React__default.createElement(React__default.Fragment, null, children);
};

var meetingStateState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'meeting-state',
  "default": 'new'
});
var meetingErrorState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'meeting-error',
  "default": null
});
var nonFatalErrorState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'non-fatal-error',
  "default": null
});
var meetingSessionDataState = /*#__PURE__*/recoil.atom({
  key: 'meeting-session-data',
  "default": {
    data: undefined,
    topology: 'none'
  }
});
var DailyMeeting = function DailyMeeting(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  /**
   * Updates meeting state.
   */
  var updateMeetingState = recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function () {
      if (!daily) return;
      var meetingState = daily.meetingState();
      set(meetingStateState, meetingState);
      return meetingState;
    };
  }, [daily]);
  useDailyEvent('loading', updateMeetingState);
  useDailyEvent('loaded', updateMeetingState);
  useDailyEvent('joining-meeting', updateMeetingState);
  useDailyEvent('joined-meeting', updateMeetingState);
  useDailyEvent('left-meeting', updateMeetingState);
  useDailyEvent('error', recoil.useRecoilCallback(function (_ref3) {
    var set = _ref3.set;
    return function (ev) {
      set(meetingErrorState, ev);
      updateMeetingState();
    };
  }, [updateMeetingState]));
  useDailyEvent('nonfatal-error', recoil.useRecoilCallback(function (_ref4) {
    var set = _ref4.set;
    return function (ev) {
      set(nonFatalErrorState, ev);
    };
  }, []));
  /**
   * Updates meeting session state.
   */
  var initMeetingSessionState = recoil.useRecoilCallback(function (_ref5) {
    var set = _ref5.set;
    return function () {
      if (!daily) return;
      set(meetingSessionDataState, daily.meetingSessionState());
    };
  }, [daily]);
  /**
   * Initialize state when joined meeting or setting up the hook.
   */
  useDailyEvent('joined-meeting', initMeetingSessionState);
  /**
   * Update Recoil state whenever meeting session state is updated.
   */
  useDailyEvent('meeting-session-state-updated', recoil.useRecoilCallback(function (_ref6) {
    var set = _ref6.set;
    return function (ev) {
      set(meetingSessionDataState, ev.meetingSessionState);
    };
  }, []));
  /**
   * Reset Recoil state when meeting ends.
   */
  useDailyEvent('left-meeting', recoil.useRecoilCallback(function (_ref7) {
    var reset = _ref7.reset;
    return function () {
      reset(meetingSessionDataState);
    };
  }, []));
  /**
   * Reset Recoil state when call instance is destroyed.
   */
  useDailyEvent('call-instance-destroyed', recoil.useRecoilCallback(function (_ref8) {
    var transact_UNSTABLE = _ref8.transact_UNSTABLE;
    return function () {
      transact_UNSTABLE(function (_ref9) {
        var reset = _ref9.reset;
        reset(meetingStateState);
        reset(meetingErrorState);
        reset(nonFatalErrorState);
        reset(meetingSessionDataState);
      });
    };
  }, []));
  return React__default.createElement(React__default.Fragment, null, children);
};

var topologyState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'topology',
  "default": 'none'
});
var networkQualityState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'networkQuality',
  "default": 100
});
var networkThresholdState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'networkThreshold',
  "default": 'good'
});
var DailyNetwork = function DailyNetwork(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  var topology = recoil.useRecoilValue(topologyState);
  var initTopology = recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return /*#__PURE__*/_asyncToGenerator(function* () {
      if (!daily) return;
      var topology = yield daily.getNetworkTopology();
      if (!topology || (topology == null ? void 0 : topology.topology) === 'none') return;
      set(topologyState, topology.topology);
    });
  }, [daily]);
  useDailyEvent('joined-meeting', initTopology);
  useDailyEvent('network-connection', recoil.useRecoilCallback(function (_ref4) {
    var set = _ref4.set;
    return function (ev) {
      switch (ev.event) {
        case 'connected':
          if (ev.type === 'peer-to-peer') set(topologyState, 'peer');
          if (ev.type === 'sfu') set(topologyState, 'sfu');
          break;
      }
    };
  }, []));
  useDailyEvent('network-quality-change', recoil.useRecoilCallback(function (_ref5) {
    var transact_UNSTABLE = _ref5.transact_UNSTABLE;
    return function (ev) {
      transact_UNSTABLE(function (_ref6) {
        var set = _ref6.set;
        set(networkQualityState, function (prevQuality) {
          return prevQuality !== ev.quality ? ev.quality : prevQuality;
        });
        set(networkThresholdState, function (prevThreshold) {
          return prevThreshold !== ev.threshold ? ev.threshold : prevThreshold;
        });
      });
    };
  }, []));
  useDailyEvent('left-meeting', recoil.useRecoilCallback(function (_ref7) {
    var transact_UNSTABLE = _ref7.transact_UNSTABLE;
    return function () {
      transact_UNSTABLE(function (_ref8) {
        var reset = _ref8.reset;
        reset(topologyState);
        reset(networkQualityState);
        reset(networkThresholdState);
      });
    };
  }, []));
  React.useEffect(function () {
    if (!daily || topology !== 'none') return;
    initTopology();
  }, [daily, initTopology, topology]);
  return React__default.createElement(React__default.Fragment, null, children);
};

var recordingState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'recording',
  "default": {
    isLocalParticipantRecorded: false,
    isRecording: false
  }
});
var DailyRecordings = function DailyRecordings(_ref) {
  var children = _ref.children;
  var setState = recoil.useSetRecoilState(recordingState);
  var localSessionId = useLocalSessionId();
  var recordingParticipantIds = useParticipantIds({
    filter: 'record'
  });
  /**
   * Update recording state, whenever amount of recording participants changes.
   */
  React.useEffect(function () {
    var hasRecordingParticipants = recordingParticipantIds.length > 0;
    var isLocalParticipantRecording = recordingParticipantIds.includes(localSessionId || 'local');
    setState(function (s) {
      return _extends({}, s, {
        // In case type is local or not set, determine based on recording participants
        isLocalParticipantRecorded: (s == null ? void 0 : s.type) === 'local' || !(s != null && s.type) ? hasRecordingParticipants : s.isLocalParticipantRecorded,
        isRecording: (s == null ? void 0 : s.type) === 'local' || !(s != null && s.type) ? hasRecordingParticipants : s.isRecording,
        local: ((s == null ? void 0 : s.type) === 'local' || !(s != null && s.type)) && hasRecordingParticipants ? isLocalParticipantRecording : s == null ? void 0 : s.local,
        /**
         * Set type in case recording participants are detected.
         * We only set `record` on participants, when recording type is 'local'.
         */
        type: hasRecordingParticipants ? 'local' : s == null ? void 0 : s.type
      });
    });
  }, [localSessionId, recordingParticipantIds, setState]);
  useDailyEvent('recording-started', recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function (ev) {
      var isLocalParticipantRecorded = true;
      switch (ev.type) {
        case 'cloud-beta':
        case 'cloud':
          {
            var _ev$layout;
            if (localSessionId && ((_ev$layout = ev.layout) == null ? void 0 : _ev$layout.preset) === 'single-participant' && ev.layout.session_id !== localSessionId) {
              isLocalParticipantRecorded = false;
            }
            break;
          }
      }
      set(recordingState, {
        error: false,
        isLocalParticipantRecorded: isLocalParticipantRecorded,
        isRecording: true,
        layout: ev == null ? void 0 : ev.layout,
        local: ev == null ? void 0 : ev.local,
        recordingId: ev == null ? void 0 : ev.recordingId,
        recordingStartedDate: new Date(),
        startedBy: ev == null ? void 0 : ev.startedBy,
        type: ev == null ? void 0 : ev.type
      });
    };
  }, [localSessionId]));
  useDailyEvent('recording-stopped', recoil.useRecoilCallback(function (_ref3) {
    var set = _ref3.set;
    return function () {
      set(recordingState, function (prevState) {
        return _extends({}, prevState, {
          isLocalParticipantRecorded: false,
          isRecording: false
        });
      });
    };
  }, []));
  useDailyEvent('recording-error', recoil.useRecoilCallback(function (_ref4) {
    var set = _ref4.set;
    return function () {
      set(recordingState, function (prevState) {
        return _extends({}, prevState, {
          error: true,
          isLocalParticipantRecorded: false,
          isRecording: false
        });
      });
    };
  }, []));
  useDailyEvent('left-meeting', recoil.useRecoilCallback(function (_ref5) {
    var reset = _ref5.reset;
    return function () {
      reset(recordingState);
    };
  }, []));
  return React__default.createElement(React__default.Fragment, null, children);
};

/**
 * Returns a meeting's current state.
 */
var useMeetingState = function useMeetingState() {
  var meetingState = recoil.useRecoilValue(meetingStateState);
  React.useDebugValue(meetingState);
  return meetingState;
};

var roomState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'room',
  "default": null
});
var DailyRoom = function DailyRoom(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateRoom = recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return /*#__PURE__*/_asyncToGenerator(function* () {
      if (!daily || meetingState === 'left-meeting') return;
      var room = yield daily.room();
      if (room && 'id' in room) {
        set(roomState, room);
      }
      return room;
    });
  }, [daily, meetingState]);
  useDailyEvent('access-state-updated', updateRoom);
  useDailyEvent('left-meeting', recoil.useRecoilCallback(function (_ref4) {
    var reset = _ref4.reset;
    return function () {
      reset(roomState);
    };
  }, []));
  return React__default.createElement(React__default.Fragment, null, children);
};

var transcriptionState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'transcription',
  "default": {
    isTranscribing: false,
    model: 'general',
    language: 'en',
    transcriptions: []
  }
});
var DailyTranscriptions = function DailyTranscriptions(_ref) {
  var children = _ref.children;
  useDailyEvent('transcription-started', recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function (ev) {
      set(transcriptionState, _extends({
        error: false,
        isTranscribing: true,
        transcriptionStartDate: new Date(),
        transcriptions: []
      }, ev));
    };
  }, []));
  useDailyEvent('transcription-stopped', recoil.useRecoilCallback(function (_ref3) {
    var set = _ref3.set;
    return function (ev) {
      set(transcriptionState, function (prevState) {
        return _extends({}, prevState, {
          updatedBy: ev == null ? void 0 : ev.updatedBy,
          isTranscribing: false
        });
      });
    };
  }, []));
  useDailyEvent('transcription-error', recoil.useRecoilCallback(function (_ref4) {
    var set = _ref4.set;
    return function () {
      set(transcriptionState, function (prevState) {
        return _extends({}, prevState, {
          error: true,
          isTranscribing: false
        });
      });
    };
  }, []));
  useDailyEvent('left-meeting', recoil.useRecoilCallback(function (_ref5) {
    var set = _ref5.set;
    return function () {
      set(transcriptionState, function (prevState) {
        return _extends({}, prevState, {
          isTranscribing: false
        });
      });
    };
  }, []));
  useDailyEvent('app-message', recoil.useRecoilCallback(function (_ref6) {
    var set = _ref6.set;
    return function (ev) {
      if ((ev == null ? void 0 : ev.fromId) === 'transcription') {
        set(transcriptionState, function (prevState) {
          return _extends({}, prevState, {
            // setting it to true whenever a new message is received
            // as the participants who joined after the transcription-started event
            // won't be knowing if transcription is started or not
            isTranscribing: true,
            transcriptions: [].concat(prevState.transcriptions, [ev.data])
          });
        });
      }
    };
  }, []));
  return React__default.createElement(React__default.Fragment, null, children);
};

var defaultOptions = {};
var defaultShouldCreateInstance = function defaultShouldCreateInstance() {
  return true;
};
var defaultProps = {
  options: defaultOptions,
  shouldCreateInstance: defaultShouldCreateInstance
};
/**
 * Helper hook to maintain custom call instances in React codebases.
 */
var useCallInstance = function useCallInstance(type, _temp) {
  var _ref = _temp === void 0 ? defaultProps : _temp,
    parentElRef = _ref.parentElRef,
    _ref$options = _ref.options,
    options = _ref$options === void 0 ? defaultOptions : _ref$options,
    _ref$shouldCreateInst = _ref.shouldCreateInstance,
    shouldCreateInstance = _ref$shouldCreateInst === void 0 ? defaultShouldCreateInstance : _ref$shouldCreateInst;
  var _useState = React.useState(null),
    callInstance = _useState[0],
    setCallInstance = _useState[1];
  /**
   * Holds last used props when callObject instance was created.
   */
  var lastUsedOptions = React.useRef();
  React.useEffect(function () {
    /**
     * Call frame instances with a defined parentEl likely pass a ref.
     * Typically a DOM ref is initialized with useRef(null).
     * We'll want to wait until parentEl is defined, meaning that the ref is
     * correctly wired up with a DOM element.
     * Otherwise we'll just check shouldCreateInstance().
     */
    if (type === 'callFrame' && (parentElRef == null ? void 0 : parentElRef.current) === null || !shouldCreateInstance()) return;
    function destroyCallInstance(_x) {
      return _destroyCallInstance.apply(this, arguments);
    }
    /**
     * Once instance is destroyed, nullify callInstance, so a new one can be created.
     */
    function _destroyCallInstance() {
      _destroyCallInstance = _asyncToGenerator(function* (co) {
        yield co.destroy();
      });
      return _destroyCallInstance.apply(this, arguments);
    }
    var handleDestroyedInstance = function handleDestroyedInstance() {
      /**
       * Setting a timeout makes sure the destruction and creation
       * of call instances happen in separate call stacks.
       * Otherwise there's a risk for duplicate call instances.
       */
      setTimeout(function () {
        return setCallInstance(null);
      }, 0);
    };
    var co = Daily.getCallInstance();
    /**
     * In case a call instance exists outside of this hook instance's knowledge,
     * store it in state.
     */
    if (!callInstance && co && !co.isDestroyed()) {
      co.once('call-instance-destroyed', handleDestroyedInstance);
      setCallInstance(co);
      return;
    }
    /**
     * callInstance exists.
     */
    if (callInstance) {
      /**
       * Props have changed. Destroy current instance, so a new one can be created.
       */
      if (!customDeepEqual(lastUsedOptions.current, options)) {
        destroyCallInstance(callInstance);
      }
      /**
       * Return early.
       */
      return;
    }
    if (!co || co.isDestroyed()) {
      /**
       * callInstance doesn't exist or is destroyed (TODO: Check why getCallInstance() can return a destroyed instance),
       * but should be created.
       * Important to spread props, because createCallObject/createFrame alters the passed object (adds layout and dailyJsVersion).
       */
      switch (type) {
        case 'callFrame':
          co = parentElRef != null && parentElRef.current ? Daily.createFrame(parentElRef.current, _extends({}, options)) : Daily.createFrame(_extends({}, options));
          break;
        case 'callObject':
          co = Daily.createCallObject(_extends({}, options));
          break;
      }
      lastUsedOptions.current = options;
    }
    setCallInstance(co);
    co.once('call-instance-destroyed', handleDestroyedInstance);
    /**
     * No cleanup phase here, because callObject.destroy() returns a Promise.
     * We can't have asynchronous cleanups in a useEffect.
     * To avoid infinite render loops we compare the props when creating call object instances.
     */
  }, [callInstance, options, parentElRef, shouldCreateInstance, type]);
  return callInstance;
};

/**
 * Helper hook to maintain custom callObject instances in React codebases.
 */
var useCallObject = function useCallObject(props) {
  return useCallInstance('callObject', props);
};

var _excluded$2 = ["children", "recoilRootProps"];
var DailyProvider = function DailyProvider(_ref) {
  var children = _ref.children,
    _ref$recoilRootProps = _ref.recoilRootProps,
    recoilRootProps = _ref$recoilRootProps === void 0 ? {} : _ref$recoilRootProps,
    props = _objectWithoutPropertiesLoose(_ref, _excluded$2);
  var eventsMap = React.useRef({});
  /**
   * Generic event handler to loop through registered event callbacks.
   */
  var handleEvent = React.useCallback(function (ev) {
    var _eventsMap$current$ev, _eventsMap$current;
    if (!('action' in ev)) return;
    var event = ev.action;
    var allHandlers = Array.from((_eventsMap$current$ev = (_eventsMap$current = eventsMap.current) == null ? void 0 : _eventsMap$current[event]) != null ? _eventsMap$current$ev : []);
    var priorityHandlers = allHandlers.filter(function (_ref2) {
      var key = _ref2[0];
      return key < 0;
    });
    var normalHandlers = allHandlers.filter(function (_ref3) {
      var key = _ref3[0];
      return key > 0;
    });
    var sortedHandlers = [].concat(priorityHandlers, normalHandlers);
    for (var _iterator = _createForOfIteratorHelperLoose(sortedHandlers), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
        cb = _step$value[1];
      cb(ev);
    }
  }, []);
  /**
   * In case events are set up via useDailyEvent before a DailyCall instance is available,
   * we'll register the events whenever daily is set.
   */
  var initEventHandlers = React.useCallback(function (daily) {
    if (!daily) return;
    Object.keys(eventsMap.current).forEach(function (event) {
      daily.off(event, handleEvent);
      if (!daily.isDestroyed()) {
        daily.on(event, handleEvent);
      }
    });
  }, [handleEvent]);
  var externalCallObject = 'callObject' in props ? props.callObject : null;
  var memoizedOptions = React.useMemo(function () {
    return 'callObject' in props ? {} : props;
  }, [props]);
  var internalCallObject = useCallObject({
    options: memoizedOptions,
    shouldCreateInstance: React.useCallback(function () {
      return !('callObject' in props);
    }, [props])
  });
  var callObject = externalCallObject != null ? externalCallObject : internalCallObject;
  React.useEffect(function () {
    if (!callObject) return;
    initEventHandlers(callObject);
  }, [callObject, initEventHandlers]);
  /**
   * Registers event callback.
   */
  var on = React.useCallback(function (ev, cb, key) {
    var _eventsMap$current$ev2;
    if (!eventsMap.current[ev]) {
      eventsMap.current[ev] = new Map();
      if (callObject) {
        /**
         * Make sure only 1 event listener is registered at anytime for handleEvent.
         * Otherwise, events sent from daily-js might be handled multiple times.
         */
        callObject.off(ev, handleEvent);
        if (!callObject.isDestroyed()) {
          callObject.on(ev, handleEvent);
        }
      }
    }
    if (!((_eventsMap$current$ev2 = eventsMap.current[ev]) != null && _eventsMap$current$ev2.has(key))) {
      var _eventsMap$current$ev3;
      (_eventsMap$current$ev3 = eventsMap.current[ev]) == null ? void 0 : _eventsMap$current$ev3.set(key, cb);
    }
  }, [callObject, handleEvent]);
  /**
   * Unregisters event callback.
   */
  var off = React.useCallback(function (ev, key) {
    var _eventsMap$current$ev4, _eventsMap$current$ev5;
    (_eventsMap$current$ev4 = eventsMap.current[ev]) == null ? void 0 : _eventsMap$current$ev4["delete"](key);
    if (((_eventsMap$current$ev5 = eventsMap.current[ev]) == null ? void 0 : _eventsMap$current$ev5.size) === 0) {
      callObject == null ? void 0 : callObject.off(ev, handleEvent);
      delete eventsMap.current[ev];
    }
  }, [callObject, handleEvent]);
  return React__default.createElement(recoil.RecoilRoot, Object.assign({}, recoilRootProps), React__default.createElement(DailyContext.Provider, {
    value: callObject
  }, React__default.createElement(DailyEventContext.Provider, {
    value: {
      on: on,
      off: off
    }
  }, React__default.createElement(DailyRoom, null, React__default.createElement(DailyMeeting, null, React__default.createElement(DailyNetwork, null, React__default.createElement(DailyParticipants, null, React__default.createElement(DailyRecordings, null, React__default.createElement(DailyLiveStreaming, null, React__default.createElement(DailyTranscriptions, null, React__default.createElement(DailyDevices, null, children)))))))))));
};

/**
 * Returns the participant identified by the given sessionId.
 * @param sessionId  The participant's session_id or "local".
 * @deprecated Use [useParticipantProperty](https://docs.daily.co/reference/daily-react/use-participant-property) instead to only subscribe to required participant properties.
 */
var useParticipant = function useParticipant(sessionId, _temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onParticipantLeft = _ref.onParticipantLeft,
    onParticipantUpdated = _ref.onParticipantUpdated;
  var participant = recoil.useRecoilValue(participantState(sessionId));
  useThrottledDailyEvent(['participant-updated', 'participant-left'], React.useCallback(function (evts) {
    var filteredEvts = evts.filter(function (ev) {
      return ev.participant.session_id === sessionId;
    });
    if (!filteredEvts.length) return;
    filteredEvts.forEach(function (ev) {
      switch (ev.action) {
        case 'participant-updated':
          onParticipantUpdated == null ? void 0 : onParticipantUpdated(ev);
          break;
        case 'participant-left':
          onParticipantLeft == null ? void 0 : onParticipantLeft(ev);
          break;
      }
    });
  }, [onParticipantLeft, onParticipantUpdated, sessionId]));
  React.useDebugValue(participant);
  return participant;
};

/**
 * Returns the most recent participant mentioned in an [active-speaker-change](https://docs.daily.co/reference/daily-js/events/meeting-events#active-speaker-change) event.
 * @deprecated Use [useActiveSpeakerId](https://docs.daily.co/reference/daily-react/use-active-speaker-id) instead.
 */
var useActiveParticipant = function useActiveParticipant(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    _ref$ignoreLocal = _ref.ignoreLocal,
    ignoreLocal = _ref$ignoreLocal === void 0 ? false : _ref$ignoreLocal,
    onActiveSpeakerChange = _ref.onActiveSpeakerChange;
  var daily = useDaily();
  var recentActiveId = recoil.useRecoilValue(activeIdState);
  var _useState = React.useState(''),
    activeId = _useState[0],
    setActiveId = _useState[1];
  var activeParticipant = useParticipant(activeId);
  React.useEffect(function () {
    var _daily$participants;
    if (!daily) return;
    var local = daily == null ? void 0 : (_daily$participants = daily.participants()) == null ? void 0 : _daily$participants.local;
    if (ignoreLocal && recentActiveId === (local == null ? void 0 : local.session_id)) return;
    // setting activeId as string to avoid passing null to useParticipant hook
    setActiveId(recentActiveId != null ? recentActiveId : '');
  }, [daily, ignoreLocal, recentActiveId]);
  useDailyEvent('active-speaker-change', React.useCallback(function (ev) {
    onActiveSpeakerChange == null ? void 0 : onActiveSpeakerChange(ev);
  }, [onActiveSpeakerChange]));
  React.useDebugValue(activeParticipant);
  return activeParticipant;
};

/**
 * React hook to setup [app-message](https://docs.daily.co/reference/daily-js/events/participant-events#app-message) listeners and
 * to send messages via [sendAppMessage](https://docs.daily.co/reference/daily-js/instance-methods/send-app-message).
 */
var useAppMessage = function useAppMessage(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onAppMessage = _ref.onAppMessage;
  var daily = useDaily();
  var sendAppMessage = React.useCallback(function (data, to) {
    if (to === void 0) {
      to = '*';
    }
    if (!daily) return;
    daily.sendAppMessage(data, to);
  }, [daily]);
  var handleAppMessage = React.useCallback(function (ev) {
    onAppMessage == null ? void 0 : onAppMessage(ev, sendAppMessage);
  }, [onAppMessage, sendAppMessage]);
  useDailyEvent('app-message', handleAppMessage);
  return sendAppMessage;
};

var audioLevelProcessor = "\n    class AudioLevelProcessor extends AudioWorkletProcessor {\n    volume;\n    interval;\n    nextFrame;\n    \n    constructor() {\n      super();\n      this.volume = 0;\n      this.interval = 25;\n      this.nextFrame = this.interval;\n    }\n    \n    get intervalInFrames() {\n      // sampleRate is globally defined in AudioWorklets.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\n      // eslint-disable-next-line no-undef\n      return (this.interval / 1000) * sampleRate;\n    }\n    \n    process(inputList) {\n      const firstInput = inputList[0];\n    \n      if (firstInput.length > 0) {\n        const inputData = firstInput[0];\n        let total = 0;\n    \n        for (let i = 0; i < inputData.length; ++i) {\n          total += Math.abs(inputData[i]);\n        }\n    \n        const rms = Math.sqrt(total / inputData.length);\n        this.volume = Math.max(0, Math.min(1, rms));\n    \n        this.nextFrame -= inputData.length;\n        if (this.nextFrame < 0) {\n          this.nextFrame += this.intervalInFrames;\n          this.port.postMessage({ volume: this.volume });\n        }\n      }\n    \n      return true;\n    }\n    }\n    \n    registerProcessor('audiolevel', AudioLevelProcessor);              \n";
var inlineAudioWorklet = "data:application/javascript;charset=utf8," + /*#__PURE__*/encodeURIComponent(audioLevelProcessor);

/**
 * Returns the volume level of a given MediaStreamTrack.
 * @param mediaTrack The MediaStreamTrack to be analysed.
 * @param onVolumeChange The function to execute when the volume changes. Can be used to visualise audio output.
 * @deprecated Use useAudioLevelObserver() instead.
 */
var useAudioLevel = function useAudioLevel(mediaTrack, onVolumeChange) {
  var audioCtx = React.useRef();
  React.useEffect(function setupStreamAndStartProcessing() {
    // No mediaTrack. Stop immediately.
    if (!mediaTrack) return;
    var AudioCtx = typeof AudioContext !== 'undefined' ? AudioContext : typeof window.webkitAudioContext !== 'undefined' ? window.webkitAudioContext : null;
    // No AudioContext available in browser. Can't measure audio volume.
    if (!AudioCtx) return;
    if (!audioCtx.current) {
      // No audio context initialized. Initializing now.
      audioCtx.current = new AudioCtx();
    }
    var audioContext = audioCtx.current;
    // Audio context could not be initialized. Stopping.
    if (!audioContext) return;
    var mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([mediaTrack]));
    var node;
    var gainNode;
    var startProcessing = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(function* () {
        /**
         * Try to add the module only once.
         * In case it's not added to the audio context, yet, trying to initialize it will fail.
         * There's only one real reason for `new AudioWorkletNode` to fail and that is
         * when the corresponding module isn't added to the audio context, yet.
         * This makes sure we only add the module once.
         *
         * We're inlining the worklet instead of loading it via a URL as not to complicate bundling
         * this package.
         */
        try {
          node = new AudioWorkletNode(audioContext, 'audiolevel');
          gainNode = audioContext.createGain();
        } catch (_unused) {
          try {
            yield audioContext.audioWorklet.addModule(inlineAudioWorklet);
            node = new AudioWorkletNode(audioContext, 'audiolevel');
            gainNode = audioContext.createGain();
          } catch (e) {
            console.error(e);
          }
        }
        if (!(node && gainNode)) return;
        node.port.onmessage = function (event) {
          var volume = 0;
          if (event.data.volume) volume = event.data.volume;
          if (!node) return;
          onVolumeChange(volume);
        };
        gainNode.gain.value = 0;
        try {
          mediaStreamSource.connect(node).connect(gainNode).connect(audioContext.destination);
        } catch (e) {
          console.warn(e);
        }
      });
      return function startProcessing() {
        return _ref.apply(this, arguments);
      };
    }();
    startProcessing();
    return function () {
      var _node;
      (_node = node) == null ? void 0 : _node.disconnect();
      node = null;
      mediaStreamSource == null ? void 0 : mediaStreamSource.disconnect();
    };
  }, [onVolumeChange, mediaTrack]);
};

/**
 * Observes the volume level for a given participant.
 * @param id The session_id of the participant to observe.
 * @param cb The function to execute when the volume changes. Can be used to visualise audio output.
 */
var useAudioLevelObserver = function useAudioLevelObserver(id, cb) {
  var daily = useDaily();
  var localSessionId = useLocalSessionId();
  var isLocal = id === localSessionId;
  useDailyEvent('local-audio-level', React.useCallback(function (ev) {
    if (!isLocal) return;
    cb(ev.audioLevel);
  }, [cb, isLocal]));
  useDailyEvent('remote-participants-audio-level', React.useCallback(function (ev) {
    if (isLocal) return;
    cb(ev.participantsAudioLevel[id]);
  }, [cb, id, isLocal]));
  React.useEffect(function maybeStartLocalAudioObserver() {
    if (!daily || daily.isDestroyed() || !isLocal) return;
    if (daily.isLocalAudioLevelObserverRunning()) return;
    daily.startLocalAudioLevelObserver();
  }, [daily, isLocal]);
  React.useEffect(function maybeStartRemoteAudioObserver() {
    if (!daily || daily.isDestroyed() || isLocal) return;
    if (daily.isRemoteParticipantsAudioLevelObserverRunning()) return;
    daily.startRemoteParticipantsAudioLevelObserver();
  }, [daily, isLocal]);
};

/**
 * Returns a participant's audio track and state.
 * @param participantId The participant's session_id.
 */
var useAudioTrack = function useAudioTrack(participantId) {
  return useMediaTrack(participantId, 'audio');
};

/**
 * Helper hook to maintain custom callFrame instances in React codebases.
 */
var useCallFrame = function useCallFrame(props) {
  return useCallInstance('callFrame', props);
};

var CPULoadState = /*#__PURE__*/recoil.atom({
  key: 'cpu-load-state',
  "default": {
    state: 'low',
    reason: 'none'
  }
});
/**
 * Returns the current CPU load as reported by daily-js [cpu-load-change](https://docs.daily.co/reference/daily-js/events/quality-events#cpu-load-change) events
 * and [getCpuLoadStats](https://docs.daily.co/reference/daily-js/instance-methods/get-cpu-load-stats).
 */
var useCPULoad = function useCPULoad(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onCPULoadChange = _ref.onCPULoadChange;
  var cpu = recoil.useRecoilValue(CPULoadState);
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateCPULoadState = recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set,
      snapshot = _ref2.snapshot;
    return /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(function* (cpu) {
        var prev = yield snapshot.getPromise(CPULoadState);
        if (deepEqual(prev, cpu)) return;
        set(CPULoadState, cpu);
      });
      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }();
  }, []);
  React.useEffect(function () {
    var mounted = true;
    if (!daily || daily.isDestroyed() || meetingState !== 'joined-meeting') return;
    daily.getCpuLoadStats().then(function (stats) {
      if (!mounted) return;
      updateCPULoadState({
        state: stats.cpuLoadState,
        reason: stats.cpuLoadStateReason
      });
    });
    return function () {
      mounted = false;
    };
  }, [daily, meetingState, updateCPULoadState]);
  useDailyEvent('cpu-load-change', React.useCallback(function (ev) {
    updateCPULoadState({
      state: ev.cpuLoadState,
      reason: ev.cpuLoadStateReason
    });
    onCPULoadChange == null ? void 0 : onCPULoadChange(ev);
  }, [onCPULoadChange, updateCPULoadState]));
  React.useDebugValue(cpu);
  return cpu;
};

/**
 * Returns a meeting's last known errors.
 */
var useDailyError = function useDailyError() {
  var meetingError = recoil.useRecoilValue(meetingErrorState);
  var nonFatalError = recoil.useRecoilValue(nonFatalErrorState);
  var result = {
    meetingError: meetingError,
    nonFatalError: nonFatalError
  };
  React.useDebugValue(result);
  return result;
};

/**
 * This hook allows access to information about the user's devices and their state.
 */
var useDevices = function useDevices() {
  var daily = useDaily();
  var camState = recoil.useRecoilValue(generalCameraState);
  var micState = recoil.useRecoilValue(generalMicrophoneState);
  var camDevices = recoil.useRecoilValue(cameraDevicesState);
  var micDevices = recoil.useRecoilValue(microphoneDevicesState);
  var speakerDevices = recoil.useRecoilValue(speakerDevicesState);
  var cameraError = recoil.useRecoilValue(lastCameraErrorState);
  var _useContext = React.useContext(DailyDevicesContext),
    refreshDevices = _useContext.refreshDevices;
  /**
   * Sets video input device to given deviceId.
   */
  var setCamera = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (deviceId) {
      yield daily == null ? void 0 : daily.setInputDevicesAsync({
        audioDeviceId: null,
        videoDeviceId: deviceId
      });
    });
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [daily]);
  /**
   * Sets audio input device to given deviceId.
   */
  var setMicrophone = React.useCallback( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (deviceId) {
      yield daily == null ? void 0 : daily.setInputDevicesAsync({
        audioDeviceId: deviceId,
        videoDeviceId: null
      });
    });
    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }(), [daily]);
  /**
   * Sets audio output device to given deviceId.
   */
  var setSpeaker = React.useCallback( /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(function* (deviceId) {
      yield daily == null ? void 0 : daily.setOutputDeviceAsync({
        outputDeviceId: deviceId
      });
    });
    return function (_x3) {
      return _ref3.apply(this, arguments);
    };
  }(), [daily]);
  var errorStates = ['blocked', 'in-use', 'not-found', 'constraints-invalid', 'constraints-none-specified', 'undefined-mediadevices', 'unknown'];
  var result = {
    /**
     * Most recent error object emitted via [camera-error event](https://docs.daily.co/reference/daily-js/events/meeting-events#camera-error).
     */
    cameraError: cameraError,
    /**
     * A list of the user's camera (videoinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    cameras: camDevices,
    /**
     * The general state for camera access.
     */
    camState: camState,
    /**
     * Holds the currently selected camera.
     */
    currentCam: camDevices.find(function (cam) {
      return cam.selected;
    }),
    /**
     * Holds the currently selected microphone.
     */
    currentMic: micDevices.find(function (mic) {
      return mic.selected;
    }),
    /**
     * Holds the currently selected speaker.
     */
    currentSpeaker: speakerDevices.find(function (speaker) {
      return speaker.selected;
    }),
    /**
     * Indicates that there's an issue with camera devices.
     */
    hasCamError: errorStates.includes(camState),
    /**
     * Indicates that there's an issue with microphone devices.
     */
    hasMicError: errorStates.includes(micState),
    /**
     * A list of the user's microphone (audioinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    microphones: micDevices,
    /**
     * The general state for microphone access.
     */
    micState: micState,
    /**
     * Refreshes the list of devices using [enumerateDevices](https://docs.daily.co/reference/daily-js/instance-methods/enumerate-devices).
     */
    refreshDevices: refreshDevices,
    /**
     * Allows to switch to the camera with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.
     */
    setCamera: setCamera,
    /**
     * Allows to switch to the microphone with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.
     */
    setMicrophone: setMicrophone,
    /**
     * Allows to switch to the speaker with the specified deviceId. Calls [setOutputDevice](https://docs.daily.co/reference/daily-js/instance-methods/set-output-device) internally.
     */
    setSpeaker: setSpeaker,
    /**
     * A list of the user's speaker (audiooutput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    speakers: speakerDevices
  };
  React.useDebugValue(result);
  return result;
};

var inputSettingsState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'input-settings',
  "default": null
});
var useInputSettings = function useInputSettings(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onError = _ref.onError,
    onInputSettingsUpdated = _ref.onInputSettingsUpdated;
  var inputSettings = recoil.useRecoilValue(inputSettingsState);
  var _useDailyError = useDailyError(),
    nonFatalError = _useDailyError.nonFatalError;
  var daily = useDaily();
  var updateInputSettingsState = recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function (inputSettings) {
      set(inputSettingsState, inputSettings);
    };
  }, []);
  React.useEffect(function () {
    if (!daily) return;
    daily.getInputSettings().then(updateInputSettingsState);
  }, [daily, updateInputSettingsState]);
  /**
   * Handle 'input-settings-updated' events.
   */
  useDailyEvent('input-settings-updated', React.useCallback(function (ev) {
    updateInputSettingsState(ev.inputSettings);
    onInputSettingsUpdated == null ? void 0 : onInputSettingsUpdated(ev);
  }, [onInputSettingsUpdated, updateInputSettingsState]));
  /**
   * Handle nonfatal errors of type 'input-settings-error'.
   */
  useDailyEvent('nonfatal-error', React.useCallback(function (ev) {
    if (ev.type !== 'input-settings-error') return;
    onError == null ? void 0 : onError(ev);
  }, [onError]));
  /**
   * Calls daily.updateInputSettings internally.
   */
  var updateInputSettings = React.useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return daily == null ? void 0 : daily.updateInputSettings.apply(daily, args);
  }, [daily]);
  var result = {
    errorMsg: (nonFatalError == null ? void 0 : nonFatalError.type) === 'input-settings-error' ? nonFatalError.errorMsg : null,
    inputSettings: inputSettings,
    updateInputSettings: updateInputSettings
  };
  React.useDebugValue(result);
  return result;
};

/**
 * This hook allows to setup [live streaming events](https://docs.daily.co/reference/daily-js/events/live-streaming-events),
 * as well as starting, stopping and updating live streams.
 *
 * Returns the current live streaming state, incl. the current layout and potential errorMsg.
 */
var useLiveStreaming = function useLiveStreaming(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onLiveStreamingError = _ref.onLiveStreamingError,
    onLiveStreamingStarted = _ref.onLiveStreamingStarted,
    onLiveStreamingStopped = _ref.onLiveStreamingStopped,
    onLiveStreamingUpdated = _ref.onLiveStreamingUpdated,
    onLiveStreamingWarning = _ref.onLiveStreamingWarning;
  var daily = useDaily();
  var state = recoil.useRecoilValue(liveStreamingState);
  useDailyEvent('live-streaming-started', React.useCallback(function (ev) {
    onLiveStreamingStarted == null ? void 0 : onLiveStreamingStarted(ev);
  }, [onLiveStreamingStarted]));
  useDailyEvent('live-streaming-stopped', React.useCallback(function (ev) {
    onLiveStreamingStopped == null ? void 0 : onLiveStreamingStopped(ev);
  }, [onLiveStreamingStopped]));
  useDailyEvent('live-streaming-updated', React.useCallback(function (ev) {
    onLiveStreamingUpdated == null ? void 0 : onLiveStreamingUpdated(ev);
  }, [onLiveStreamingUpdated]));
  useDailyEvent('live-streaming-error', React.useCallback(function (ev) {
    onLiveStreamingError == null ? void 0 : onLiveStreamingError(ev);
  }, [onLiveStreamingError]));
  useDailyEvent('nonfatal-error', React.useCallback(function (ev) {
    if (ev.type !== 'live-streaming-warning') return;
    onLiveStreamingWarning == null ? void 0 : onLiveStreamingWarning(ev);
  }, [onLiveStreamingWarning]));
  var startLiveStreaming = React.useCallback(function () {
    if (!daily) return;
    daily.startLiveStreaming.apply(daily, arguments);
  }, [daily]);
  var stopLiveStreaming = React.useCallback(function () {
    if (!daily) return;
    daily.stopLiveStreaming.apply(daily, arguments);
  }, [daily]);
  var updateLiveStreaming = React.useCallback(function () {
    if (!daily) return;
    daily.updateLiveStreaming.apply(daily, arguments);
  }, [daily]);
  var result = _extends({}, state, {
    startLiveStreaming: startLiveStreaming,
    stopLiveStreaming: stopLiveStreaming,
    updateLiveStreaming: updateLiveStreaming
  });
  React.useDebugValue(result);
  return result;
};

/**
 * Returns the [participants() object](https://docs.daily.co/reference/daily-js/instance-methods/participants) for the local user.
 * @deprecated Use [useLocalSessionId](https://docs.daily.co/reference/daily-react/use-local-session-id) instead.
 */
var useLocalParticipant = function useLocalParticipant() {
  var localId = recoil.useRecoilValue(localIdState);
  var localParticipant = useParticipant(localId);
  React.useDebugValue(localParticipant);
  return localParticipant;
};

/**
 * Returns a meeting's current session data and topology.
 */
var useMeetingSessionState = function useMeetingSessionState(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onError = _ref.onError;
  var meetingSessionState = recoil.useRecoilValue(meetingSessionDataState);
  useDailyEvent('nonfatal-error', React.useCallback(function (ev) {
    if (ev.type !== 'meeting-session-data-error') return;
    onError == null ? void 0 : onError(ev);
  }, [onError]));
  var result = {
    data: meetingSessionState == null ? void 0 : meetingSessionState.data,
    topology: meetingSessionState == null ? void 0 : meetingSessionState.topology
  };
  React.useDebugValue(result);
  return result;
};

/**
 * Returns current information about network quality and topology.
 * Allows to setup event listeners for daily's [network events](https://docs.daily.co/reference/daily-js/events/network-events).
 */
var useNetwork = function useNetwork(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onNetworkConnection = _ref.onNetworkConnection,
    onNetworkQualityChange = _ref.onNetworkQualityChange;
  var daily = useDaily();
  var topology = recoil.useRecoilValue(topologyState);
  var quality = recoil.useRecoilValue(networkQualityState);
  var threshold = recoil.useRecoilValue(networkThresholdState);
  useDailyEvent('network-connection', React.useCallback(function (ev) {
    onNetworkConnection == null ? void 0 : onNetworkConnection(ev);
  }, [onNetworkConnection]));
  useDailyEvent('network-quality-change', React.useCallback(function (ev) {
    onNetworkQualityChange == null ? void 0 : onNetworkQualityChange(ev);
  }, [onNetworkQualityChange]));
  var getStats = React.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    var newStats = yield daily == null ? void 0 : daily.getNetworkStats();
    return newStats == null ? void 0 : newStats.stats;
  }), [daily]);
  var result = {
    getStats: getStats,
    quality: quality,
    threshold: threshold,
    topology: topology
  };
  React.useDebugValue(result);
  return result;
};

var participantCountsState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'participant-counts',
  "default": {
    hidden: 0,
    present: 0
  }
});
/**
 * Returns participant counts for hidden and present participants.
 */
var useParticipantCounts = function useParticipantCounts(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onParticipantCountsUpdated = _ref.onParticipantCountsUpdated;
  var daily = useDaily();
  var participantCounts = recoil.useRecoilValue(participantCountsState);
  var updateCounts = recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function (counts) {
      set(participantCountsState, counts);
    };
  }, []);
  useDailyEvent('participant-counts-updated', React.useCallback(function (ev) {
    updateCounts(ev.participantCounts);
    onParticipantCountsUpdated == null ? void 0 : onParticipantCountsUpdated(ev);
  }, [onParticipantCountsUpdated, updateCounts]));
  React.useEffect(function () {
    if (!daily || daily.isDestroyed()) return;
    updateCounts(daily.participantCounts());
  }, [daily, updateCounts]);
  React.useDebugValue(participantCounts);
  return participantCounts;
};

/**
 * Returns parsed permissions for a given participant.
 * In case no `sessionId` is passed, the hook returns permissions for the local participant.
 * @param sessionId The participant's session_id (optional)
 */
var usePermissions = function usePermissions(sessionId) {
  var _permissions$canSend, _permissions$canSend2, _permissions$canSend3, _permissions$canSend4, _permissions$canSend5, _permissions$canSend6, _permissions$canAdmin, _permissions$canAdmin2, _permissions$canAdmin3;
  var localSessionId = useLocalSessionId();
  var permissions = useParticipantProperty(sessionId != null ? sessionId : localSessionId, 'permissions');
  var canSendAudio = typeof (permissions == null ? void 0 : permissions.canSend) === 'boolean' ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend = permissions.canSend) == null ? void 0 : _permissions$canSend.has('audio'));
  var canSendVideo = typeof (permissions == null ? void 0 : permissions.canSend) === 'boolean' ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend2 = permissions.canSend) == null ? void 0 : _permissions$canSend2.has('video'));
  var canSendCustomAudio = typeof (permissions == null ? void 0 : permissions.canSend) === 'boolean' ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend3 = permissions.canSend) == null ? void 0 : _permissions$canSend3.has('customAudio'));
  var canSendCustomVideo = typeof (permissions == null ? void 0 : permissions.canSend) === 'boolean' ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend4 = permissions.canSend) == null ? void 0 : _permissions$canSend4.has('customVideo'));
  var canSendScreenAudio = typeof (permissions == null ? void 0 : permissions.canSend) === 'boolean' ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend5 = permissions.canSend) == null ? void 0 : _permissions$canSend5.has('screenAudio'));
  var canSendScreenVideo = typeof (permissions == null ? void 0 : permissions.canSend) === 'boolean' ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend6 = permissions.canSend) == null ? void 0 : _permissions$canSend6.has('screenVideo'));
  var canAdminParticipants = typeof (permissions == null ? void 0 : permissions.canAdmin) === 'boolean' ? permissions == null ? void 0 : permissions.canAdmin : Boolean(permissions == null ? void 0 : (_permissions$canAdmin = permissions.canAdmin) == null ? void 0 : _permissions$canAdmin.has('participants'));
  var canAdminStreaming = typeof (permissions == null ? void 0 : permissions.canAdmin) === 'boolean' ? permissions == null ? void 0 : permissions.canAdmin : Boolean(permissions == null ? void 0 : (_permissions$canAdmin2 = permissions.canAdmin) == null ? void 0 : _permissions$canAdmin2.has('streaming'));
  var canAdminTranscription = typeof (permissions == null ? void 0 : permissions.canAdmin) === 'boolean' ? permissions == null ? void 0 : permissions.canAdmin : Boolean(permissions == null ? void 0 : (_permissions$canAdmin3 = permissions.canAdmin) == null ? void 0 : _permissions$canAdmin3.has('transcription'));
  var result = {
    canAdminParticipants: canAdminParticipants,
    canAdminStreaming: canAdminStreaming,
    canAdminTranscription: canAdminTranscription,
    canSendAudio: canSendAudio,
    canSendCustomAudio: canSendCustomAudio,
    canSendCustomVideo: canSendCustomVideo,
    canSendScreenAudio: canSendScreenAudio,
    canSendScreenVideo: canSendScreenVideo,
    canSendVideo: canSendVideo,
    hasPresence: permissions == null ? void 0 : permissions.hasPresence,
    permissions: permissions
  };
  React.useDebugValue(result);
  return result;
};

var participantReceiveSettingsState = /*#__PURE__*/recoil.atomFamily({
  key: RECOIL_PREFIX + 'participant-receive-settings',
  "default": {}
});
/**
 * Allows to read and set receiveSettings.
 * In case receiveSettings for participant specified by id are empty, not set or 'inherit',
 * base receiveSettings will be returned.
 * In case meeting is not in joined state, calls to updateReceiveSettings will be silently ignored.
 */
var useReceiveSettings = function useReceiveSettings(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    _ref$id = _ref.id,
    id = _ref$id === void 0 ? 'base' : _ref$id,
    onReceiveSettingsUpdated = _ref.onReceiveSettingsUpdated;
  var baseSettings = recoil.useRecoilValue(participantReceiveSettingsState('base'));
  var receiveSettings = recoil.useRecoilValue(participantReceiveSettingsState(id));
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateReceiveSettingsState = recoil.useRecoilCallback(function (_ref2) {
    var transact_UNSTABLE = _ref2.transact_UNSTABLE;
    return function (receiveSettings) {
      transact_UNSTABLE(function (_ref3) {
        var reset = _ref3.reset,
          set = _ref3.set;
        var ids = _extends({}, receiveSettings);
        for (var _i = 0, _Object$entries = Object.entries(ids); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _Object$entries[_i],
            _id = _Object$entries$_i[0],
            settings = _Object$entries$_i[1];
          set(participantReceiveSettingsState(_id), settings);
        }
        if (!(id in ids)) {
          reset(participantReceiveSettingsState(id));
        }
      });
    };
  }, [id]);
  useDailyEvent('receive-settings-updated', React.useCallback(function (ev) {
    updateReceiveSettingsState(ev.receiveSettings);
    onReceiveSettingsUpdated == null ? void 0 : onReceiveSettingsUpdated(ev);
  }, [onReceiveSettingsUpdated, updateReceiveSettingsState]));
  React.useEffect(function () {
    if (!daily || daily.isDestroyed()) return;
    daily.getReceiveSettings().then(updateReceiveSettingsState);
  }, [daily, updateReceiveSettingsState]);
  var updateReceiveSettings = React.useCallback(function () {
    if (!daily || meetingState !== 'joined-meeting') return;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    daily == null ? void 0 : daily.updateReceiveSettings == null ? void 0 : daily.updateReceiveSettings.apply(daily, args);
  }, [daily, meetingState]);
  var result = {
    receiveSettings: id === 'base' || Object.keys(receiveSettings).length === 0 ? baseSettings : receiveSettings,
    updateReceiveSettings: updateReceiveSettings
  };
  React.useDebugValue(result);
  return result;
};

var useRecording = function useRecording(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onRecordingData = _ref.onRecordingData,
    onRecordingError = _ref.onRecordingError,
    onRecordingStarted = _ref.onRecordingStarted,
    onRecordingStopped = _ref.onRecordingStopped;
  var daily = useDaily();
  var state = recoil.useRecoilValue(recordingState);
  useDailyEvent('recording-started', React.useCallback(function (ev) {
    onRecordingStarted == null ? void 0 : onRecordingStarted(ev);
  }, [onRecordingStarted]));
  useDailyEvent('recording-stopped', React.useCallback(function (ev) {
    onRecordingStopped == null ? void 0 : onRecordingStopped(ev);
  }, [onRecordingStopped]));
  useDailyEvent('recording-error', React.useCallback(function (ev) {
    onRecordingError == null ? void 0 : onRecordingError(ev);
  }, [onRecordingError]));
  useDailyEvent('recording-data', React.useCallback(function (ev) {
    onRecordingData == null ? void 0 : onRecordingData(ev);
  }, [onRecordingData]));
  /**
   * Starts the recording with the given optional options.
   */
  var startRecording = React.useCallback(function () {
    if (!daily) return;
    daily.startRecording.apply(daily, arguments);
  }, [daily]);
  /**
   * Stops a recording.
   */
  var stopRecording = React.useCallback(function () {
    if (!daily) return;
    daily.stopRecording.apply(daily, arguments);
  }, [daily]);
  /**
   * Updates a running recording's layout configuration.
   */
  var updateRecording = React.useCallback(function () {
    if (!daily) return;
    daily.updateRecording.apply(daily, arguments);
  }, [daily]);
  var result = _extends({}, state, {
    startRecording: startRecording,
    stopRecording: stopRecording,
    updateRecording: updateRecording
  });
  React.useDebugValue(result);
  return result;
};

/**
 * Stateful hook to work with room, domain and token configuration for a daily room.
 * Includes room default values.
 */
var useRoom = function useRoom() {
  var room = recoil.useRecoilValue(roomState);
  React.useDebugValue(room);
  return room;
};

var useRoomExp = function useRoomExp(_temp) {
  var _room$config4, _room$config5, _room$config6, _room$tokenConfig4, _room$tokenConfig5, _room$tokenConfig6;
  var _ref = _temp === void 0 ? {} : _temp,
    onCountdown = _ref.onCountdown;
  var localJoinDate = recoil.useRecoilValue(localJoinDateState);
  var room = useRoom();
  var _useState = React.useState(null),
    ejectDate = _useState[0],
    setEjectDate = _useState[1];
  React.useEffect(function () {
    var _ref2, _room$tokenConfig$eje, _room$tokenConfig, _room$config, _ref3, _room$tokenConfig$exp, _room$tokenConfig2, _room$config2, _ref4, _room$tokenConfig$eje2, _room$tokenConfig3, _room$config3;
    var ejectAfterElapsed = (_ref2 = (_room$tokenConfig$eje = room == null ? void 0 : (_room$tokenConfig = room.tokenConfig) == null ? void 0 : _room$tokenConfig.eject_after_elapsed) != null ? _room$tokenConfig$eje : room == null ? void 0 : (_room$config = room.config) == null ? void 0 : _room$config.eject_after_elapsed) != null ? _ref2 : 0;
    var expUTCTimeStamp = (_ref3 = (_room$tokenConfig$exp = room == null ? void 0 : (_room$tokenConfig2 = room.tokenConfig) == null ? void 0 : _room$tokenConfig2.exp) != null ? _room$tokenConfig$exp : room == null ? void 0 : (_room$config2 = room.config) == null ? void 0 : _room$config2.exp) != null ? _ref3 : 0;
    var ejectAtExp = (_ref4 = (_room$tokenConfig$eje2 = room == null ? void 0 : (_room$tokenConfig3 = room.tokenConfig) == null ? void 0 : _room$tokenConfig3.eject_at_token_exp) != null ? _room$tokenConfig$eje2 : room == null ? void 0 : (_room$config3 = room.config) == null ? void 0 : _room$config3.eject_at_room_exp) != null ? _ref4 : false;
    var newEjectDate = new Date(0);
    if (ejectAfterElapsed && localJoinDate) {
      newEjectDate = new Date(localJoinDate.getTime() + 1000 * ejectAfterElapsed);
    }
    if (ejectAtExp && expUTCTimeStamp) {
      var expDate = new Date(expUTCTimeStamp * 1000);
      if (!newEjectDate.getTime() || newEjectDate.getTime() > 0 && expDate < newEjectDate) newEjectDate = expDate;
    }
    if (newEjectDate.getTime() === 0) return;
    setEjectDate(function (oldEjectDate) {
      return (oldEjectDate == null ? void 0 : oldEjectDate.getTime()) !== newEjectDate.getTime() ? newEjectDate : oldEjectDate;
    });
  }, [localJoinDate, room == null ? void 0 : (_room$config4 = room.config) == null ? void 0 : _room$config4.eject_after_elapsed, room == null ? void 0 : (_room$config5 = room.config) == null ? void 0 : _room$config5.eject_at_room_exp, room == null ? void 0 : (_room$config6 = room.config) == null ? void 0 : _room$config6.exp, room == null ? void 0 : (_room$tokenConfig4 = room.tokenConfig) == null ? void 0 : _room$tokenConfig4.eject_after_elapsed, room == null ? void 0 : (_room$tokenConfig5 = room.tokenConfig) == null ? void 0 : _room$tokenConfig5.eject_at_token_exp, room == null ? void 0 : (_room$tokenConfig6 = room.tokenConfig) == null ? void 0 : _room$tokenConfig6.exp]);
  React.useEffect(function () {
    if (!ejectDate || ejectDate.getTime() === 0) return;
    var interval = setInterval(function () {
      var _ejectDate$getTime;
      var eject = ((_ejectDate$getTime = ejectDate == null ? void 0 : ejectDate.getTime()) != null ? _ejectDate$getTime : 0) / 1000;
      var now = Date.now() / 1000;
      var diff = eject - now;
      if (diff < 0) return;
      var hours = Math.max(0, Math.floor(diff / 3600));
      var minutes = Math.max(0, Math.floor(diff % 3600 / 60));
      var seconds = Math.max(0, Math.floor(diff % 60));
      onCountdown == null ? void 0 : onCountdown({
        hours: hours,
        minutes: minutes,
        seconds: seconds
      });
    }, 1000);
    return function () {
      clearInterval(interval);
    };
  }, [ejectDate, onCountdown]);
  var result = {
    ejectDate: ejectDate
  };
  React.useDebugValue(result);
  return result;
};

/**
 * Returns a participant's screenAudio track and state.
 * @param participantId The participant's session_id.
 */
var useScreenAudioTrack = function useScreenAudioTrack(participantId) {
  return useMediaTrack(participantId, 'screenAudio');
};

/**
 * Returns a participant's screenVideo track and state.
 * @param participantId The participant's session_id.
 */
var useScreenVideoTrack = function useScreenVideoTrack(participantId) {
  return useMediaTrack(participantId, 'screenVideo');
};

var sendSettingsState = /*#__PURE__*/recoil.atom({
  key: RECOIL_PREFIX + 'send-settings',
  "default": null
});
/**
 * Returns the current media send settings and an updater function to change the settings.
 */
var useSendSettings = function useSendSettings(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onSendSettingsUpdated = _ref.onSendSettingsUpdated;
  var daily = useDaily();
  var sendSettings = recoil.useRecoilValue(sendSettingsState);
  useDailyEvent('send-settings-updated', recoil.useRecoilCallback(function (_ref2) {
    var set = _ref2.set;
    return function (ev) {
      set(sendSettingsState, ev.sendSettings);
      onSendSettingsUpdated == null ? void 0 : onSendSettingsUpdated(ev);
    };
  }, [onSendSettingsUpdated]));
  var storeSendSettings = recoil.useRecoilCallback(function (_ref3) {
    var set = _ref3.set;
    return function (sendSettings) {
      set(sendSettingsState, sendSettings);
    };
  }, []);
  React.useEffect(function () {
    if (!daily || daily.isDestroyed()) return;
    storeSendSettings(daily.getSendSettings());
  }, [daily, storeSendSettings]);
  /**
   * Updates the local clients send settings.
   * See https://docs.daily.co/reference/daily-js/instance-methods/update-send-settings for details.
   */
  var updateSendSettings = React.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var newSendSettings = yield daily == null ? void 0 : daily.updateSendSettings.apply(daily, args);
    if (!newSendSettings) return;
    storeSendSettings(newSendSettings);
    return newSendSettings;
  }), [daily, storeSendSettings]);
  var result = {
    sendSettings: sendSettings,
    updateSendSettings: updateSendSettings
  };
  React.useDebugValue(result);
  return result;
};

var useTranscription = function useTranscription(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onTranscriptionAppData = _ref.onTranscriptionAppData,
    onTranscriptionError = _ref.onTranscriptionError,
    onTranscriptionMessage = _ref.onTranscriptionMessage,
    onTranscriptionStarted = _ref.onTranscriptionStarted,
    onTranscriptionStopped = _ref.onTranscriptionStopped;
  var daily = useDaily();
  var state = recoil.useRecoilValue(transcriptionState);
  useDailyEvent('transcription-started', React.useCallback(function (ev) {
    onTranscriptionStarted == null ? void 0 : onTranscriptionStarted(ev);
  }, [onTranscriptionStarted]));
  useDailyEvent('transcription-stopped', React.useCallback(function (ev) {
    onTranscriptionStopped == null ? void 0 : onTranscriptionStopped(ev);
  }, [onTranscriptionStopped]));
  useDailyEvent('transcription-error', React.useCallback(function (ev) {
    onTranscriptionError == null ? void 0 : onTranscriptionError(ev);
  }, [onTranscriptionError]));
  useDailyEvent('transcription-message', React.useCallback(function (ev) {
    onTranscriptionMessage == null ? void 0 : onTranscriptionMessage(ev);
  }, [onTranscriptionMessage]));
  useDailyEvent('app-message', React.useCallback(function (ev) {
    if ((ev == null ? void 0 : ev.fromId) === 'transcription') {
      onTranscriptionAppData == null ? void 0 : onTranscriptionAppData(ev);
    }
  }, [onTranscriptionAppData]));
  /**
   * Starts the transcription with the given optional options.
   */
  var startTranscription = React.useCallback(function () {
    if (!daily) return;
    daily.startTranscription.apply(daily, arguments);
  }, [daily]);
  /**
   * Stops a transcription.
   */
  var stopTranscription = React.useCallback(function () {
    if (!daily) return;
    daily.stopTranscription.apply(daily, arguments);
  }, [daily]);
  var result = _extends({}, state, {
    startTranscription: startTranscription,
    stopTranscription: stopTranscription
  });
  React.useDebugValue(result);
  return result;
};

/**
 * Returns a participant's video track and state.
 * @param participantId The participant's session_id.
 */
var useVideoTrack = function useVideoTrack(participantId) {
  return useMediaTrack(participantId, 'video');
};

/**
 * Hook to access and manage waiting participants.
 */
var useWaitingParticipants = function useWaitingParticipants(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
    onWaitingParticipantAdded = _ref.onWaitingParticipantAdded,
    onWaitingParticipantRemoved = _ref.onWaitingParticipantRemoved,
    onWaitingParticipantUpdated = _ref.onWaitingParticipantUpdated;
  var daily = useDaily();
  var waitingParticipants = recoil.useRecoilValue(allWaitingParticipantsSelector);
  useDailyEvent('waiting-participant-added', React.useCallback(function (ev) {
    onWaitingParticipantAdded == null ? void 0 : onWaitingParticipantAdded(ev);
  }, [onWaitingParticipantAdded]));
  useDailyEvent('waiting-participant-removed', React.useCallback(function (ev) {
    onWaitingParticipantRemoved == null ? void 0 : onWaitingParticipantRemoved(ev);
  }, [onWaitingParticipantRemoved]));
  useDailyEvent('waiting-participant-updated', React.useCallback(function (ev) {
    onWaitingParticipantUpdated == null ? void 0 : onWaitingParticipantUpdated(ev);
  }, [onWaitingParticipantUpdated]));
  var updateWaitingParticipantAccess = React.useCallback(function (id, grantRequestedAccess) {
    if (id === '*') {
      daily == null ? void 0 : daily.updateWaitingParticipants({
        '*': {
          grantRequestedAccess: grantRequestedAccess
        }
      });
      return;
    }
    daily == null ? void 0 : daily.updateWaitingParticipant(id, {
      grantRequestedAccess: grantRequestedAccess
    });
  }, [daily]);
  var grantAccess = React.useCallback(function (id) {
    updateWaitingParticipantAccess(id, true);
  }, [updateWaitingParticipantAccess]);
  var denyAccess = React.useCallback(function (id) {
    updateWaitingParticipantAccess(id, false);
  }, [updateWaitingParticipantAccess]);
  var result = {
    waitingParticipants: waitingParticipants,
    grantAccess: grantAccess,
    denyAccess: denyAccess
  };
  React.useDebugValue(result);
  return result;
};

exports.DailyAudio = DailyAudio;
exports.DailyAudioTrack = DailyAudioTrack;
exports.DailyProvider = DailyProvider;
exports.DailyVideo = DailyVideo;
exports.useActiveParticipant = useActiveParticipant;
exports.useActiveSpeakerId = useActiveSpeakerId;
exports.useAppMessage = useAppMessage;
exports.useAudioLevel = useAudioLevel;
exports.useAudioLevelObserver = useAudioLevelObserver;
exports.useAudioTrack = useAudioTrack;
exports.useCPULoad = useCPULoad;
exports.useCallFrame = useCallFrame;
exports.useCallObject = useCallObject;
exports.useDaily = useDaily;
exports.useDailyError = useDailyError;
exports.useDailyEvent = useDailyEvent;
exports.useDevices = useDevices;
exports.useInputSettings = useInputSettings;
exports.useLiveStreaming = useLiveStreaming;
exports.useLocalParticipant = useLocalParticipant;
exports.useLocalSessionId = useLocalSessionId;
exports.useMediaTrack = useMediaTrack;
exports.useMeetingSessionState = useMeetingSessionState;
exports.useMeetingState = useMeetingState;
exports.useNetwork = useNetwork;
exports.useParticipant = useParticipant;
exports.useParticipantCounts = useParticipantCounts;
exports.useParticipantIds = useParticipantIds;
exports.useParticipantProperty = useParticipantProperty;
exports.usePermissions = usePermissions;
exports.useReceiveSettings = useReceiveSettings;
exports.useRecording = useRecording;
exports.useRoom = useRoom;
exports.useRoomExp = useRoomExp;
exports.useScreenAudioTrack = useScreenAudioTrack;
exports.useScreenShare = useScreenShare;
exports.useScreenVideoTrack = useScreenVideoTrack;
exports.useSendSettings = useSendSettings;
exports.useThrottledDailyEvent = useThrottledDailyEvent;
exports.useTranscription = useTranscription;
exports.useVideoTrack = useVideoTrack;
exports.useWaitingParticipants = useWaitingParticipants;
//# sourceMappingURL=daily-react.cjs.development.js.map
