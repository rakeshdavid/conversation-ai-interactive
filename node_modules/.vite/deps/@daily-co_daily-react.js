import {
  require_react_dom
} from "./chunk-6BKLQ22S.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = throttle2;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module2) {
    "use strict";
    module2.exports = function equal(a2, b2) {
      if (a2 === b2) return true;
      if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
        if (a2.constructor !== b2.constructor) return false;
        var length, i2, keys;
        if (Array.isArray(a2)) {
          length = a2.length;
          if (length != b2.length) return false;
          for (i2 = length; i2-- !== 0; )
            if (!equal(a2[i2], b2[i2])) return false;
          return true;
        }
        if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
        if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
        if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
        keys = Object.keys(a2);
        length = keys.length;
        if (length !== Object.keys(b2).length) return false;
        for (i2 = length; i2-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
        for (i2 = length; i2-- !== 0; ) {
          var key = keys[i2];
          if (!equal(a2[key], b2[key])) return false;
        }
        return true;
      }
      return a2 !== a2 && b2 !== b2;
    };
  }
});

// node_modules/@daily-co/daily-react/dist/daily-react.esm.js
var import_react2 = __toESM(require_react());

// node_modules/recoil/es/index.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function err(message) {
  const error = new Error(message);
  if (error.stack === void 0) {
    try {
      throw error;
    } catch (_2) {
    }
  }
  return error;
}
var err_1 = err;
var Recoil_err = err_1;
function isPromise(p2) {
  return !!p2 && typeof p2.then === "function";
}
var Recoil_isPromise = isPromise;
function nullthrows(x2, message) {
  if (x2 != null) {
    return x2;
  }
  throw Recoil_err(message !== null && message !== void 0 ? message : "Got unexpected null or undefined");
}
var Recoil_nullthrows = nullthrows;
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var BaseLoadable = class {
  getValue() {
    throw Recoil_err("BaseLoadable");
  }
  toPromise() {
    throw Recoil_err("BaseLoadable");
  }
  valueMaybe() {
    throw Recoil_err("BaseLoadable");
  }
  valueOrThrow() {
    throw Recoil_err(`Loadable expected value, but in "${this.state}" state`);
  }
  promiseMaybe() {
    throw Recoil_err("BaseLoadable");
  }
  promiseOrThrow() {
    throw Recoil_err(`Loadable expected promise, but in "${this.state}" state`);
  }
  errorMaybe() {
    throw Recoil_err("BaseLoadable");
  }
  errorOrThrow() {
    throw Recoil_err(`Loadable expected error, but in "${this.state}" state`);
  }
  is(other) {
    return other.state === this.state && other.contents === this.contents;
  }
  map(_map) {
    throw Recoil_err("BaseLoadable");
  }
};
var ValueLoadable = class extends BaseLoadable {
  constructor(value) {
    super();
    _defineProperty(this, "state", "hasValue");
    _defineProperty(this, "contents", void 0);
    this.contents = value;
  }
  getValue() {
    return this.contents;
  }
  toPromise() {
    return Promise.resolve(this.contents);
  }
  valueMaybe() {
    return this.contents;
  }
  valueOrThrow() {
    return this.contents;
  }
  promiseMaybe() {
    return void 0;
  }
  errorMaybe() {
    return void 0;
  }
  map(map) {
    try {
      const next = map(this.contents);
      return Recoil_isPromise(next) ? loadableWithPromise(next) : isLoadable(next) ? next : loadableWithValue(next);
    } catch (e2) {
      return Recoil_isPromise(e2) ? (
        // If we "suspended", then try again.
        // errors and subsequent retries will be handled in 'loading' case
        // $FlowFixMe[prop-missing]
        loadableWithPromise(e2.next(() => this.map(map)))
      ) : loadableWithError(e2);
    }
  }
};
var ErrorLoadable = class extends BaseLoadable {
  constructor(error) {
    super();
    _defineProperty(this, "state", "hasError");
    _defineProperty(this, "contents", void 0);
    this.contents = error;
  }
  getValue() {
    throw this.contents;
  }
  toPromise() {
    return Promise.reject(this.contents);
  }
  valueMaybe() {
    return void 0;
  }
  promiseMaybe() {
    return void 0;
  }
  errorMaybe() {
    return this.contents;
  }
  errorOrThrow() {
    return this.contents;
  }
  map(_map) {
    return this;
  }
};
var LoadingLoadable = class extends BaseLoadable {
  constructor(promise) {
    super();
    _defineProperty(this, "state", "loading");
    _defineProperty(this, "contents", void 0);
    this.contents = promise;
  }
  getValue() {
    throw this.contents;
  }
  toPromise() {
    return this.contents;
  }
  valueMaybe() {
    return void 0;
  }
  promiseMaybe() {
    return this.contents;
  }
  promiseOrThrow() {
    return this.contents;
  }
  errorMaybe() {
    return void 0;
  }
  map(map) {
    return loadableWithPromise(this.contents.then((value) => {
      const next = map(value);
      if (isLoadable(next)) {
        const nextLoadable = next;
        switch (nextLoadable.state) {
          case "hasValue":
            return nextLoadable.contents;
          case "hasError":
            throw nextLoadable.contents;
          case "loading":
            return nextLoadable.contents;
        }
      }
      return next;
    }).catch((e2) => {
      if (Recoil_isPromise(e2)) {
        return e2.then(() => this.map(map).contents);
      }
      throw e2;
    }));
  }
};
function loadableWithValue(value) {
  return Object.freeze(new ValueLoadable(value));
}
function loadableWithError(error) {
  return Object.freeze(new ErrorLoadable(error));
}
function loadableWithPromise(promise) {
  return Object.freeze(new LoadingLoadable(promise));
}
function loadableLoading() {
  return Object.freeze(new LoadingLoadable(new Promise(() => {
  })));
}
function loadableAllArray(inputs) {
  return inputs.every((i2) => i2.state === "hasValue") ? loadableWithValue(inputs.map((i2) => i2.contents)) : inputs.some((i2) => i2.state === "hasError") ? loadableWithError(Recoil_nullthrows(inputs.find((i2) => i2.state === "hasError"), "Invalid loadable passed to loadableAll").contents) : loadableWithPromise(Promise.all(inputs.map((i2) => i2.contents)));
}
function loadableAll(inputs) {
  const unwrapedInputs = Array.isArray(inputs) ? inputs : Object.getOwnPropertyNames(inputs).map((key) => inputs[key]);
  const normalizedInputs = unwrapedInputs.map((x2) => isLoadable(x2) ? x2 : Recoil_isPromise(x2) ? loadableWithPromise(x2) : loadableWithValue(x2));
  const output = loadableAllArray(normalizedInputs);
  return Array.isArray(inputs) ? (
    // $FlowIssue[incompatible-return]
    output
  ) : (
    // Object.getOwnPropertyNames() has consistent key ordering with ES6
    // $FlowIssue[incompatible-call]
    output.map((outputs) => Object.getOwnPropertyNames(inputs).reduce(
      // $FlowFixMe[invalid-computed-prop]
      (out, key, idx) => ({
        ...out,
        [key]: outputs[idx]
      }),
      {}
    ))
  );
}
function isLoadable(x2) {
  return x2 instanceof BaseLoadable;
}
var LoadableStaticInterface = {
  of: (value) => Recoil_isPromise(value) ? loadableWithPromise(value) : isLoadable(value) ? value : loadableWithValue(value),
  error: (error) => loadableWithError(error),
  // $FlowIssue[incompatible-return]
  loading: () => loadableLoading(),
  // $FlowIssue[unclear-type]
  all: loadableAll,
  isLoadable
};
var Recoil_Loadable = {
  loadableWithValue,
  loadableWithError,
  loadableWithPromise,
  loadableLoading,
  loadableAll,
  isLoadable,
  RecoilLoadable: LoadableStaticInterface
};
var Recoil_Loadable_1 = Recoil_Loadable.loadableWithValue;
var Recoil_Loadable_2 = Recoil_Loadable.loadableWithError;
var Recoil_Loadable_3 = Recoil_Loadable.loadableWithPromise;
var Recoil_Loadable_4 = Recoil_Loadable.loadableLoading;
var Recoil_Loadable_5 = Recoil_Loadable.loadableAll;
var Recoil_Loadable_6 = Recoil_Loadable.isLoadable;
var Recoil_Loadable_7 = Recoil_Loadable.RecoilLoadable;
var Recoil_Loadable$1 = Object.freeze({
  __proto__: null,
  loadableWithValue: Recoil_Loadable_1,
  loadableWithError: Recoil_Loadable_2,
  loadableWithPromise: Recoil_Loadable_3,
  loadableLoading: Recoil_Loadable_4,
  loadableAll: Recoil_Loadable_5,
  isLoadable: Recoil_Loadable_6,
  RecoilLoadable: Recoil_Loadable_7
});
var env = {
  RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED: true,
  // Note: RECOIL_GKS_ENABLED settings will only be honored in OSS builds of Recoil
  RECOIL_GKS_ENABLED: /* @__PURE__ */ new Set(["recoil_hamt_2020", "recoil_sync_external_store", "recoil_suppress_rerender_in_callback", "recoil_memory_managament_2020"])
};
function readProcessEnvBooleanFlag(name, set) {
  var _process$env$name, _process$env$name$toL;
  const sanitizedValue = (_process$env$name = process.env[name]) === null || _process$env$name === void 0 ? void 0 : (_process$env$name$toL = _process$env$name.toLowerCase()) === null || _process$env$name$toL === void 0 ? void 0 : _process$env$name$toL.trim();
  if (sanitizedValue == null || sanitizedValue === "") {
    return;
  }
  const allowedValues = ["true", "false"];
  if (!allowedValues.includes(sanitizedValue)) {
    throw Recoil_err(`process.env.${name} value must be 'true', 'false', or empty: ${sanitizedValue}`);
  }
  set(sanitizedValue === "true");
}
function readProcessEnvStringArrayFlag(name, set) {
  var _process$env$name2;
  const sanitizedValue = (_process$env$name2 = process.env[name]) === null || _process$env$name2 === void 0 ? void 0 : _process$env$name2.trim();
  if (sanitizedValue == null || sanitizedValue === "") {
    return;
  }
  set(sanitizedValue.split(/\s*,\s*|\s+/));
}
function applyProcessEnvFlagOverrides() {
  var _process;
  if (typeof process === "undefined") {
    return;
  }
  if (((_process = process) === null || _process === void 0 ? void 0 : _process.env) == null) {
    return;
  }
  readProcessEnvBooleanFlag("RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED", (value) => {
    env.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED = value;
  });
  readProcessEnvStringArrayFlag("RECOIL_GKS_ENABLED", (value) => {
    value.forEach((gk) => {
      env.RECOIL_GKS_ENABLED.add(gk);
    });
  });
}
applyProcessEnvFlagOverrides();
var Recoil_RecoilEnv = env;
function Recoil_gkx_OSS(gk) {
  return Recoil_RecoilEnv.RECOIL_GKS_ENABLED.has(gk);
}
Recoil_gkx_OSS.setPass = (gk) => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.add(gk);
};
Recoil_gkx_OSS.setFail = (gk) => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.delete(gk);
};
Recoil_gkx_OSS.clear = () => {
  Recoil_RecoilEnv.RECOIL_GKS_ENABLED.clear();
};
var Recoil_gkx = Recoil_gkx_OSS;
function recoverableViolation(message, _projectName, {
  error
} = {}) {
  if (true) {
    console.error(message, error);
  }
  return null;
}
var recoverableViolation_1 = recoverableViolation;
var Recoil_recoverableViolation = recoverableViolation_1;
var _createMutableSource;
var _useMutableSource;
var _useSyncExternalStore;
var createMutableSource = (
  // flowlint-next-line unclear-type:off
  (_createMutableSource = import_react.default.createMutableSource) !== null && _createMutableSource !== void 0 ? _createMutableSource : import_react.default.unstable_createMutableSource
);
var useMutableSource = (
  // flowlint-next-line unclear-type:off
  (_useMutableSource = import_react.default.useMutableSource) !== null && _useMutableSource !== void 0 ? _useMutableSource : import_react.default.unstable_useMutableSource
);
var useSyncExternalStore = (
  // flowlint-next-line unclear-type:off
  (_useSyncExternalStore = import_react.default.useSyncExternalStore) !== null && _useSyncExternalStore !== void 0 ? _useSyncExternalStore : (
    // flowlint-next-line unclear-type:off
    import_react.default.unstable_useSyncExternalStore
  )
);
var ReactRendererVersionMismatchWarnOnce = false;
function currentRendererSupportsUseSyncExternalStore() {
  var _ReactCurrentDispatch;
  const {
    ReactCurrentDispatcher,
    ReactCurrentOwner
  } = (
    /* $FlowFixMe[prop-missing] This workaround was approved as a safer mechanism
     * to detect if the current renderer supports useSyncExternalStore()
     * https://fb.workplace.com/groups/reactjs/posts/9558682330846963/ */
    import_react.default.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  );
  const dispatcher = (_ReactCurrentDispatch = ReactCurrentDispatcher === null || ReactCurrentDispatcher === void 0 ? void 0 : ReactCurrentDispatcher.current) !== null && _ReactCurrentDispatch !== void 0 ? _ReactCurrentDispatch : ReactCurrentOwner.currentDispatcher;
  const isUseSyncExternalStoreSupported = dispatcher.useSyncExternalStore != null;
  if (useSyncExternalStore && !isUseSyncExternalStoreSupported && !ReactRendererVersionMismatchWarnOnce) {
    ReactRendererVersionMismatchWarnOnce = true;
    Recoil_recoverableViolation("A React renderer without React 18+ API support is being used with React 18+.");
  }
  return isUseSyncExternalStoreSupported;
}
function reactMode() {
  if (Recoil_gkx("recoil_transition_support")) {
    return {
      mode: "TRANSITION_SUPPORT",
      early: true,
      concurrent: true
    };
  }
  if (Recoil_gkx("recoil_sync_external_store") && useSyncExternalStore != null) {
    return {
      mode: "SYNC_EXTERNAL_STORE",
      early: true,
      concurrent: false
    };
  }
  if (Recoil_gkx("recoil_mutable_source") && useMutableSource != null && typeof window !== "undefined" && !window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE) {
    return Recoil_gkx("recoil_suppress_rerender_in_callback") ? {
      mode: "MUTABLE_SOURCE",
      early: true,
      concurrent: true
    } : {
      mode: "MUTABLE_SOURCE",
      early: false,
      concurrent: false
    };
  }
  return Recoil_gkx("recoil_suppress_rerender_in_callback") ? {
    mode: "LEGACY",
    early: true,
    concurrent: false
  } : {
    mode: "LEGACY",
    early: false,
    concurrent: false
  };
}
function isFastRefreshEnabled() {
  return false;
}
var Recoil_ReactMode = {
  createMutableSource,
  useMutableSource,
  useSyncExternalStore,
  currentRendererSupportsUseSyncExternalStore,
  reactMode,
  isFastRefreshEnabled
};
var AbstractRecoilValue = class {
  constructor(newKey) {
    _defineProperty(this, "key", void 0);
    this.key = newKey;
  }
  toJSON() {
    return {
      key: this.key
    };
  }
};
var RecoilState = class extends AbstractRecoilValue {
};
var RecoilValueReadOnly = class extends AbstractRecoilValue {
};
function isRecoilValue(x2) {
  return x2 instanceof RecoilState || x2 instanceof RecoilValueReadOnly;
}
var Recoil_RecoilValue = {
  AbstractRecoilValue,
  RecoilState,
  RecoilValueReadOnly,
  isRecoilValue
};
var Recoil_RecoilValue_1 = Recoil_RecoilValue.AbstractRecoilValue;
var Recoil_RecoilValue_2 = Recoil_RecoilValue.RecoilState;
var Recoil_RecoilValue_3 = Recoil_RecoilValue.RecoilValueReadOnly;
var Recoil_RecoilValue_4 = Recoil_RecoilValue.isRecoilValue;
var Recoil_RecoilValue$1 = Object.freeze({
  __proto__: null,
  AbstractRecoilValue: Recoil_RecoilValue_1,
  RecoilState: Recoil_RecoilValue_2,
  RecoilValueReadOnly: Recoil_RecoilValue_3,
  isRecoilValue: Recoil_RecoilValue_4
});
function sprintf(format, ...args) {
  let index = 0;
  return format.replace(/%s/g, () => String(args[index++]));
}
var sprintf_1 = sprintf;
function expectationViolation(format, ...args) {
  if (true) {
    const message = sprintf_1.call(null, format, ...args);
    const error = new Error(message);
    error.name = "Expectation Violation";
    console.error(error);
  }
}
var expectationViolation_1 = expectationViolation;
var Recoil_expectationViolation = expectationViolation_1;
function mapIterable(iterable, callback) {
  return function* () {
    let index = 0;
    for (const value of iterable) {
      yield callback(value, index++);
    }
  }();
}
var Recoil_mapIterable = mapIterable;
var {
  isFastRefreshEnabled: isFastRefreshEnabled$1
} = Recoil_ReactMode;
var DefaultValue = class {
};
var DEFAULT_VALUE = new DefaultValue();
var nodes = /* @__PURE__ */ new Map();
var recoilValues = /* @__PURE__ */ new Map();
function recoilValuesForKeys(keys) {
  return Recoil_mapIterable(keys, (key) => Recoil_nullthrows(recoilValues.get(key)));
}
function checkForDuplicateAtomKey(key) {
  if (nodes.has(key)) {
    const message = `Duplicate atom key "${key}". This is a FATAL ERROR in
      production. But it is safe to ignore this warning if it occurred because of
      hot module replacement.`;
    if (true) {
      if (!isFastRefreshEnabled$1()) {
        Recoil_expectationViolation(message, "recoil");
      }
    } else {
      console.warn(message);
    }
  }
}
function registerNode(node) {
  if (Recoil_RecoilEnv.RECOIL_DUPLICATE_ATOM_KEY_CHECKING_ENABLED) {
    checkForDuplicateAtomKey(node.key);
  }
  nodes.set(node.key, node);
  const recoilValue = node.set == null ? new Recoil_RecoilValue$1.RecoilValueReadOnly(node.key) : new Recoil_RecoilValue$1.RecoilState(node.key);
  recoilValues.set(node.key, recoilValue);
  return recoilValue;
}
var NodeMissingError = class extends Error {
};
function getNode(key) {
  const node = nodes.get(key);
  if (node == null) {
    throw new NodeMissingError(`Missing definition for RecoilValue: "${key}""`);
  }
  return node;
}
function getNodeMaybe(key) {
  return nodes.get(key);
}
var configDeletionHandlers = /* @__PURE__ */ new Map();
function deleteNodeConfigIfPossible(key) {
  var _node$shouldDeleteCon;
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const node = nodes.get(key);
  if (node !== null && node !== void 0 && (_node$shouldDeleteCon = node.shouldDeleteConfigOnRelease) !== null && _node$shouldDeleteCon !== void 0 && _node$shouldDeleteCon.call(node)) {
    var _getConfigDeletionHan;
    nodes.delete(key);
    (_getConfigDeletionHan = getConfigDeletionHandler(key)) === null || _getConfigDeletionHan === void 0 ? void 0 : _getConfigDeletionHan();
    configDeletionHandlers.delete(key);
  }
}
function setConfigDeletionHandler(key, fn2) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  if (fn2 === void 0) {
    configDeletionHandlers.delete(key);
  } else {
    configDeletionHandlers.set(key, fn2);
  }
}
function getConfigDeletionHandler(key) {
  return configDeletionHandlers.get(key);
}
var Recoil_Node = {
  nodes,
  recoilValues,
  registerNode,
  getNode,
  getNodeMaybe,
  deleteNodeConfigIfPossible,
  setConfigDeletionHandler,
  getConfigDeletionHandler,
  recoilValuesForKeys,
  NodeMissingError,
  DefaultValue,
  DEFAULT_VALUE
};
function enqueueExecution(s2, f2) {
  f2();
}
var Recoil_Queue = {
  enqueueExecution
};
function createCommonjsModule(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var hamt_1 = createCommonjsModule(function(module2) {
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
  } : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  var hamt = {};
  var SIZE = 5;
  var BUCKET_SIZE = Math.pow(2, SIZE);
  var MASK = BUCKET_SIZE - 1;
  var MAX_INDEX_NODE = BUCKET_SIZE / 2;
  var MIN_ARRAY_NODE = BUCKET_SIZE / 4;
  var nothing = {};
  var constant = function constant2(x2) {
    return function() {
      return x2;
    };
  };
  var hash = hamt.hash = function(str) {
    var type = typeof str === "undefined" ? "undefined" : _typeof(str);
    if (type === "number") return str;
    if (type !== "string") str += "";
    var hash2 = 0;
    for (var i2 = 0, len = str.length; i2 < len; ++i2) {
      var c2 = str.charCodeAt(i2);
      hash2 = (hash2 << 5) - hash2 + c2 | 0;
    }
    return hash2;
  };
  var popcount = function popcount2(x2) {
    x2 -= x2 >> 1 & 1431655765;
    x2 = (x2 & 858993459) + (x2 >> 2 & 858993459);
    x2 = x2 + (x2 >> 4) & 252645135;
    x2 += x2 >> 8;
    x2 += x2 >> 16;
    return x2 & 127;
  };
  var hashFragment = function hashFragment2(shift, h2) {
    return h2 >>> shift & MASK;
  };
  var toBitmap = function toBitmap2(x2) {
    return 1 << x2;
  };
  var fromBitmap = function fromBitmap2(bitmap, bit) {
    return popcount(bitmap & bit - 1);
  };
  var arrayUpdate = function arrayUpdate2(mutate2, at2, v2, arr) {
    var out = arr;
    if (!mutate2) {
      var len = arr.length;
      out = new Array(len);
      for (var i2 = 0; i2 < len; ++i2) {
        out[i2] = arr[i2];
      }
    }
    out[at2] = v2;
    return out;
  };
  var arraySpliceOut = function arraySpliceOut2(mutate2, at2, arr) {
    var newLen = arr.length - 1;
    var i2 = 0;
    var g2 = 0;
    var out = arr;
    if (mutate2) {
      i2 = g2 = at2;
    } else {
      out = new Array(newLen);
      while (i2 < at2) {
        out[g2++] = arr[i2++];
      }
    }
    ++i2;
    while (i2 <= newLen) {
      out[g2++] = arr[i2++];
    }
    if (mutate2) {
      out.length = newLen;
    }
    return out;
  };
  var arraySpliceIn = function arraySpliceIn2(mutate2, at2, v2, arr) {
    var len = arr.length;
    if (mutate2) {
      var _i2 = len;
      while (_i2 >= at2) {
        arr[_i2--] = arr[_i2];
      }
      arr[at2] = v2;
      return arr;
    }
    var i2 = 0, g2 = 0;
    var out = new Array(len + 1);
    while (i2 < at2) {
      out[g2++] = arr[i2++];
    }
    out[at2] = v2;
    while (i2 < len) {
      out[++g2] = arr[i2++];
    }
    return out;
  };
  var LEAF = 1;
  var COLLISION = 2;
  var INDEX = 3;
  var ARRAY = 4;
  var empty = {
    __hamt_isEmpty: true
  };
  var isEmptyNode = function isEmptyNode2(x2) {
    return x2 === empty || x2 && x2.__hamt_isEmpty;
  };
  var Leaf = function Leaf2(edit, hash2, key, value) {
    return {
      type: LEAF,
      edit,
      hash: hash2,
      key,
      value,
      _modify: Leaf__modify
    };
  };
  var Collision = function Collision2(edit, hash2, children) {
    return {
      type: COLLISION,
      edit,
      hash: hash2,
      children,
      _modify: Collision__modify
    };
  };
  var IndexedNode = function IndexedNode2(edit, mask, children) {
    return {
      type: INDEX,
      edit,
      mask,
      children,
      _modify: IndexedNode__modify
    };
  };
  var ArrayNode = function ArrayNode2(edit, size, children) {
    return {
      type: ARRAY,
      edit,
      size,
      children,
      _modify: ArrayNode__modify
    };
  };
  var isLeaf = function isLeaf2(node) {
    return node === empty || node.type === LEAF || node.type === COLLISION;
  };
  var expand = function expand2(edit, frag, child, bitmap, subNodes) {
    var arr = [];
    var bit = bitmap;
    var count2 = 0;
    for (var i2 = 0; bit; ++i2) {
      if (bit & 1) arr[i2] = subNodes[count2++];
      bit >>>= 1;
    }
    arr[frag] = child;
    return ArrayNode(edit, count2 + 1, arr);
  };
  var pack = function pack2(edit, count2, removed, elements) {
    var children = new Array(count2 - 1);
    var g2 = 0;
    var bitmap = 0;
    for (var i2 = 0, len = elements.length; i2 < len; ++i2) {
      if (i2 !== removed) {
        var elem = elements[i2];
        if (elem && !isEmptyNode(elem)) {
          children[g2++] = elem;
          bitmap |= 1 << i2;
        }
      }
    }
    return IndexedNode(edit, bitmap, children);
  };
  var mergeLeaves = function mergeLeaves2(edit, shift, h1, n1, h2, n2) {
    if (h1 === h2) return Collision(edit, h1, [n2, n1]);
    var subH1 = hashFragment(shift, h1);
    var subH2 = hashFragment(shift, h2);
    return IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), subH1 === subH2 ? [mergeLeaves2(edit, shift + SIZE, h1, n1, h2, n2)] : subH1 < subH2 ? [n1, n2] : [n2, n1]);
  };
  var updateCollisionList = function updateCollisionList2(mutate2, edit, keyEq, h2, list, f2, k2, size) {
    var len = list.length;
    for (var i2 = 0; i2 < len; ++i2) {
      var child = list[i2];
      if (keyEq(k2, child.key)) {
        var value = child.value;
        var _newValue = f2(value);
        if (_newValue === value) return list;
        if (_newValue === nothing) {
          --size.value;
          return arraySpliceOut(mutate2, i2, list);
        }
        return arrayUpdate(mutate2, i2, Leaf(edit, h2, k2, _newValue), list);
      }
    }
    var newValue = f2();
    if (newValue === nothing) return list;
    ++size.value;
    return arrayUpdate(mutate2, len, Leaf(edit, h2, k2, newValue), list);
  };
  var canEditNode = function canEditNode2(edit, node) {
    return edit === node.edit;
  };
  var Leaf__modify = function Leaf__modify2(edit, keyEq, shift, f2, h2, k2, size) {
    if (keyEq(k2, this.key)) {
      var _v = f2(this.value);
      if (_v === this.value) return this;
      else if (_v === nothing) {
        --size.value;
        return empty;
      }
      if (canEditNode(edit, this)) {
        this.value = _v;
        return this;
      }
      return Leaf(edit, h2, k2, _v);
    }
    var v2 = f2();
    if (v2 === nothing) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, h2, Leaf(edit, h2, k2, v2));
  };
  var Collision__modify = function Collision__modify2(edit, keyEq, shift, f2, h2, k2, size) {
    if (h2 === this.hash) {
      var canEdit = canEditNode(edit, this);
      var list = updateCollisionList(canEdit, edit, keyEq, this.hash, this.children, f2, k2, size);
      if (list === this.children) return this;
      return list.length > 1 ? Collision(edit, this.hash, list) : list[0];
    }
    var v2 = f2();
    if (v2 === nothing) return this;
    ++size.value;
    return mergeLeaves(edit, shift, this.hash, this, h2, Leaf(edit, h2, k2, v2));
  };
  var IndexedNode__modify = function IndexedNode__modify2(edit, keyEq, shift, f2, h2, k2, size) {
    var mask = this.mask;
    var children = this.children;
    var frag = hashFragment(shift, h2);
    var bit = toBitmap(frag);
    var indx = fromBitmap(mask, bit);
    var exists = mask & bit;
    var current = exists ? children[indx] : empty;
    var child = current._modify(edit, keyEq, shift + SIZE, f2, h2, k2, size);
    if (current === child) return this;
    var canEdit = canEditNode(edit, this);
    var bitmap = mask;
    var newChildren = void 0;
    if (exists && isEmptyNode(child)) {
      bitmap &= ~bit;
      if (!bitmap) return empty;
      if (children.length <= 2 && isLeaf(children[indx ^ 1])) return children[indx ^ 1];
      newChildren = arraySpliceOut(canEdit, indx, children);
    } else if (!exists && !isEmptyNode(child)) {
      if (children.length >= MAX_INDEX_NODE) return expand(edit, frag, child, mask, children);
      bitmap |= bit;
      newChildren = arraySpliceIn(canEdit, indx, child, children);
    } else {
      newChildren = arrayUpdate(canEdit, indx, child, children);
    }
    if (canEdit) {
      this.mask = bitmap;
      this.children = newChildren;
      return this;
    }
    return IndexedNode(edit, bitmap, newChildren);
  };
  var ArrayNode__modify = function ArrayNode__modify2(edit, keyEq, shift, f2, h2, k2, size) {
    var count2 = this.size;
    var children = this.children;
    var frag = hashFragment(shift, h2);
    var child = children[frag];
    var newChild = (child || empty)._modify(edit, keyEq, shift + SIZE, f2, h2, k2, size);
    if (child === newChild) return this;
    var canEdit = canEditNode(edit, this);
    var newChildren = void 0;
    if (isEmptyNode(child) && !isEmptyNode(newChild)) {
      ++count2;
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
      --count2;
      if (count2 <= MIN_ARRAY_NODE) return pack(edit, count2, frag, children);
      newChildren = arrayUpdate(canEdit, frag, empty, children);
    } else {
      newChildren = arrayUpdate(canEdit, frag, newChild, children);
    }
    if (canEdit) {
      this.size = count2;
      this.children = newChildren;
      return this;
    }
    return ArrayNode(edit, count2, newChildren);
  };
  empty._modify = function(edit, keyEq, shift, f2, h2, k2, size) {
    var v2 = f2();
    if (v2 === nothing) return empty;
    ++size.value;
    return Leaf(edit, h2, k2, v2);
  };
  function Map2(editable, edit, config, root, size) {
    this._editable = editable;
    this._edit = edit;
    this._config = config;
    this._root = root;
    this._size = size;
  }
  Map2.prototype.setTree = function(newRoot, newSize) {
    if (this._editable) {
      this._root = newRoot;
      this._size = newSize;
      return this;
    }
    return newRoot === this._root ? this : new Map2(this._editable, this._edit, this._config, newRoot, newSize);
  };
  var tryGetHash = hamt.tryGetHash = function(alt, hash2, key, map) {
    var node = map._root;
    var shift = 0;
    var keyEq = map._config.keyEq;
    while (true) {
      switch (node.type) {
        case LEAF: {
          return keyEq(key, node.key) ? node.value : alt;
        }
        case COLLISION: {
          if (hash2 === node.hash) {
            var children = node.children;
            for (var i2 = 0, len = children.length; i2 < len; ++i2) {
              var child = children[i2];
              if (keyEq(key, child.key)) return child.value;
            }
          }
          return alt;
        }
        case INDEX: {
          var frag = hashFragment(shift, hash2);
          var bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift += SIZE;
            break;
          }
          return alt;
        }
        case ARRAY: {
          node = node.children[hashFragment(shift, hash2)];
          if (node) {
            shift += SIZE;
            break;
          }
          return alt;
        }
        default:
          return alt;
      }
    }
  };
  Map2.prototype.tryGetHash = function(alt, hash2, key) {
    return tryGetHash(alt, hash2, key, this);
  };
  var tryGet = hamt.tryGet = function(alt, key, map) {
    return tryGetHash(alt, map._config.hash(key), key, map);
  };
  Map2.prototype.tryGet = function(alt, key) {
    return tryGet(alt, key, this);
  };
  var getHash = hamt.getHash = function(hash2, key, map) {
    return tryGetHash(void 0, hash2, key, map);
  };
  Map2.prototype.getHash = function(hash2, key) {
    return getHash(hash2, key, this);
  };
  var get5 = hamt.get = function(key, map) {
    return tryGetHash(void 0, map._config.hash(key), key, map);
  };
  Map2.prototype.get = function(key, alt) {
    return tryGet(alt, key, this);
  };
  var hasHash = hamt.has = function(hash2, key, map) {
    return tryGetHash(nothing, hash2, key, map) !== nothing;
  };
  Map2.prototype.hasHash = function(hash2, key) {
    return hasHash(hash2, key, this);
  };
  var has = hamt.has = function(key, map) {
    return hasHash(map._config.hash(key), key, map);
  };
  Map2.prototype.has = function(key) {
    return has(key, this);
  };
  var defKeyCompare = function defKeyCompare2(x2, y2) {
    return x2 === y2;
  };
  hamt.make = function(config) {
    return new Map2(0, 0, {
      keyEq: config && config.keyEq || defKeyCompare,
      hash: config && config.hash || hash
    }, empty, 0);
  };
  hamt.empty = hamt.make();
  var isEmpty = hamt.isEmpty = function(map) {
    return map && !!isEmptyNode(map._root);
  };
  Map2.prototype.isEmpty = function() {
    return isEmpty(this);
  };
  var modifyHash = hamt.modifyHash = function(f2, hash2, key, map) {
    var size = {
      value: map._size
    };
    var newRoot = map._root._modify(map._editable ? map._edit : NaN, map._config.keyEq, 0, f2, hash2, key, size);
    return map.setTree(newRoot, size.value);
  };
  Map2.prototype.modifyHash = function(hash2, key, f2) {
    return modifyHash(f2, hash2, key, this);
  };
  var modify = hamt.modify = function(f2, key, map) {
    return modifyHash(f2, map._config.hash(key), key, map);
  };
  Map2.prototype.modify = function(key, f2) {
    return modify(f2, key, this);
  };
  var setHash = hamt.setHash = function(hash2, key, value, map) {
    return modifyHash(constant(value), hash2, key, map);
  };
  Map2.prototype.setHash = function(hash2, key, value) {
    return setHash(hash2, key, value, this);
  };
  var set = hamt.set = function(key, value, map) {
    return setHash(map._config.hash(key), key, value, map);
  };
  Map2.prototype.set = function(key, value) {
    return set(key, value, this);
  };
  var del = constant(nothing);
  var removeHash = hamt.removeHash = function(hash2, key, map) {
    return modifyHash(del, hash2, key, map);
  };
  Map2.prototype.removeHash = Map2.prototype.deleteHash = function(hash2, key) {
    return removeHash(hash2, key, this);
  };
  var remove = hamt.remove = function(key, map) {
    return removeHash(map._config.hash(key), key, map);
  };
  Map2.prototype.remove = Map2.prototype.delete = function(key) {
    return remove(key, this);
  };
  var beginMutation = hamt.beginMutation = function(map) {
    return new Map2(map._editable + 1, map._edit + 1, map._config, map._root, map._size);
  };
  Map2.prototype.beginMutation = function() {
    return beginMutation(this);
  };
  var endMutation = hamt.endMutation = function(map) {
    map._editable = map._editable && map._editable - 1;
    return map;
  };
  Map2.prototype.endMutation = function() {
    return endMutation(this);
  };
  var mutate = hamt.mutate = function(f2, map) {
    var transient = beginMutation(map);
    f2(transient);
    return endMutation(transient);
  };
  Map2.prototype.mutate = function(f2) {
    return mutate(f2, this);
  };
  var appk = function appk2(k2) {
    return k2 && lazyVisitChildren(k2[0], k2[1], k2[2], k2[3], k2[4]);
  };
  var lazyVisitChildren = function lazyVisitChildren2(len, children, i2, f2, k2) {
    while (i2 < len) {
      var child = children[i2++];
      if (child && !isEmptyNode(child)) return lazyVisit(child, f2, [len, children, i2, f2, k2]);
    }
    return appk(k2);
  };
  var lazyVisit = function lazyVisit2(node, f2, k2) {
    switch (node.type) {
      case LEAF:
        return {
          value: f2(node),
          rest: k2
        };
      case COLLISION:
      case ARRAY:
      case INDEX:
        var children = node.children;
        return lazyVisitChildren(children.length, children, 0, f2, k2);
      default:
        return appk(k2);
    }
  };
  var DONE = {
    done: true
  };
  function MapIterator(v2) {
    this.v = v2;
  }
  MapIterator.prototype.next = function() {
    if (!this.v) return DONE;
    var v0 = this.v;
    this.v = appk(v0.rest);
    return v0;
  };
  MapIterator.prototype[Symbol.iterator] = function() {
    return this;
  };
  var visit = function visit2(map, f2) {
    return new MapIterator(lazyVisit(map._root, f2));
  };
  var buildPairs = function buildPairs2(x2) {
    return [x2.key, x2.value];
  };
  var entries = hamt.entries = function(map) {
    return visit(map, buildPairs);
  };
  Map2.prototype.entries = Map2.prototype[Symbol.iterator] = function() {
    return entries(this);
  };
  var buildKeys = function buildKeys2(x2) {
    return x2.key;
  };
  var keys = hamt.keys = function(map) {
    return visit(map, buildKeys);
  };
  Map2.prototype.keys = function() {
    return keys(this);
  };
  var buildValues = function buildValues2(x2) {
    return x2.value;
  };
  var values = hamt.values = Map2.prototype.values = function(map) {
    return visit(map, buildValues);
  };
  Map2.prototype.values = function() {
    return values(this);
  };
  var fold = hamt.fold = function(f2, z2, m2) {
    var root = m2._root;
    if (root.type === LEAF) return f2(z2, root.value, root.key);
    var toVisit = [root.children];
    var children = void 0;
    while (children = toVisit.pop()) {
      for (var i2 = 0, len = children.length; i2 < len; ) {
        var child = children[i2++];
        if (child && child.type) {
          if (child.type === LEAF) z2 = f2(z2, child.value, child.key);
          else toVisit.push(child.children);
        }
      }
    }
    return z2;
  };
  Map2.prototype.fold = function(f2, z2) {
    return fold(f2, z2, this);
  };
  var forEach = hamt.forEach = function(f2, map) {
    return fold(function(_2, value, key) {
      return f2(value, key, map);
    }, null, map);
  };
  Map2.prototype.forEach = function(f2) {
    return forEach(f2, this);
  };
  var count = hamt.count = function(map) {
    return map._size;
  };
  Map2.prototype.count = function() {
    return count(this);
  };
  Object.defineProperty(Map2.prototype, "size", {
    get: Map2.prototype.count
  });
  if (module2.exports) {
    module2.exports = hamt;
  } else {
    (void 0).hamt = hamt;
  }
});
var BuiltInMap = class {
  constructor(existing) {
    _defineProperty(this, "_map", void 0);
    this._map = new Map(existing === null || existing === void 0 ? void 0 : existing.entries());
  }
  keys() {
    return this._map.keys();
  }
  entries() {
    return this._map.entries();
  }
  get(k2) {
    return this._map.get(k2);
  }
  has(k2) {
    return this._map.has(k2);
  }
  set(k2, v2) {
    this._map.set(k2, v2);
    return this;
  }
  delete(k2) {
    this._map.delete(k2);
    return this;
  }
  clone() {
    return persistentMap(this);
  }
  toMap() {
    return new Map(this._map);
  }
};
var HashArrayMappedTrieMap = class _HashArrayMappedTrieMap {
  // Because hamt.empty is not a function there is no way to introduce type
  // parameters on it, so empty is typed as HAMTPlusMap<string, mixed>.
  // $FlowIssue
  constructor(existing) {
    _defineProperty(this, "_hamt", hamt_1.empty.beginMutation());
    if (existing instanceof _HashArrayMappedTrieMap) {
      const h2 = existing._hamt.endMutation();
      existing._hamt = h2.beginMutation();
      this._hamt = h2.beginMutation();
    } else if (existing) {
      for (const [k2, v2] of existing.entries()) {
        this._hamt.set(k2, v2);
      }
    }
  }
  keys() {
    return this._hamt.keys();
  }
  entries() {
    return this._hamt.entries();
  }
  get(k2) {
    return this._hamt.get(k2);
  }
  has(k2) {
    return this._hamt.has(k2);
  }
  set(k2, v2) {
    this._hamt.set(k2, v2);
    return this;
  }
  delete(k2) {
    this._hamt.delete(k2);
    return this;
  }
  clone() {
    return persistentMap(this);
  }
  toMap() {
    return new Map(this._hamt);
  }
};
function persistentMap(existing) {
  if (Recoil_gkx("recoil_hamt_2020")) {
    return new HashArrayMappedTrieMap(existing);
  } else {
    return new BuiltInMap(existing);
  }
}
var Recoil_PersistentMap = {
  persistentMap
};
var Recoil_PersistentMap_1 = Recoil_PersistentMap.persistentMap;
var Recoil_PersistentMap$1 = Object.freeze({
  __proto__: null,
  persistentMap: Recoil_PersistentMap_1
});
function differenceSets(set, ...setsWithValuesToRemove) {
  const ret = /* @__PURE__ */ new Set();
  FIRST: for (const value of set) {
    for (const otherSet of setsWithValuesToRemove) {
      if (otherSet.has(value)) {
        continue FIRST;
      }
    }
    ret.add(value);
  }
  return ret;
}
var Recoil_differenceSets = differenceSets;
function mapMap(map, callback) {
  const result = /* @__PURE__ */ new Map();
  map.forEach((value, key) => {
    result.set(key, callback(value, key));
  });
  return result;
}
var Recoil_mapMap = mapMap;
function makeGraph() {
  return {
    nodeDeps: /* @__PURE__ */ new Map(),
    nodeToNodeSubscriptions: /* @__PURE__ */ new Map()
  };
}
function cloneGraph(graph2) {
  return {
    nodeDeps: Recoil_mapMap(graph2.nodeDeps, (s2) => new Set(s2)),
    nodeToNodeSubscriptions: Recoil_mapMap(graph2.nodeToNodeSubscriptions, (s2) => new Set(s2))
  };
}
function mergeDepsIntoGraph(key, newDeps, graph2, olderGraph) {
  const {
    nodeDeps,
    nodeToNodeSubscriptions
  } = graph2;
  const oldDeps = nodeDeps.get(key);
  if (oldDeps && olderGraph && oldDeps !== olderGraph.nodeDeps.get(key)) {
    return;
  }
  nodeDeps.set(key, newDeps);
  const addedDeps = oldDeps == null ? newDeps : Recoil_differenceSets(newDeps, oldDeps);
  for (const dep of addedDeps) {
    if (!nodeToNodeSubscriptions.has(dep)) {
      nodeToNodeSubscriptions.set(dep, /* @__PURE__ */ new Set());
    }
    const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
    existing.add(key);
  }
  if (oldDeps) {
    const removedDeps = Recoil_differenceSets(oldDeps, newDeps);
    for (const dep of removedDeps) {
      if (!nodeToNodeSubscriptions.has(dep)) {
        return;
      }
      const existing = Recoil_nullthrows(nodeToNodeSubscriptions.get(dep));
      existing.delete(key);
      if (existing.size === 0) {
        nodeToNodeSubscriptions.delete(dep);
      }
    }
  }
}
function saveDepsToStore(key, deps, store, version) {
  var _storeState$nextTree, _storeState$previousT, _storeState$previousT2, _storeState$previousT3;
  const storeState = store.getState();
  if (!(version === storeState.currentTree.version || version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
    Recoil_recoverableViolation("Tried to save dependencies to a discarded tree");
  }
  const graph2 = store.getGraph(version);
  mergeDepsIntoGraph(key, deps, graph2);
  if (version === ((_storeState$previousT2 = storeState.previousTree) === null || _storeState$previousT2 === void 0 ? void 0 : _storeState$previousT2.version)) {
    const currentGraph = store.getGraph(storeState.currentTree.version);
    mergeDepsIntoGraph(key, deps, currentGraph, graph2);
  }
  if (version === ((_storeState$previousT3 = storeState.previousTree) === null || _storeState$previousT3 === void 0 ? void 0 : _storeState$previousT3.version) || version === storeState.currentTree.version) {
    var _storeState$nextTree2;
    const nextVersion = (_storeState$nextTree2 = storeState.nextTree) === null || _storeState$nextTree2 === void 0 ? void 0 : _storeState$nextTree2.version;
    if (nextVersion !== void 0) {
      const nextGraph = store.getGraph(nextVersion);
      mergeDepsIntoGraph(key, deps, nextGraph, graph2);
    }
  }
}
var Recoil_Graph = {
  cloneGraph,
  graph: makeGraph,
  saveDepsToStore
};
var nextTreeStateVersion = 0;
var getNextTreeStateVersion = () => nextTreeStateVersion++;
var nextStoreID = 0;
var getNextStoreID = () => nextStoreID++;
var nextComponentID = 0;
var getNextComponentID = () => nextComponentID++;
var Recoil_Keys = {
  getNextTreeStateVersion,
  getNextStoreID,
  getNextComponentID
};
var {
  persistentMap: persistentMap$1
} = Recoil_PersistentMap$1;
var {
  graph
} = Recoil_Graph;
var {
  getNextTreeStateVersion: getNextTreeStateVersion$1
} = Recoil_Keys;
function makeEmptyTreeState() {
  const version = getNextTreeStateVersion$1();
  return {
    version,
    stateID: version,
    transactionMetadata: {},
    dirtyAtoms: /* @__PURE__ */ new Set(),
    atomValues: persistentMap$1(),
    nonvalidatedAtoms: persistentMap$1()
  };
}
function makeEmptyStoreState() {
  const currentTree = makeEmptyTreeState();
  return {
    currentTree,
    nextTree: null,
    previousTree: null,
    commitDepth: 0,
    knownAtoms: /* @__PURE__ */ new Set(),
    knownSelectors: /* @__PURE__ */ new Set(),
    transactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: /* @__PURE__ */ new Set(),
    graphsByVersion: (/* @__PURE__ */ new Map()).set(currentTree.version, graph()),
    retention: {
      referenceCounts: /* @__PURE__ */ new Map(),
      nodesRetainedByZone: /* @__PURE__ */ new Map(),
      retainablesToCheckForRelease: /* @__PURE__ */ new Set()
    },
    nodeCleanupFunctions: /* @__PURE__ */ new Map()
  };
}
var Recoil_State = {
  makeEmptyTreeState,
  makeEmptyStoreState,
  getNextTreeStateVersion: getNextTreeStateVersion$1
};
var RetentionZone = class {
};
function retentionZone() {
  return new RetentionZone();
}
var Recoil_RetentionZone = {
  RetentionZone,
  retentionZone
};
function setByAddingToSet(set, v2) {
  const next = new Set(set);
  next.add(v2);
  return next;
}
function setByDeletingFromSet(set, v2) {
  const next = new Set(set);
  next.delete(v2);
  return next;
}
function mapBySettingInMap(map, k2, v2) {
  const next = new Map(map);
  next.set(k2, v2);
  return next;
}
function mapByUpdatingInMap(map, k2, updater) {
  const next = new Map(map);
  next.set(k2, updater(next.get(k2)));
  return next;
}
function mapByDeletingFromMap(map, k2) {
  const next = new Map(map);
  next.delete(k2);
  return next;
}
function mapByDeletingMultipleFromMap(map, ks2) {
  const next = new Map(map);
  ks2.forEach((k2) => next.delete(k2));
  return next;
}
var Recoil_CopyOnWrite = {
  setByAddingToSet,
  setByDeletingFromSet,
  mapBySettingInMap,
  mapByUpdatingInMap,
  mapByDeletingFromMap,
  mapByDeletingMultipleFromMap
};
function* filterIterable(iterable, predicate) {
  let index = 0;
  for (const value of iterable) {
    if (predicate(value, index++)) {
      yield value;
    }
  }
}
var Recoil_filterIterable = filterIterable;
function lazyProxy(base, factories) {
  const proxy = new Proxy(base, {
    // Compute and cache lazy property if not already done.
    get: (target, prop) => {
      if (!(prop in target) && prop in factories) {
        target[prop] = factories[prop]();
      }
      return target[prop];
    },
    // This method allows user to iterate keys as normal
    ownKeys: (target) => {
      return Object.keys(target);
    }
  });
  return proxy;
}
var Recoil_lazyProxy = lazyProxy;
var {
  getNode: getNode$1,
  getNodeMaybe: getNodeMaybe$1,
  recoilValuesForKeys: recoilValuesForKeys$1
} = Recoil_Node;
var {
  RetentionZone: RetentionZone$1
} = Recoil_RetentionZone;
var {
  setByAddingToSet: setByAddingToSet$1
} = Recoil_CopyOnWrite;
var emptySet = Object.freeze(/* @__PURE__ */ new Set());
var ReadOnlyRecoilValueError = class extends Error {
};
function initializeRetentionForNode(store, nodeKey, retainedBy) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return () => void 0;
  }
  const {
    nodesRetainedByZone: nodesRetainedByZone2
  } = store.getState().retention;
  function addToZone(zone) {
    let set = nodesRetainedByZone2.get(zone);
    if (!set) {
      nodesRetainedByZone2.set(zone, set = /* @__PURE__ */ new Set());
    }
    set.add(nodeKey);
  }
  if (retainedBy instanceof RetentionZone$1) {
    addToZone(retainedBy);
  } else if (Array.isArray(retainedBy)) {
    for (const zone of retainedBy) {
      addToZone(zone);
    }
  }
  return () => {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    const {
      retention
    } = store.getState();
    function deleteFromZone(zone) {
      const set = retention.nodesRetainedByZone.get(zone);
      set === null || set === void 0 ? void 0 : set.delete(nodeKey);
      if (set && set.size === 0) {
        retention.nodesRetainedByZone.delete(zone);
      }
    }
    if (retainedBy instanceof RetentionZone$1) {
      deleteFromZone(retainedBy);
    } else if (Array.isArray(retainedBy)) {
      for (const zone of retainedBy) {
        deleteFromZone(zone);
      }
    }
  };
}
function initializeNodeIfNewToStore(store, treeState, key, trigger) {
  const storeState = store.getState();
  if (storeState.nodeCleanupFunctions.has(key)) {
    return;
  }
  const node = getNode$1(key);
  const retentionCleanup = initializeRetentionForNode(store, key, node.retainedBy);
  const nodeCleanup = node.init(store, treeState, trigger);
  storeState.nodeCleanupFunctions.set(key, () => {
    nodeCleanup();
    retentionCleanup();
  });
}
function initializeNode(store, key, trigger) {
  initializeNodeIfNewToStore(store, store.getState().currentTree, key, trigger);
}
function cleanUpNode(store, key) {
  var _state$nodeCleanupFun;
  const state = store.getState();
  (_state$nodeCleanupFun = state.nodeCleanupFunctions.get(key)) === null || _state$nodeCleanupFun === void 0 ? void 0 : _state$nodeCleanupFun();
  state.nodeCleanupFunctions.delete(key);
}
function getNodeLoadable(store, state, key) {
  initializeNodeIfNewToStore(store, state, key, "get");
  return getNode$1(key).get(store, state);
}
function peekNodeLoadable(store, state, key) {
  return getNode$1(key).peek(store, state);
}
function setUnvalidatedAtomValue_DEPRECATED(state, key, newValue) {
  var _node$invalidate;
  const node = getNodeMaybe$1(key);
  node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
  return {
    ...state,
    atomValues: state.atomValues.clone().delete(key),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone().set(key, newValue),
    dirtyAtoms: setByAddingToSet$1(state.dirtyAtoms, key)
  };
}
function setNodeValue(store, state, key, newValue) {
  const node = getNode$1(key);
  if (node.set == null) {
    throw new ReadOnlyRecoilValueError(`Attempt to set read-only RecoilValue: ${key}`);
  }
  const set = node.set;
  initializeNodeIfNewToStore(store, state, key, "set");
  return set(store, state, newValue);
}
function peekNodeInfo(store, state, key) {
  const storeState = store.getState();
  const graph2 = store.getGraph(state.version);
  const type = getNode$1(key).nodeType;
  return Recoil_lazyProxy({
    type
  }, {
    // $FlowFixMe[underconstrained-implicit-instantiation]
    loadable: () => peekNodeLoadable(store, state, key),
    isActive: () => storeState.knownAtoms.has(key) || storeState.knownSelectors.has(key),
    isSet: () => type === "selector" ? false : state.atomValues.has(key),
    isModified: () => state.dirtyAtoms.has(key),
    // Report current dependencies.  If the node hasn't been evaluated, then
    // dependencies may be missing based on the current state.
    deps: () => {
      var _graph$nodeDeps$get;
      return recoilValuesForKeys$1((_graph$nodeDeps$get = graph2.nodeDeps.get(key)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : []);
    },
    // Reports all "current" subscribers.  Evaluating other nodes or
    // previous in-progress async evaluations may introduce new subscribers.
    subscribers: () => {
      var _storeState$nodeToCom, _storeState$nodeToCom2;
      return {
        nodes: recoilValuesForKeys$1(Recoil_filterIterable(getDownstreamNodes(store, state, /* @__PURE__ */ new Set([key])), (nodeKey) => nodeKey !== key)),
        components: Recoil_mapIterable((_storeState$nodeToCom = (_storeState$nodeToCom2 = storeState.nodeToComponentSubscriptions.get(key)) === null || _storeState$nodeToCom2 === void 0 ? void 0 : _storeState$nodeToCom2.values()) !== null && _storeState$nodeToCom !== void 0 ? _storeState$nodeToCom : [], ([name]) => ({
          name
        }))
      };
    }
  });
}
function getDownstreamNodes(store, state, keys) {
  const visitedNodes = /* @__PURE__ */ new Set();
  const visitingNodes = Array.from(keys);
  const graph2 = store.getGraph(state.version);
  for (let key = visitingNodes.pop(); key; key = visitingNodes.pop()) {
    var _graph$nodeToNodeSubs;
    visitedNodes.add(key);
    const subscribedNodes = (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(key)) !== null && _graph$nodeToNodeSubs !== void 0 ? _graph$nodeToNodeSubs : emptySet;
    for (const downstreamNode of subscribedNodes) {
      if (!visitedNodes.has(downstreamNode)) {
        visitingNodes.push(downstreamNode);
      }
    }
  }
  return visitedNodes;
}
var Recoil_FunctionalCore = {
  getNodeLoadable,
  peekNodeLoadable,
  setNodeValue,
  initializeNode,
  cleanUpNode,
  setUnvalidatedAtomValue_DEPRECATED,
  peekNodeInfo,
  getDownstreamNodes
};
var _invalidateMemoizedSnapshot = null;
function setInvalidateMemoizedSnapshot(invalidate) {
  _invalidateMemoizedSnapshot = invalidate;
}
function invalidateMemoizedSnapshot() {
  var _invalidateMemoizedSn;
  (_invalidateMemoizedSn = _invalidateMemoizedSnapshot) === null || _invalidateMemoizedSn === void 0 ? void 0 : _invalidateMemoizedSn();
}
var Recoil_SnapshotCache = {
  setInvalidateMemoizedSnapshot,
  invalidateMemoizedSnapshot
};
var {
  getDownstreamNodes: getDownstreamNodes$1,
  getNodeLoadable: getNodeLoadable$1,
  setNodeValue: setNodeValue$1
} = Recoil_FunctionalCore;
var {
  getNextComponentID: getNextComponentID$1
} = Recoil_Keys;
var {
  getNode: getNode$2,
  getNodeMaybe: getNodeMaybe$2
} = Recoil_Node;
var {
  DefaultValue: DefaultValue$1
} = Recoil_Node;
var {
  reactMode: reactMode$1
} = Recoil_ReactMode;
var {
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  isRecoilValue: isRecoilValue$1
} = Recoil_RecoilValue$1;
var {
  invalidateMemoizedSnapshot: invalidateMemoizedSnapshot$1
} = Recoil_SnapshotCache;
function getRecoilValueAsLoadable(store, {
  key
}, treeState = store.getState().currentTree) {
  var _storeState$nextTree, _storeState$previousT;
  const storeState = store.getState();
  if (!(treeState.version === storeState.currentTree.version || treeState.version === ((_storeState$nextTree = storeState.nextTree) === null || _storeState$nextTree === void 0 ? void 0 : _storeState$nextTree.version) || treeState.version === ((_storeState$previousT = storeState.previousTree) === null || _storeState$previousT === void 0 ? void 0 : _storeState$previousT.version))) {
    Recoil_recoverableViolation("Tried to read from a discarded tree");
  }
  const loadable = getNodeLoadable$1(store, treeState, key);
  if (loadable.state === "loading") {
    loadable.contents.catch(() => {
      return;
    });
  }
  return loadable;
}
function applyAtomValueWrites(atomValues, writes) {
  const result = atomValues.clone();
  writes.forEach((v2, k2) => {
    if (v2.state === "hasValue" && v2.contents instanceof DefaultValue$1) {
      result.delete(k2);
    } else {
      result.set(k2, v2);
    }
  });
  return result;
}
function valueFromValueOrUpdater(store, state, {
  key
}, valueOrUpdater) {
  if (typeof valueOrUpdater === "function") {
    const current = getNodeLoadable$1(store, state, key);
    if (current.state === "loading") {
      const msg = `Tried to set atom or selector "${key}" using an updater function while the current state is pending, this is not currently supported.`;
      Recoil_recoverableViolation(msg);
      throw Recoil_err(msg);
    } else if (current.state === "hasError") {
      throw current.contents;
    }
    return valueOrUpdater(current.contents);
  } else {
    return valueOrUpdater;
  }
}
function applyAction(store, state, action) {
  if (action.type === "set") {
    const {
      recoilValue,
      valueOrUpdater
    } = action;
    const newValue = valueFromValueOrUpdater(store, state, recoilValue, valueOrUpdater);
    const writes = setNodeValue$1(store, state, recoilValue.key, newValue);
    for (const [key, loadable] of writes.entries()) {
      writeLoadableToTreeState(state, key, loadable);
    }
  } else if (action.type === "setLoadable") {
    const {
      recoilValue: {
        key
      },
      loadable
    } = action;
    writeLoadableToTreeState(state, key, loadable);
  } else if (action.type === "markModified") {
    const {
      recoilValue: {
        key
      }
    } = action;
    state.dirtyAtoms.add(key);
  } else if (action.type === "setUnvalidated") {
    var _node$invalidate;
    const {
      recoilValue: {
        key
      },
      unvalidatedValue
    } = action;
    const node = getNodeMaybe$2(key);
    node === null || node === void 0 ? void 0 : (_node$invalidate = node.invalidate) === null || _node$invalidate === void 0 ? void 0 : _node$invalidate.call(node, state);
    state.atomValues.delete(key);
    state.nonvalidatedAtoms.set(key, unvalidatedValue);
    state.dirtyAtoms.add(key);
  } else {
    Recoil_recoverableViolation(`Unknown action ${action.type}`);
  }
}
function writeLoadableToTreeState(state, key, loadable) {
  if (loadable.state === "hasValue" && loadable.contents instanceof DefaultValue$1) {
    state.atomValues.delete(key);
  } else {
    state.atomValues.set(key, loadable);
  }
  state.dirtyAtoms.add(key);
  state.nonvalidatedAtoms.delete(key);
}
function applyActionsToStore(store, actions) {
  store.replaceState((state) => {
    const newState = copyTreeState(state);
    for (const action of actions) {
      applyAction(store, newState, action);
    }
    invalidateDownstreams(store, newState);
    invalidateMemoizedSnapshot$1();
    return newState;
  });
}
function queueOrPerformStateUpdate(store, action) {
  if (batchStack.length) {
    const actionsByStore = batchStack[batchStack.length - 1];
    let actions = actionsByStore.get(store);
    if (!actions) {
      actionsByStore.set(store, actions = []);
    }
    actions.push(action);
  } else {
    applyActionsToStore(store, [action]);
  }
}
var batchStack = [];
function batchStart() {
  const actionsByStore = /* @__PURE__ */ new Map();
  batchStack.push(actionsByStore);
  return () => {
    for (const [store, actions] of actionsByStore) {
      applyActionsToStore(store, actions);
    }
    const popped = batchStack.pop();
    if (popped !== actionsByStore) {
      Recoil_recoverableViolation("Incorrect order of batch popping");
    }
  };
}
function copyTreeState(state) {
  return {
    ...state,
    atomValues: state.atomValues.clone(),
    nonvalidatedAtoms: state.nonvalidatedAtoms.clone(),
    dirtyAtoms: new Set(state.dirtyAtoms)
  };
}
function invalidateDownstreams(store, state) {
  const downstreams = getDownstreamNodes$1(store, state, state.dirtyAtoms);
  for (const key of downstreams) {
    var _getNodeMaybe, _getNodeMaybe$invalid;
    (_getNodeMaybe = getNodeMaybe$2(key)) === null || _getNodeMaybe === void 0 ? void 0 : (_getNodeMaybe$invalid = _getNodeMaybe.invalidate) === null || _getNodeMaybe$invalid === void 0 ? void 0 : _getNodeMaybe$invalid.call(_getNodeMaybe, state);
  }
}
function setRecoilValue(store, recoilValue, valueOrUpdater) {
  queueOrPerformStateUpdate(store, {
    type: "set",
    recoilValue,
    valueOrUpdater
  });
}
function setRecoilValueLoadable(store, recoilValue, loadable) {
  if (loadable instanceof DefaultValue$1) {
    return setRecoilValue(store, recoilValue, loadable);
  }
  queueOrPerformStateUpdate(store, {
    type: "setLoadable",
    recoilValue,
    loadable
  });
}
function markRecoilValueModified(store, recoilValue) {
  queueOrPerformStateUpdate(store, {
    type: "markModified",
    recoilValue
  });
}
function setUnvalidatedRecoilValue(store, recoilValue, unvalidatedValue) {
  queueOrPerformStateUpdate(store, {
    type: "setUnvalidated",
    recoilValue,
    unvalidatedValue
  });
}
function subscribeToRecoilValue(store, {
  key
}, callback, componentDebugName = null) {
  const subID = getNextComponentID$1();
  const storeState = store.getState();
  if (!storeState.nodeToComponentSubscriptions.has(key)) {
    storeState.nodeToComponentSubscriptions.set(key, /* @__PURE__ */ new Map());
  }
  Recoil_nullthrows(storeState.nodeToComponentSubscriptions.get(key)).set(subID, [componentDebugName !== null && componentDebugName !== void 0 ? componentDebugName : "<not captured>", callback]);
  const mode2 = reactMode$1();
  if (mode2.early && (mode2.mode === "LEGACY" || mode2.mode === "MUTABLE_SOURCE")) {
    const nextTree = store.getState().nextTree;
    if (nextTree && nextTree.dirtyAtoms.has(key)) {
      callback(nextTree);
    }
  }
  return {
    release: () => {
      const releaseStoreState = store.getState();
      const subs = releaseStoreState.nodeToComponentSubscriptions.get(key);
      if (subs === void 0 || !subs.has(subID)) {
        Recoil_recoverableViolation(`Subscription missing at release time for atom ${key}. This is a bug in Recoil.`);
        return;
      }
      subs.delete(subID);
      if (subs.size === 0) {
        releaseStoreState.nodeToComponentSubscriptions.delete(key);
      }
    }
  };
}
function refreshRecoilValue(store, recoilValue) {
  var _node$clearCache;
  const {
    currentTree
  } = store.getState();
  const node = getNode$2(recoilValue.key);
  (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, currentTree);
}
var Recoil_RecoilValueInterface = {
  RecoilValueReadOnly: RecoilValueReadOnly$1,
  AbstractRecoilValue: AbstractRecoilValue$1,
  RecoilState: RecoilState$1,
  getRecoilValueAsLoadable,
  setRecoilValue,
  setRecoilValueLoadable,
  markRecoilValueModified,
  setUnvalidatedRecoilValue,
  subscribeToRecoilValue,
  isRecoilValue: isRecoilValue$1,
  applyAtomValueWrites,
  // TODO Remove export when deprecating initialStoreState_DEPRECATED in RecoilRoot
  batchStart,
  writeLoadableToTreeState,
  invalidateDownstreams,
  copyTreeState,
  refreshRecoilValue
};
function someSet(set, callback, context) {
  const iterator = set.entries();
  let current = iterator.next();
  while (!current.done) {
    const entry = current.value;
    if (callback.call(context, entry[1], entry[0], set)) {
      return true;
    }
    current = iterator.next();
  }
  return false;
}
var Recoil_someSet = someSet;
var {
  cleanUpNode: cleanUpNode$1
} = Recoil_FunctionalCore;
var {
  deleteNodeConfigIfPossible: deleteNodeConfigIfPossible$1,
  getNode: getNode$3
} = Recoil_Node;
var {
  RetentionZone: RetentionZone$2
} = Recoil_RetentionZone;
var SUSPENSE_TIMEOUT_MS = 12e4;
var emptySet$1 = /* @__PURE__ */ new Set();
function releaseRetainablesNowOnCurrentTree(store, retainables) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  if (storeState.nextTree) {
    Recoil_recoverableViolation("releaseNodesNowOnCurrentTree should only be called at the end of a batch");
    return;
  }
  const nodes2 = /* @__PURE__ */ new Set();
  for (const r2 of retainables) {
    if (r2 instanceof RetentionZone$2) {
      for (const n2 of nodesRetainedByZone(storeState, r2)) {
        nodes2.add(n2);
      }
    } else {
      nodes2.add(r2);
    }
  }
  const releasableNodes = findReleasableNodes(store, nodes2);
  for (const node of releasableNodes) {
    releaseNode(store, treeState, node);
  }
}
function findReleasableNodes(store, searchFromNodes) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  const graph2 = store.getGraph(treeState.version);
  const releasableNodes = /* @__PURE__ */ new Set();
  const nonReleasableNodes = /* @__PURE__ */ new Set();
  findReleasableNodesInner(searchFromNodes);
  return releasableNodes;
  function findReleasableNodesInner(searchFromNodes2) {
    const releasableNodesFoundThisIteration = /* @__PURE__ */ new Set();
    const downstreams = getDownstreamNodesInTopologicalOrder(
      store,
      treeState,
      searchFromNodes2,
      releasableNodes,
      // don't descend into these
      nonReleasableNodes
      // don't descend into these
    );
    for (const node of downstreams) {
      var _storeState$retention;
      if (getNode$3(node).retainedBy === "recoilRoot") {
        nonReleasableNodes.add(node);
        continue;
      }
      if (((_storeState$retention = storeState.retention.referenceCounts.get(node)) !== null && _storeState$retention !== void 0 ? _storeState$retention : 0) > 0) {
        nonReleasableNodes.add(node);
        continue;
      }
      if (zonesThatCouldRetainNode(node).some((z2) => storeState.retention.referenceCounts.get(z2))) {
        nonReleasableNodes.add(node);
        continue;
      }
      const nodeChildren = graph2.nodeToNodeSubscriptions.get(node);
      if (nodeChildren && Recoil_someSet(nodeChildren, (child) => nonReleasableNodes.has(child))) {
        nonReleasableNodes.add(node);
        continue;
      }
      releasableNodes.add(node);
      releasableNodesFoundThisIteration.add(node);
    }
    const parents = /* @__PURE__ */ new Set();
    for (const node of releasableNodesFoundThisIteration) {
      for (const parent of (_graph$nodeDeps$get = graph2.nodeDeps.get(node)) !== null && _graph$nodeDeps$get !== void 0 ? _graph$nodeDeps$get : emptySet$1) {
        var _graph$nodeDeps$get;
        if (!releasableNodes.has(parent)) {
          parents.add(parent);
        }
      }
    }
    if (parents.size) {
      findReleasableNodesInner(parents);
    }
  }
}
function getDownstreamNodesInTopologicalOrder(store, treeState, nodes2, doNotDescendInto1, doNotDescendInto2) {
  const graph2 = store.getGraph(treeState.version);
  const answer = [];
  const visited = /* @__PURE__ */ new Set();
  while (nodes2.size > 0) {
    visit(Recoil_nullthrows(nodes2.values().next().value));
  }
  return answer;
  function visit(node) {
    if (doNotDescendInto1.has(node) || doNotDescendInto2.has(node)) {
      nodes2.delete(node);
      return;
    }
    if (visited.has(node)) {
      return;
    }
    const children = graph2.nodeToNodeSubscriptions.get(node);
    if (children) {
      for (const child of children) {
        visit(child);
      }
    }
    visited.add(node);
    nodes2.delete(node);
    answer.push(node);
  }
}
function releaseNode(store, treeState, node) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  cleanUpNode$1(store, node);
  const storeState = store.getState();
  storeState.knownAtoms.delete(node);
  storeState.knownSelectors.delete(node);
  storeState.nodeTransactionSubscriptions.delete(node);
  storeState.retention.referenceCounts.delete(node);
  const zones = zonesThatCouldRetainNode(node);
  for (const zone of zones) {
    var _storeState$retention2;
    (_storeState$retention2 = storeState.retention.nodesRetainedByZone.get(zone)) === null || _storeState$retention2 === void 0 ? void 0 : _storeState$retention2.delete(node);
  }
  treeState.atomValues.delete(node);
  treeState.dirtyAtoms.delete(node);
  treeState.nonvalidatedAtoms.delete(node);
  const graph2 = storeState.graphsByVersion.get(treeState.version);
  if (graph2) {
    const deps = graph2.nodeDeps.get(node);
    if (deps !== void 0) {
      graph2.nodeDeps.delete(node);
      for (const dep of deps) {
        var _graph$nodeToNodeSubs;
        (_graph$nodeToNodeSubs = graph2.nodeToNodeSubscriptions.get(dep)) === null || _graph$nodeToNodeSubs === void 0 ? void 0 : _graph$nodeToNodeSubs.delete(node);
      }
    }
    graph2.nodeToNodeSubscriptions.delete(node);
  }
  deleteNodeConfigIfPossible$1(node);
}
function nodesRetainedByZone(storeState, zone) {
  var _storeState$retention3;
  return (_storeState$retention3 = storeState.retention.nodesRetainedByZone.get(zone)) !== null && _storeState$retention3 !== void 0 ? _storeState$retention3 : emptySet$1;
}
function zonesThatCouldRetainNode(node) {
  const retainedBy = getNode$3(node).retainedBy;
  if (retainedBy === void 0 || retainedBy === "components" || retainedBy === "recoilRoot") {
    return [];
  } else if (retainedBy instanceof RetentionZone$2) {
    return [retainedBy];
  } else {
    return retainedBy;
  }
}
function scheduleOrPerformPossibleReleaseOfRetainable(store, retainable) {
  const state = store.getState();
  if (state.nextTree) {
    state.retention.retainablesToCheckForRelease.add(retainable);
  } else {
    releaseRetainablesNowOnCurrentTree(store, /* @__PURE__ */ new Set([retainable]));
  }
}
function updateRetainCount(store, retainable, delta) {
  var _map$get;
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const map = store.getState().retention.referenceCounts;
  const newCount = ((_map$get = map.get(retainable)) !== null && _map$get !== void 0 ? _map$get : 0) + delta;
  if (newCount === 0) {
    updateRetainCountToZero(store, retainable);
  } else {
    map.set(retainable, newCount);
  }
}
function updateRetainCountToZero(store, retainable) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const map = store.getState().retention.referenceCounts;
  map.delete(retainable);
  scheduleOrPerformPossibleReleaseOfRetainable(store, retainable);
}
function releaseScheduledRetainablesNow(store) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  const state = store.getState();
  releaseRetainablesNowOnCurrentTree(store, state.retention.retainablesToCheckForRelease);
  state.retention.retainablesToCheckForRelease.clear();
}
function retainedByOptionWithDefault(r2) {
  return r2 === void 0 ? "recoilRoot" : r2;
}
var Recoil_Retention = {
  SUSPENSE_TIMEOUT_MS,
  updateRetainCount,
  updateRetainCountToZero,
  releaseScheduledRetainablesNow,
  retainedByOptionWithDefault
};
var {
  unstable_batchedUpdates
} = import_react_dom.default;
var ReactBatchedUpdates = {
  unstable_batchedUpdates
};
var {
  unstable_batchedUpdates: unstable_batchedUpdates$1
} = ReactBatchedUpdates;
var Recoil_ReactBatchedUpdates = {
  unstable_batchedUpdates: unstable_batchedUpdates$1
};
var {
  batchStart: batchStart$1
} = Recoil_RecoilValueInterface;
var {
  unstable_batchedUpdates: unstable_batchedUpdates$2
} = Recoil_ReactBatchedUpdates;
var batcher = unstable_batchedUpdates$2 || ((batchFn) => batchFn());
var setBatcher = (newBatcher) => {
  batcher = newBatcher;
};
var getBatcher = () => batcher;
var batchUpdates = (callback) => {
  batcher(() => {
    let batchEnd = () => void 0;
    try {
      batchEnd = batchStart$1();
      callback();
    } finally {
      batchEnd();
    }
  });
};
var Recoil_Batching = {
  getBatcher,
  setBatcher,
  batchUpdates
};
function* concatIterables(iters) {
  for (const iter of iters) {
    for (const val of iter) {
      yield val;
    }
  }
}
var Recoil_concatIterables = concatIterables;
var isSSR = (
  // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709
  typeof Window === "undefined" || typeof window === "undefined"
);
var isWindow = (value) => !isSSR && // $FlowFixMe(site=recoil) Window does not have a FlowType definition https://github.com/facebook/flow/issues/6709
(value === window || value instanceof Window);
var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
var Recoil_Environment = {
  isSSR,
  isReactNative,
  isWindow
};
function memoizeWithArgsHash(fn2, hashFunction) {
  let cache;
  return (...args) => {
    if (!cache) {
      cache = {};
    }
    const key = hashFunction(...args);
    if (!Object.hasOwnProperty.call(cache, key)) {
      cache[key] = fn2(...args);
    }
    return cache[key];
  };
}
function memoizeOneWithArgsHash(fn2, hashFunction) {
  let lastKey;
  let lastResult;
  return (...args) => {
    const key = hashFunction(...args);
    if (lastKey === key) {
      return lastResult;
    }
    lastKey = key;
    lastResult = fn2(...args);
    return lastResult;
  };
}
function memoizeOneWithArgsHashAndInvalidation(fn2, hashFunction) {
  let lastKey;
  let lastResult;
  const memoizedFn = (...args) => {
    const key = hashFunction(...args);
    if (lastKey === key) {
      return lastResult;
    }
    lastKey = key;
    lastResult = fn2(...args);
    return lastResult;
  };
  const invalidate = () => {
    lastKey = null;
  };
  return [memoizedFn, invalidate];
}
var Recoil_Memoize = {
  memoizeWithArgsHash,
  memoizeOneWithArgsHash,
  memoizeOneWithArgsHashAndInvalidation
};
var {
  batchUpdates: batchUpdates$1
} = Recoil_Batching;
var {
  initializeNode: initializeNode$1,
  peekNodeInfo: peekNodeInfo$1
} = Recoil_FunctionalCore;
var {
  graph: graph$1
} = Recoil_Graph;
var {
  getNextStoreID: getNextStoreID$1
} = Recoil_Keys;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$1,
  recoilValues: recoilValues$1,
  recoilValuesForKeys: recoilValuesForKeys$2
} = Recoil_Node;
var {
  AbstractRecoilValue: AbstractRecoilValue$2,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$1,
  setRecoilValue: setRecoilValue$1,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$1
} = Recoil_RecoilValueInterface;
var {
  updateRetainCount: updateRetainCount$1
} = Recoil_Retention;
var {
  setInvalidateMemoizedSnapshot: setInvalidateMemoizedSnapshot$1
} = Recoil_SnapshotCache;
var {
  getNextTreeStateVersion: getNextTreeStateVersion$2,
  makeEmptyStoreState: makeEmptyStoreState$1
} = Recoil_State;
var {
  isSSR: isSSR$1
} = Recoil_Environment;
var {
  memoizeOneWithArgsHashAndInvalidation: memoizeOneWithArgsHashAndInvalidation$1
} = Recoil_Memoize;
var retainWarning = `
Recoil Snapshots only last for the duration of the callback they are provided to. To keep a Snapshot longer, do this:

  const release = snapshot.retain();
  try {
    await doSomethingWithSnapshot(snapshot);
  } finally {
    release();
  }

This is currently a DEV-only warning but will become a thrown exception in the next release of Recoil.
`;
var Snapshot = class {
  // eslint-disable-next-line fb-www/no-uninitialized-properties
  constructor(storeState, parentStoreID) {
    _defineProperty(this, "_store", void 0);
    _defineProperty(this, "_refCount", 1);
    _defineProperty(this, "getLoadable", (recoilValue) => {
      this.checkRefCount_INTERNAL();
      return getRecoilValueAsLoadable$1(this._store, recoilValue);
    });
    _defineProperty(this, "getPromise", (recoilValue) => {
      this.checkRefCount_INTERNAL();
      return this.getLoadable(recoilValue).toPromise();
    });
    _defineProperty(this, "getNodes_UNSTABLE", (opt) => {
      this.checkRefCount_INTERNAL();
      if ((opt === null || opt === void 0 ? void 0 : opt.isModified) === true) {
        if ((opt === null || opt === void 0 ? void 0 : opt.isInitialized) === false) {
          return [];
        }
        const state = this._store.getState().currentTree;
        return recoilValuesForKeys$2(state.dirtyAtoms);
      }
      const knownAtoms = this._store.getState().knownAtoms;
      const knownSelectors = this._store.getState().knownSelectors;
      return (opt === null || opt === void 0 ? void 0 : opt.isInitialized) == null ? recoilValues$1.values() : opt.isInitialized === true ? recoilValuesForKeys$2(Recoil_concatIterables([knownAtoms, knownSelectors])) : Recoil_filterIterable(recoilValues$1.values(), ({
        key
      }) => !knownAtoms.has(key) && !knownSelectors.has(key));
    });
    _defineProperty(this, "getInfo_UNSTABLE", ({
      key
    }) => {
      this.checkRefCount_INTERNAL();
      return peekNodeInfo$1(this._store, this._store.getState().currentTree, key);
    });
    _defineProperty(this, "map", (mapper) => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      mapper(mutableSnapshot);
      return mutableSnapshot;
    });
    _defineProperty(this, "asyncMap", async (mapper) => {
      this.checkRefCount_INTERNAL();
      const mutableSnapshot = new MutableSnapshot(this, batchUpdates$1);
      mutableSnapshot.retain();
      await mapper(mutableSnapshot);
      mutableSnapshot.autoRelease_INTERNAL();
      return mutableSnapshot;
    });
    this._store = {
      storeID: getNextStoreID$1(),
      parentStoreID,
      getState: () => storeState,
      replaceState: (replacer) => {
        storeState.currentTree = replacer(storeState.currentTree);
      },
      getGraph: (version) => {
        const graphs = storeState.graphsByVersion;
        if (graphs.has(version)) {
          return Recoil_nullthrows(graphs.get(version));
        }
        const newGraph = graph$1();
        graphs.set(version, newGraph);
        return newGraph;
      },
      subscribeToTransactions: () => ({
        release: () => {
        }
      }),
      addTransactionMetadata: () => {
        throw Recoil_err("Cannot subscribe to Snapshots");
      }
    };
    for (const nodeKey of this._store.getState().knownAtoms) {
      initializeNode$1(this._store, nodeKey, "get");
      updateRetainCount$1(this._store, nodeKey, 1);
    }
    this.autoRelease_INTERNAL();
  }
  retain() {
    if (this._refCount <= 0) {
      if (true) {
        throw Recoil_err("Snapshot has already been released.");
      } else {
        Recoil_recoverableViolation("Attempt to retain() Snapshot that was already released.");
      }
    }
    this._refCount++;
    let released = false;
    return () => {
      if (!released) {
        released = true;
        this._release();
      }
    };
  }
  /**
   * Release the snapshot on the next tick.  This means the snapshot is retained
   * during the execution of the current function using it.
   */
  autoRelease_INTERNAL() {
    if (!isSSR$1) {
      window.setTimeout(() => this._release(), 10);
    }
  }
  _release() {
    this._refCount--;
    if (this._refCount === 0) {
      this._store.getState().nodeCleanupFunctions.forEach((cleanup) => cleanup());
      this._store.getState().nodeCleanupFunctions.clear();
      if (!Recoil_gkx("recoil_memory_managament_2020")) {
        return;
      }
    } else if (this._refCount < 0) {
      if (true) {
        Recoil_recoverableViolation("Snapshot released an extra time.");
      }
    }
  }
  isRetained() {
    return this._refCount > 0;
  }
  checkRefCount_INTERNAL() {
    if (Recoil_gkx("recoil_memory_managament_2020") && this._refCount <= 0) {
      if (true) {
        Recoil_recoverableViolation(retainWarning);
      }
    }
  }
  getStore_INTERNAL() {
    this.checkRefCount_INTERNAL();
    return this._store;
  }
  getID() {
    this.checkRefCount_INTERNAL();
    return this._store.getState().currentTree.stateID;
  }
  getStoreID() {
    this.checkRefCount_INTERNAL();
    return this._store.storeID;
  }
  // We want to allow the methods to be destructured and used as accessors
  /* eslint-disable fb-www/extra-arrow-initializer */
  /* eslint-enable fb-www/extra-arrow-initializer */
};
function cloneStoreState(store, treeState, bumpVersion = false) {
  const storeState = store.getState();
  const version = bumpVersion ? getNextTreeStateVersion$2() : treeState.version;
  return {
    // Always clone the TreeState to isolate stores from accidental mutations.
    // For example, reading a selector from a cloned snapshot shouldn't cache
    // in the original treestate which may cause the original to skip
    // initialization of upstream atoms.
    currentTree: {
      // TODO snapshots shouldn't really have versions because a new version number
      // is always assigned when the snapshot is gone to.
      version: bumpVersion ? version : treeState.version,
      stateID: bumpVersion ? version : treeState.stateID,
      transactionMetadata: {
        ...treeState.transactionMetadata
      },
      dirtyAtoms: new Set(treeState.dirtyAtoms),
      atomValues: treeState.atomValues.clone(),
      nonvalidatedAtoms: treeState.nonvalidatedAtoms.clone()
    },
    commitDepth: 0,
    nextTree: null,
    previousTree: null,
    knownAtoms: new Set(storeState.knownAtoms),
    // FIXME here's a copy
    knownSelectors: new Set(storeState.knownSelectors),
    // FIXME here's a copy
    transactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeTransactionSubscriptions: /* @__PURE__ */ new Map(),
    nodeToComponentSubscriptions: /* @__PURE__ */ new Map(),
    queuedComponentCallbacks_DEPRECATED: [],
    suspendedComponentResolvers: /* @__PURE__ */ new Set(),
    graphsByVersion: (/* @__PURE__ */ new Map()).set(version, store.getGraph(treeState.version)),
    retention: {
      referenceCounts: /* @__PURE__ */ new Map(),
      nodesRetainedByZone: /* @__PURE__ */ new Map(),
      retainablesToCheckForRelease: /* @__PURE__ */ new Set()
    },
    // FIXME here's a copy
    // Create blank cleanup handlers for atoms so snapshots don't re-run
    // atom effects.
    nodeCleanupFunctions: new Map(Recoil_mapIterable(storeState.nodeCleanupFunctions.entries(), ([key]) => [key, () => {
    }]))
  };
}
function freshSnapshot(initializeState) {
  const snapshot = new Snapshot(makeEmptyStoreState$1());
  return initializeState != null ? snapshot.map(initializeState) : snapshot;
}
var [memoizedCloneSnapshot, invalidateMemoizedSnapshot$2] = memoizeOneWithArgsHashAndInvalidation$1(
  // $FlowFixMe[missing-local-annot]
  (store, version) => {
    var _storeState$nextTree;
    const storeState = store.getState();
    const treeState = version === "latest" ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : Recoil_nullthrows(storeState.previousTree);
    return new Snapshot(cloneStoreState(store, treeState), store.storeID);
  },
  (store, version) => {
    var _store$getState$nextT, _store$getState$previ;
    return String(version) + String(store.storeID) + String((_store$getState$nextT = store.getState().nextTree) === null || _store$getState$nextT === void 0 ? void 0 : _store$getState$nextT.version) + String(store.getState().currentTree.version) + String((_store$getState$previ = store.getState().previousTree) === null || _store$getState$previ === void 0 ? void 0 : _store$getState$previ.version);
  }
);
setInvalidateMemoizedSnapshot$1(invalidateMemoizedSnapshot$2);
function cloneSnapshot(store, version = "latest") {
  const snapshot = memoizedCloneSnapshot(store, version);
  if (!snapshot.isRetained()) {
    invalidateMemoizedSnapshot$2();
    return memoizedCloneSnapshot(store, version);
  }
  return snapshot;
}
var MutableSnapshot = class extends Snapshot {
  constructor(snapshot, batch) {
    super(cloneStoreState(snapshot.getStore_INTERNAL(), snapshot.getStore_INTERNAL().getState().currentTree, true), snapshot.getStoreID());
    _defineProperty(this, "_batch", void 0);
    _defineProperty(this, "set", (recoilState, newValueOrUpdater) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, newValueOrUpdater);
      });
    });
    _defineProperty(this, "reset", (recoilState) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      this._batch(() => {
        updateRetainCount$1(store, recoilState.key, 1);
        setRecoilValue$1(this.getStore_INTERNAL(), recoilState, DEFAULT_VALUE$1);
      });
    });
    _defineProperty(this, "setUnvalidatedAtomValues_DEPRECATED", (values) => {
      this.checkRefCount_INTERNAL();
      const store = this.getStore_INTERNAL();
      batchUpdates$1(() => {
        for (const [k2, v2] of values.entries()) {
          updateRetainCount$1(store, k2, 1);
          setUnvalidatedRecoilValue$1(store, new AbstractRecoilValue$2(k2), v2);
        }
      });
    });
    this._batch = batch;
  }
};
var Recoil_Snapshot = {
  Snapshot,
  MutableSnapshot,
  freshSnapshot,
  cloneSnapshot
};
var Recoil_Snapshot_1 = Recoil_Snapshot.Snapshot;
var Recoil_Snapshot_2 = Recoil_Snapshot.MutableSnapshot;
var Recoil_Snapshot_3 = Recoil_Snapshot.freshSnapshot;
var Recoil_Snapshot_4 = Recoil_Snapshot.cloneSnapshot;
var Recoil_Snapshot$1 = Object.freeze({
  __proto__: null,
  Snapshot: Recoil_Snapshot_1,
  MutableSnapshot: Recoil_Snapshot_2,
  freshSnapshot: Recoil_Snapshot_3,
  cloneSnapshot: Recoil_Snapshot_4
});
function unionSets(...sets) {
  const result = /* @__PURE__ */ new Set();
  for (const set of sets) {
    for (const value of set) {
      result.add(value);
    }
  }
  return result;
}
var Recoil_unionSets = unionSets;
var {
  useRef
} = import_react.default;
function useRefInitOnce(initialValue) {
  const ref = useRef(initialValue);
  if (ref.current === initialValue && typeof initialValue === "function") {
    ref.current = initialValue();
  }
  return ref;
}
var Recoil_useRefInitOnce = useRefInitOnce;
var {
  getNextTreeStateVersion: getNextTreeStateVersion$3,
  makeEmptyStoreState: makeEmptyStoreState$2
} = Recoil_State;
var {
  cleanUpNode: cleanUpNode$2,
  getDownstreamNodes: getDownstreamNodes$2,
  initializeNode: initializeNode$2,
  setNodeValue: setNodeValue$2,
  setUnvalidatedAtomValue_DEPRECATED: setUnvalidatedAtomValue_DEPRECATED$1
} = Recoil_FunctionalCore;
var {
  graph: graph$2
} = Recoil_Graph;
var {
  cloneGraph: cloneGraph$1
} = Recoil_Graph;
var {
  getNextStoreID: getNextStoreID$2
} = Recoil_Keys;
var {
  createMutableSource: createMutableSource$1,
  reactMode: reactMode$2
} = Recoil_ReactMode;
var {
  applyAtomValueWrites: applyAtomValueWrites$1
} = Recoil_RecoilValueInterface;
var {
  releaseScheduledRetainablesNow: releaseScheduledRetainablesNow$1
} = Recoil_Retention;
var {
  freshSnapshot: freshSnapshot$1
} = Recoil_Snapshot$1;
var {
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useRef: useRef$1,
  useState
} = import_react.default;
function notInAContext() {
  throw Recoil_err("This component must be used inside a <RecoilRoot> component.");
}
var defaultStore = Object.freeze({
  storeID: getNextStoreID$2(),
  getState: notInAContext,
  replaceState: notInAContext,
  getGraph: notInAContext,
  subscribeToTransactions: notInAContext,
  addTransactionMetadata: notInAContext
});
var stateReplacerIsBeingExecuted = false;
function startNextTreeIfNeeded(store) {
  if (stateReplacerIsBeingExecuted) {
    throw Recoil_err("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");
  }
  const storeState = store.getState();
  if (storeState.nextTree === null) {
    if (Recoil_gkx("recoil_memory_managament_2020") && Recoil_gkx("recoil_release_on_cascading_update_killswitch_2021")) {
      if (storeState.commitDepth > 0) {
        releaseScheduledRetainablesNow$1(store);
      }
    }
    const version = storeState.currentTree.version;
    const nextVersion = getNextTreeStateVersion$3();
    storeState.nextTree = {
      ...storeState.currentTree,
      version: nextVersion,
      stateID: nextVersion,
      dirtyAtoms: /* @__PURE__ */ new Set(),
      transactionMetadata: {}
    };
    storeState.graphsByVersion.set(nextVersion, cloneGraph$1(Recoil_nullthrows(storeState.graphsByVersion.get(version))));
  }
}
var AppContext = import_react.default.createContext({
  current: defaultStore
});
var useStoreRef = () => useContext(AppContext);
var MutableSourceContext = import_react.default.createContext(null);
function useRecoilMutableSource() {
  const mutableSource = useContext(MutableSourceContext);
  if (mutableSource == null) {
    Recoil_expectationViolation("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks.");
  }
  return mutableSource;
}
function notifyComponents(store, storeState, treeState) {
  const dependentNodes = getDownstreamNodes$2(store, treeState, treeState.dirtyAtoms);
  for (const key of dependentNodes) {
    const comps = storeState.nodeToComponentSubscriptions.get(key);
    if (comps) {
      for (const [_subID, [_debugName, callback]] of comps) {
        callback(treeState);
      }
    }
  }
}
function sendEndOfBatchNotifications(store) {
  const storeState = store.getState();
  const treeState = storeState.currentTree;
  const dirtyAtoms = treeState.dirtyAtoms;
  if (dirtyAtoms.size) {
    for (const [key, subscriptions] of storeState.nodeTransactionSubscriptions) {
      if (dirtyAtoms.has(key)) {
        for (const [_2, subscription] of subscriptions) {
          subscription(store);
        }
      }
    }
    for (const [_2, subscription] of storeState.transactionSubscriptions) {
      subscription(store);
    }
    if (!reactMode$2().early || storeState.suspendedComponentResolvers.size > 0) {
      notifyComponents(store, storeState, treeState);
      storeState.suspendedComponentResolvers.forEach((cb) => cb());
      storeState.suspendedComponentResolvers.clear();
    }
  }
  storeState.queuedComponentCallbacks_DEPRECATED.forEach((cb) => cb(treeState));
  storeState.queuedComponentCallbacks_DEPRECATED.splice(0, storeState.queuedComponentCallbacks_DEPRECATED.length);
}
function endBatch(store) {
  const storeState = store.getState();
  storeState.commitDepth++;
  try {
    const {
      nextTree
    } = storeState;
    if (nextTree == null) {
      return;
    }
    storeState.previousTree = storeState.currentTree;
    storeState.currentTree = nextTree;
    storeState.nextTree = null;
    sendEndOfBatchNotifications(store);
    if (storeState.previousTree != null) {
      storeState.graphsByVersion.delete(storeState.previousTree.version);
    } else {
      Recoil_recoverableViolation("Ended batch with no previous state, which is unexpected", "recoil");
    }
    storeState.previousTree = null;
    if (Recoil_gkx("recoil_memory_managament_2020")) {
      if (nextTree == null) {
        releaseScheduledRetainablesNow$1(store);
      }
    }
  } finally {
    storeState.commitDepth--;
  }
}
function Batcher({
  setNotifyBatcherOfChange
}) {
  const storeRef = useStoreRef();
  const [, setState] = useState([]);
  setNotifyBatcherOfChange(() => setState({}));
  useEffect(() => {
    setNotifyBatcherOfChange(() => setState({}));
    return () => {
      setNotifyBatcherOfChange(() => {
      });
    };
  }, [setNotifyBatcherOfChange]);
  useEffect(() => {
    Recoil_Queue.enqueueExecution("Batcher", () => {
      endBatch(storeRef.current);
    });
  });
  return null;
}
if (true) {
  if (typeof window !== "undefined" && !window.$recoilDebugStates) {
    window.$recoilDebugStates = [];
  }
}
function initialStoreState_DEPRECATED(store, initializeState) {
  const initial = makeEmptyStoreState$2();
  initializeState({
    set: (atom2, value) => {
      const state = initial.currentTree;
      const writes = setNodeValue$2(store, state, atom2.key, value);
      const writtenNodes = new Set(writes.keys());
      const nonvalidatedAtoms = state.nonvalidatedAtoms.clone();
      for (const n2 of writtenNodes) {
        nonvalidatedAtoms.delete(n2);
      }
      initial.currentTree = {
        ...state,
        dirtyAtoms: Recoil_unionSets(state.dirtyAtoms, writtenNodes),
        atomValues: applyAtomValueWrites$1(state.atomValues, writes),
        // NB: PLEASE un-export applyAtomValueWrites when deleting this code
        nonvalidatedAtoms
      };
    },
    setUnvalidatedAtomValues: (atomValues) => {
      atomValues.forEach((v2, k2) => {
        initial.currentTree = setUnvalidatedAtomValue_DEPRECATED$1(initial.currentTree, k2, v2);
      });
    }
  });
  return initial;
}
function initialStoreState(initializeState) {
  const snapshot = freshSnapshot$1(initializeState);
  const storeState = snapshot.getStore_INTERNAL().getState();
  snapshot.retain();
  storeState.nodeCleanupFunctions.forEach((cleanup) => cleanup());
  storeState.nodeCleanupFunctions.clear();
  return storeState;
}
var nextID = 0;
function RecoilRoot_INTERNAL({
  initializeState_DEPRECATED,
  initializeState,
  store_INTERNAL: storeProp,
  // For use with React "context bridging"
  children
}) {
  let storeStateRef;
  const getGraph = (version) => {
    const graphs = storeStateRef.current.graphsByVersion;
    if (graphs.has(version)) {
      return Recoil_nullthrows(graphs.get(version));
    }
    const newGraph = graph$2();
    graphs.set(version, newGraph);
    return newGraph;
  };
  const subscribeToTransactions = (callback, key) => {
    if (key == null) {
      const {
        transactionSubscriptions
      } = storeRef.current.getState();
      const id = nextID++;
      transactionSubscriptions.set(id, callback);
      return {
        release: () => {
          transactionSubscriptions.delete(id);
        }
      };
    } else {
      const {
        nodeTransactionSubscriptions
      } = storeRef.current.getState();
      if (!nodeTransactionSubscriptions.has(key)) {
        nodeTransactionSubscriptions.set(key, /* @__PURE__ */ new Map());
      }
      const id = nextID++;
      Recoil_nullthrows(nodeTransactionSubscriptions.get(key)).set(id, callback);
      return {
        release: () => {
          const subs = nodeTransactionSubscriptions.get(key);
          if (subs) {
            subs.delete(id);
            if (subs.size === 0) {
              nodeTransactionSubscriptions.delete(key);
            }
          }
        }
      };
    }
  };
  const addTransactionMetadata = (metadata) => {
    startNextTreeIfNeeded(storeRef.current);
    for (const k2 of Object.keys(metadata)) {
      Recoil_nullthrows(storeRef.current.getState().nextTree).transactionMetadata[k2] = metadata[k2];
    }
  };
  const replaceState = (replacer) => {
    startNextTreeIfNeeded(storeRef.current);
    const nextTree = Recoil_nullthrows(storeStateRef.current.nextTree);
    let replaced;
    try {
      stateReplacerIsBeingExecuted = true;
      replaced = replacer(nextTree);
    } finally {
      stateReplacerIsBeingExecuted = false;
    }
    if (replaced === nextTree) {
      return;
    }
    if (true) {
      if (typeof window !== "undefined") {
        window.$recoilDebugStates.push(replaced);
      }
    }
    storeStateRef.current.nextTree = replaced;
    if (reactMode$2().early) {
      notifyComponents(storeRef.current, storeStateRef.current, replaced);
    }
    Recoil_nullthrows(notifyBatcherOfChange.current)();
  };
  const notifyBatcherOfChange = useRef$1(null);
  const setNotifyBatcherOfChange = useCallback((x2) => {
    notifyBatcherOfChange.current = x2;
  }, [notifyBatcherOfChange]);
  const storeRef = Recoil_useRefInitOnce(() => storeProp !== null && storeProp !== void 0 ? storeProp : {
    storeID: getNextStoreID$2(),
    getState: () => storeStateRef.current,
    replaceState,
    getGraph,
    subscribeToTransactions,
    addTransactionMetadata
  });
  if (storeProp != null) {
    storeRef.current = storeProp;
  }
  storeStateRef = Recoil_useRefInitOnce(() => initializeState_DEPRECATED != null ? initialStoreState_DEPRECATED(storeRef.current, initializeState_DEPRECATED) : initializeState != null ? initialStoreState(initializeState) : makeEmptyStoreState$2());
  const mutableSource = useMemo(() => createMutableSource$1 === null || createMutableSource$1 === void 0 ? void 0 : createMutableSource$1(storeStateRef, () => storeStateRef.current.currentTree.version), [storeStateRef]);
  useEffect(() => {
    const store = storeRef.current;
    for (const atomKey of new Set(store.getState().knownAtoms)) {
      initializeNode$2(store, atomKey, "get");
    }
    return () => {
      for (const atomKey of store.getState().knownAtoms) {
        cleanUpNode$2(store, atomKey);
      }
    };
  }, [storeRef]);
  return import_react.default.createElement(AppContext.Provider, {
    value: storeRef
  }, import_react.default.createElement(MutableSourceContext.Provider, {
    value: mutableSource
  }, import_react.default.createElement(Batcher, {
    setNotifyBatcherOfChange
  }), children));
}
function RecoilRoot(props) {
  const {
    override,
    ...propsExceptOverride
  } = props;
  const ancestorStoreRef = useStoreRef();
  if (override === false && ancestorStoreRef.current !== defaultStore) {
    return props.children;
  }
  return import_react.default.createElement(RecoilRoot_INTERNAL, propsExceptOverride);
}
function useRecoilStoreID() {
  return useStoreRef().current.storeID;
}
var Recoil_RecoilRoot = {
  RecoilRoot,
  useStoreRef,
  useRecoilMutableSource,
  useRecoilStoreID,
  notifyComponents_FOR_TESTING: notifyComponents,
  sendEndOfBatchNotifications_FOR_TESTING: sendEndOfBatchNotifications
};
function shallowArrayEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2.length !== b2.length) {
    return false;
  }
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
var Recoil_shallowArrayEqual = shallowArrayEqual;
var {
  useEffect: useEffect$1,
  useRef: useRef$2
} = import_react.default;
function usePrevious(value) {
  const ref = useRef$2();
  useEffect$1(() => {
    ref.current = value;
  });
  return ref.current;
}
var Recoil_usePrevious = usePrevious;
var {
  useStoreRef: useStoreRef$1
} = Recoil_RecoilRoot;
var {
  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$1
} = Recoil_Retention;
var {
  updateRetainCount: updateRetainCount$2
} = Recoil_Retention;
var {
  RetentionZone: RetentionZone$3
} = Recoil_RetentionZone;
var {
  useEffect: useEffect$2,
  useRef: useRef$3
} = import_react.default;
var {
  isSSR: isSSR$2
} = Recoil_Environment;
function useRetain(toRetain) {
  if (!Recoil_gkx("recoil_memory_managament_2020")) {
    return;
  }
  return useRetain_ACTUAL(toRetain);
}
function useRetain_ACTUAL(toRetain) {
  const array = Array.isArray(toRetain) ? toRetain : [toRetain];
  const retainables = array.map((a2) => a2 instanceof RetentionZone$3 ? a2 : a2.key);
  const storeRef = useStoreRef$1();
  useEffect$2(() => {
    if (!Recoil_gkx("recoil_memory_managament_2020")) {
      return;
    }
    const store = storeRef.current;
    if (timeoutID.current && !isSSR$2) {
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
    } else {
      for (const r2 of retainables) {
        updateRetainCount$2(store, r2, 1);
      }
    }
    return () => {
      for (const r2 of retainables) {
        updateRetainCount$2(store, r2, -1);
      }
    };
  }, [storeRef, ...retainables]);
  const timeoutID = useRef$3();
  const previousRetainables = Recoil_usePrevious(retainables);
  if (!isSSR$2 && (previousRetainables === void 0 || !Recoil_shallowArrayEqual(previousRetainables, retainables))) {
    const store = storeRef.current;
    for (const r2 of retainables) {
      updateRetainCount$2(store, r2, 1);
    }
    if (previousRetainables) {
      for (const r2 of previousRetainables) {
        updateRetainCount$2(store, r2, -1);
      }
    }
    if (timeoutID.current) {
      window.clearTimeout(timeoutID.current);
    }
    timeoutID.current = window.setTimeout(() => {
      timeoutID.current = null;
      for (const r2 of retainables) {
        updateRetainCount$2(store, r2, -1);
      }
    }, SUSPENSE_TIMEOUT_MS$1);
  }
}
var Recoil_useRetain = useRetain;
function useComponentName() {
  return "<component name not available>";
}
var Recoil_useComponentName = useComponentName;
var {
  batchUpdates: batchUpdates$2
} = Recoil_Batching;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$2
} = Recoil_Node;
var {
  currentRendererSupportsUseSyncExternalStore: currentRendererSupportsUseSyncExternalStore$1,
  reactMode: reactMode$3,
  useMutableSource: useMutableSource$1,
  useSyncExternalStore: useSyncExternalStore$1
} = Recoil_ReactMode;
var {
  useRecoilMutableSource: useRecoilMutableSource$1,
  useStoreRef: useStoreRef$2
} = Recoil_RecoilRoot;
var {
  isRecoilValue: isRecoilValue$2
} = Recoil_RecoilValue$1;
var {
  AbstractRecoilValue: AbstractRecoilValue$3,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$2,
  setRecoilValue: setRecoilValue$2,
  setUnvalidatedRecoilValue: setUnvalidatedRecoilValue$2,
  subscribeToRecoilValue: subscribeToRecoilValue$1
} = Recoil_RecoilValueInterface;
var {
  useCallback: useCallback$1,
  useEffect: useEffect$3,
  useMemo: useMemo$1,
  useRef: useRef$4,
  useState: useState$1
} = import_react.default;
var {
  setByAddingToSet: setByAddingToSet$2
} = Recoil_CopyOnWrite;
var {
  isSSR: isSSR$3
} = Recoil_Environment;
function handleLoadable(loadable, recoilValue, storeRef) {
  if (loadable.state === "hasValue") {
    return loadable.contents;
  } else if (loadable.state === "loading") {
    const promise = new Promise((resolve) => {
      const suspendedComponentResolvers = storeRef.current.getState().suspendedComponentResolvers;
      suspendedComponentResolvers.add(resolve);
      if (isSSR$3 && Recoil_isPromise(loadable.contents)) {
        loadable.contents.finally(() => {
          suspendedComponentResolvers.delete(resolve);
        });
      }
    });
    throw promise;
  } else if (loadable.state === "hasError") {
    throw loadable.contents;
  } else {
    throw Recoil_err(`Invalid value of loadable atom "${recoilValue.key}"`);
  }
}
function validateRecoilValue(recoilValue, hookName) {
  if (!isRecoilValue$2(recoilValue)) {
    throw Recoil_err(`Invalid argument to ${hookName}: expected an atom or selector but got ${String(recoilValue)}`);
  }
}
function useRecoilInterface_DEPRECATED() {
  const componentName = Recoil_useComponentName();
  const storeRef = useStoreRef$2();
  const [, forceUpdate] = useState$1([]);
  const recoilValuesUsed = useRef$4(/* @__PURE__ */ new Set());
  recoilValuesUsed.current = /* @__PURE__ */ new Set();
  const previousSubscriptions = useRef$4(/* @__PURE__ */ new Set());
  const subscriptions = useRef$4(/* @__PURE__ */ new Map());
  const unsubscribeFrom = useCallback$1((key) => {
    const sub = subscriptions.current.get(key);
    if (sub) {
      sub.release();
      subscriptions.current.delete(key);
    }
  }, [subscriptions]);
  const updateState = useCallback$1((_state, key) => {
    if (subscriptions.current.has(key)) {
      forceUpdate([]);
    }
  }, []);
  useEffect$3(() => {
    const store = storeRef.current;
    Recoil_differenceSets(recoilValuesUsed.current, previousSubscriptions.current).forEach((key) => {
      if (subscriptions.current.has(key)) {
        Recoil_expectationViolation(`Double subscription to RecoilValue "${key}"`);
        return;
      }
      const sub = subscribeToRecoilValue$1(store, new AbstractRecoilValue$3(key), (state2) => updateState(state2, key), componentName);
      subscriptions.current.set(key, sub);
      const state = store.getState();
      if (state.nextTree) {
        store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
          updateState(store.getState(), key);
        });
      } else {
        updateState(store.getState(), key);
      }
    });
    Recoil_differenceSets(previousSubscriptions.current, recoilValuesUsed.current).forEach((key) => {
      unsubscribeFrom(key);
    });
    previousSubscriptions.current = recoilValuesUsed.current;
  });
  useEffect$3(() => {
    const currentSubscriptions = subscriptions.current;
    Recoil_differenceSets(recoilValuesUsed.current, new Set(currentSubscriptions.keys())).forEach((key) => {
      const sub = subscribeToRecoilValue$1(storeRef.current, new AbstractRecoilValue$3(key), (state) => updateState(state, key), componentName);
      currentSubscriptions.set(key, sub);
    });
    return () => currentSubscriptions.forEach((_2, key) => unsubscribeFrom(key));
  }, [componentName, storeRef, unsubscribeFrom, updateState]);
  return useMemo$1(() => {
    function useSetRecoilState2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useSetRecoilState");
      }
      return (newValueOrUpdater) => {
        setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
      };
    }
    function useResetRecoilState2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useResetRecoilState");
      }
      return () => setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);
    }
    function useRecoilValueLoadable2(recoilValue) {
      var _storeState$nextTree;
      if (true) {
        validateRecoilValue(recoilValue, "useRecoilValueLoadable");
      }
      if (!recoilValuesUsed.current.has(recoilValue.key)) {
        recoilValuesUsed.current = setByAddingToSet$2(recoilValuesUsed.current, recoilValue.key);
      }
      const storeState = storeRef.current.getState();
      return getRecoilValueAsLoadable$2(storeRef.current, recoilValue, reactMode$3().early ? (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree : storeState.currentTree);
    }
    function useRecoilValue2(recoilValue) {
      if (true) {
        validateRecoilValue(recoilValue, "useRecoilValue");
      }
      const loadable = useRecoilValueLoadable2(recoilValue);
      return handleLoadable(loadable, recoilValue, storeRef);
    }
    function useRecoilState2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useRecoilState");
      }
      return [useRecoilValue2(recoilState), useSetRecoilState2(recoilState)];
    }
    function useRecoilStateLoadable2(recoilState) {
      if (true) {
        validateRecoilValue(recoilState, "useRecoilStateLoadable");
      }
      return [useRecoilValueLoadable2(recoilState), useSetRecoilState2(recoilState)];
    }
    return {
      getRecoilValue: useRecoilValue2,
      getRecoilValueLoadable: useRecoilValueLoadable2,
      getRecoilState: useRecoilState2,
      getRecoilStateLoadable: useRecoilStateLoadable2,
      getSetRecoilState: useSetRecoilState2,
      getResetRecoilState: useResetRecoilState2
    };
  }, [recoilValuesUsed, storeRef]);
}
var recoilComponentGetRecoilValueCount_FOR_TESTING = {
  current: 0
};
function useRecoilValueLoadable_SYNC_EXTERNAL_STORE(recoilValue) {
  const storeRef = useStoreRef$2();
  const componentName = Recoil_useComponentName();
  const getSnapshot = useCallback$1(() => {
    var _storeState$nextTree2;
    if (true) {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree2 = storeState.nextTree) !== null && _storeState$nextTree2 !== void 0 ? _storeState$nextTree2 : storeState.currentTree : storeState.currentTree;
    const loadable = getRecoilValueAsLoadable$2(store, recoilValue, treeState);
    return {
      loadable,
      key: recoilValue.key
    };
  }, [storeRef, recoilValue]);
  const memoizePreviousSnapshot = useCallback$1((getState) => {
    let prevState;
    return () => {
      var _prevState, _prevState2;
      const nextState = getState();
      if ((_prevState = prevState) !== null && _prevState !== void 0 && _prevState.loadable.is(nextState.loadable) && ((_prevState2 = prevState) === null || _prevState2 === void 0 ? void 0 : _prevState2.key) === nextState.key) {
        return prevState;
      }
      prevState = nextState;
      return nextState;
    };
  }, []);
  const getMemoizedSnapshot = useMemo$1(() => memoizePreviousSnapshot(getSnapshot), [getSnapshot, memoizePreviousSnapshot]);
  const subscribe = useCallback$1((notify) => {
    const store = storeRef.current;
    const subscription = subscribeToRecoilValue$1(store, recoilValue, notify, componentName);
    return subscription.release;
  }, [storeRef, recoilValue, componentName]);
  return useSyncExternalStore$1(
    subscribe,
    getMemoizedSnapshot,
    // getSnapshot()
    getMemoizedSnapshot
    // getServerSnapshot() for SSR support
  ).loadable;
}
function useRecoilValueLoadable_MUTABLE_SOURCE(recoilValue) {
  const storeRef = useStoreRef$2();
  const getLoadable = useCallback$1(() => {
    var _storeState$nextTree3;
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree3 = storeState.nextTree) !== null && _storeState$nextTree3 !== void 0 ? _storeState$nextTree3 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const getLoadableWithTesting = useCallback$1(() => {
    if (true) {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }
    return getLoadable();
  }, [getLoadable]);
  const componentName = Recoil_useComponentName();
  const subscribe = useCallback$1((_storeState, notify) => {
    const store = storeRef.current;
    const subscription = subscribeToRecoilValue$1(store, recoilValue, () => {
      if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
        return notify();
      }
      const newLoadable = getLoadable();
      if (!prevLoadableRef.current.is(newLoadable)) {
        notify();
      }
      prevLoadableRef.current = newLoadable;
    }, componentName);
    return subscription.release;
  }, [storeRef, recoilValue, componentName, getLoadable]);
  const source = useRecoilMutableSource$1();
  if (source == null) {
    throw Recoil_err("Recoil hooks must be used in components contained within a <RecoilRoot> component.");
  }
  const loadable = useMutableSource$1(source, getLoadableWithTesting, subscribe);
  const prevLoadableRef = useRef$4(loadable);
  useEffect$3(() => {
    prevLoadableRef.current = loadable;
  });
  return loadable;
}
function useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue) {
  const storeRef = useStoreRef$2();
  const componentName = Recoil_useComponentName();
  const getLoadable = useCallback$1(() => {
    var _storeState$nextTree4;
    if (true) {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree4 = storeState.nextTree) !== null && _storeState$nextTree4 !== void 0 ? _storeState$nextTree4 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const getState = useCallback$1(() => ({
    loadable: getLoadable(),
    key: recoilValue.key
  }), [getLoadable, recoilValue.key]);
  const updateState = useCallback$1((prevState) => {
    const nextState = getState();
    return prevState.loadable.is(nextState.loadable) && prevState.key === nextState.key ? prevState : nextState;
  }, [getState]);
  useEffect$3(() => {
    const subscription = subscribeToRecoilValue$1(storeRef.current, recoilValue, (_state) => {
      setState(updateState);
    }, componentName);
    setState(updateState);
    return subscription.release;
  }, [componentName, recoilValue, storeRef, updateState]);
  const [state, setState] = useState$1(getState);
  return state.key !== recoilValue.key ? getState().loadable : state.loadable;
}
function useRecoilValueLoadable_LEGACY(recoilValue) {
  const storeRef = useStoreRef$2();
  const [, forceUpdate] = useState$1([]);
  const componentName = Recoil_useComponentName();
  const getLoadable = useCallback$1(() => {
    var _storeState$nextTree5;
    if (true) {
      recoilComponentGetRecoilValueCount_FOR_TESTING.current++;
    }
    const store = storeRef.current;
    const storeState = store.getState();
    const treeState = reactMode$3().early ? (_storeState$nextTree5 = storeState.nextTree) !== null && _storeState$nextTree5 !== void 0 ? _storeState$nextTree5 : storeState.currentTree : storeState.currentTree;
    return getRecoilValueAsLoadable$2(store, recoilValue, treeState);
  }, [storeRef, recoilValue]);
  const loadable = getLoadable();
  const prevLoadableRef = useRef$4(loadable);
  useEffect$3(() => {
    prevLoadableRef.current = loadable;
  });
  useEffect$3(() => {
    const store = storeRef.current;
    const storeState = store.getState();
    const subscription = subscribeToRecoilValue$1(store, recoilValue, (_state) => {
      var _prevLoadableRef$curr;
      if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
        return forceUpdate([]);
      }
      const newLoadable = getLoadable();
      if (!((_prevLoadableRef$curr = prevLoadableRef.current) !== null && _prevLoadableRef$curr !== void 0 && _prevLoadableRef$curr.is(newLoadable))) {
        forceUpdate(newLoadable);
      }
      prevLoadableRef.current = newLoadable;
    }, componentName);
    if (storeState.nextTree) {
      store.getState().queuedComponentCallbacks_DEPRECATED.push(() => {
        prevLoadableRef.current = null;
        forceUpdate([]);
      });
    } else {
      var _prevLoadableRef$curr2;
      if (!Recoil_gkx("recoil_suppress_rerender_in_callback")) {
        return forceUpdate([]);
      }
      const newLoadable = getLoadable();
      if (!((_prevLoadableRef$curr2 = prevLoadableRef.current) !== null && _prevLoadableRef$curr2 !== void 0 && _prevLoadableRef$curr2.is(newLoadable))) {
        forceUpdate(newLoadable);
      }
      prevLoadableRef.current = newLoadable;
    }
    return subscription.release;
  }, [componentName, getLoadable, recoilValue, storeRef]);
  return loadable;
}
function useRecoilValueLoadable(recoilValue) {
  if (true) {
    validateRecoilValue(recoilValue, "useRecoilValueLoadable");
  }
  if (Recoil_gkx("recoil_memory_managament_2020")) {
    Recoil_useRetain(recoilValue);
  }
  return {
    TRANSITION_SUPPORT: useRecoilValueLoadable_TRANSITION_SUPPORT,
    // Recoil will attemp to detect if `useSyncExternalStore()` is supported with
    // `reactMode()` before calling it.  However, sometimes the host React
    // environment supports it but uses additional React renderers (such as with
    // `react-three-fiber`) which do not.  While this is technically a user issue
    // by using a renderer with React 18+ that doesn't fully support React 18 we
    // don't want to break users if it can be avoided. As the current renderer can
    // change at runtime, we need to dynamically check and fallback if necessary.
    SYNC_EXTERNAL_STORE: currentRendererSupportsUseSyncExternalStore$1() ? useRecoilValueLoadable_SYNC_EXTERNAL_STORE : useRecoilValueLoadable_TRANSITION_SUPPORT,
    MUTABLE_SOURCE: useRecoilValueLoadable_MUTABLE_SOURCE,
    LEGACY: useRecoilValueLoadable_LEGACY
  }[reactMode$3().mode](recoilValue);
}
function useRecoilValue(recoilValue) {
  if (true) {
    validateRecoilValue(recoilValue, "useRecoilValue");
  }
  const storeRef = useStoreRef$2();
  const loadable = useRecoilValueLoadable(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}
function useSetRecoilState(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useSetRecoilState");
  }
  const storeRef = useStoreRef$2();
  return useCallback$1((newValueOrUpdater) => {
    setRecoilValue$2(storeRef.current, recoilState, newValueOrUpdater);
  }, [storeRef, recoilState]);
}
function useResetRecoilState(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useResetRecoilState");
  }
  const storeRef = useStoreRef$2();
  return useCallback$1(() => {
    setRecoilValue$2(storeRef.current, recoilState, DEFAULT_VALUE$2);
  }, [storeRef, recoilState]);
}
function useRecoilState(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useRecoilState");
  }
  return [useRecoilValue(recoilState), useSetRecoilState(recoilState)];
}
function useRecoilStateLoadable(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useRecoilStateLoadable");
  }
  return [useRecoilValueLoadable(recoilState), useSetRecoilState(recoilState)];
}
function useSetUnvalidatedAtomValues() {
  const storeRef = useStoreRef$2();
  return (values, transactionMetadata = {}) => {
    batchUpdates$2(() => {
      storeRef.current.addTransactionMetadata(transactionMetadata);
      values.forEach((value, key) => setUnvalidatedRecoilValue$2(storeRef.current, new AbstractRecoilValue$3(key), value));
    });
  };
}
function useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {
  if (true) {
    validateRecoilValue(recoilValue, "useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE");
    if (!reactMode$3().early) {
      Recoil_recoverableViolation("Attepmt to use a hook with UNSTABLE_TRANSITION_SUPPORT in a rendering mode incompatible with concurrent rendering.  Try enabling the recoil_sync_external_store or recoil_transition_support GKs.");
    }
  }
  if (Recoil_gkx("recoil_memory_managament_2020")) {
    Recoil_useRetain(recoilValue);
  }
  return useRecoilValueLoadable_TRANSITION_SUPPORT(recoilValue);
}
function useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilValue) {
  if (true) {
    validateRecoilValue(recoilValue, "useRecoilValue_TRANSITION_SUPPORT_UNSTABLE");
  }
  const storeRef = useStoreRef$2();
  const loadable = useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE(recoilValue);
  return handleLoadable(loadable, recoilValue, storeRef);
}
function useRecoilState_TRANSITION_SUPPORT_UNSTABLE(recoilState) {
  if (true) {
    validateRecoilValue(recoilState, "useRecoilState_TRANSITION_SUPPORT_UNSTABLE");
  }
  return [useRecoilValue_TRANSITION_SUPPORT_UNSTABLE(recoilState), useSetRecoilState(recoilState)];
}
var Recoil_Hooks = {
  recoilComponentGetRecoilValueCount_FOR_TESTING,
  useRecoilInterface: useRecoilInterface_DEPRECATED,
  useRecoilState,
  useRecoilStateLoadable,
  useRecoilValue,
  useRecoilValueLoadable,
  useResetRecoilState,
  useSetRecoilState,
  useSetUnvalidatedAtomValues,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE
};
function filterMap(map, callback) {
  const result = /* @__PURE__ */ new Map();
  for (const [key, value] of map) {
    if (callback(value, key)) {
      result.set(key, value);
    }
  }
  return result;
}
var Recoil_filterMap = filterMap;
function filterSet(set, callback) {
  const result = /* @__PURE__ */ new Set();
  for (const value of set) {
    if (callback(value)) {
      result.add(value);
    }
  }
  return result;
}
var Recoil_filterSet = filterSet;
function mergeMaps(...maps) {
  const result = /* @__PURE__ */ new Map();
  for (let i2 = 0; i2 < maps.length; i2++) {
    const iterator = maps[i2].keys();
    let nextKey;
    while (!(nextKey = iterator.next()).done) {
      result.set(nextKey.value, maps[i2].get(nextKey.value));
    }
  }
  return result;
}
var Recoil_mergeMaps = mergeMaps;
var {
  batchUpdates: batchUpdates$3
} = Recoil_Batching;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$3,
  getNode: getNode$4,
  nodes: nodes$1
} = Recoil_Node;
var {
  useStoreRef: useStoreRef$3
} = Recoil_RecoilRoot;
var {
  AbstractRecoilValue: AbstractRecoilValue$4,
  setRecoilValueLoadable: setRecoilValueLoadable$1
} = Recoil_RecoilValueInterface;
var {
  SUSPENSE_TIMEOUT_MS: SUSPENSE_TIMEOUT_MS$2
} = Recoil_Retention;
var {
  cloneSnapshot: cloneSnapshot$1
} = Recoil_Snapshot$1;
var {
  useCallback: useCallback$2,
  useEffect: useEffect$4,
  useRef: useRef$5,
  useState: useState$2
} = import_react.default;
var {
  isSSR: isSSR$4
} = Recoil_Environment;
function useTransactionSubscription(callback) {
  const storeRef = useStoreRef$3();
  useEffect$4(() => {
    const sub = storeRef.current.subscribeToTransactions(callback);
    return sub.release;
  }, [callback, storeRef]);
}
function externallyVisibleAtomValuesInState(state) {
  const atomValues = state.atomValues.toMap();
  const persistedAtomContentsValues = Recoil_mapMap(Recoil_filterMap(atomValues, (v2, k2) => {
    const node = getNode$4(k2);
    const persistence = node.persistence_UNSTABLE;
    return persistence != null && persistence.type !== "none" && v2.state === "hasValue";
  }), (v2) => v2.contents);
  return Recoil_mergeMaps(state.nonvalidatedAtoms.toMap(), persistedAtomContentsValues);
}
function useTransactionObservation_DEPRECATED(callback) {
  useTransactionSubscription(useCallback$2((store) => {
    let previousTree = store.getState().previousTree;
    const currentTree = store.getState().currentTree;
    if (!previousTree) {
      Recoil_recoverableViolation("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil");
      previousTree = store.getState().currentTree;
    }
    const atomValues = externallyVisibleAtomValuesInState(currentTree);
    const previousAtomValues = externallyVisibleAtomValuesInState(previousTree);
    const atomInfo = Recoil_mapMap(nodes$1, (node) => {
      var _node$persistence_UNS, _node$persistence_UNS2, _node$persistence_UNS3, _node$persistence_UNS4;
      return {
        persistence_UNSTABLE: {
          type: (_node$persistence_UNS = (_node$persistence_UNS2 = node.persistence_UNSTABLE) === null || _node$persistence_UNS2 === void 0 ? void 0 : _node$persistence_UNS2.type) !== null && _node$persistence_UNS !== void 0 ? _node$persistence_UNS : "none",
          backButton: (_node$persistence_UNS3 = (_node$persistence_UNS4 = node.persistence_UNSTABLE) === null || _node$persistence_UNS4 === void 0 ? void 0 : _node$persistence_UNS4.backButton) !== null && _node$persistence_UNS3 !== void 0 ? _node$persistence_UNS3 : false
        }
      };
    });
    const modifiedAtoms = Recoil_filterSet(currentTree.dirtyAtoms, (k2) => atomValues.has(k2) || previousAtomValues.has(k2));
    callback({
      atomValues,
      previousAtomValues,
      atomInfo,
      modifiedAtoms,
      transactionMetadata: {
        ...currentTree.transactionMetadata
      }
    });
  }, [callback]));
}
function useRecoilTransactionObserver(callback) {
  useTransactionSubscription(useCallback$2((store) => {
    const snapshot = cloneSnapshot$1(store, "latest");
    const previousSnapshot = cloneSnapshot$1(store, "previous");
    callback({
      snapshot,
      previousSnapshot
    });
  }, [callback]));
}
function useRecoilSnapshot() {
  const storeRef = useStoreRef$3();
  const [snapshot, setSnapshot] = useState$2(() => cloneSnapshot$1(storeRef.current));
  const previousSnapshot = Recoil_usePrevious(snapshot);
  const timeoutID = useRef$5();
  const releaseRef = useRef$5();
  useTransactionSubscription(useCallback$2((store) => setSnapshot(cloneSnapshot$1(store)), []));
  useEffect$4(() => {
    const release = snapshot.retain();
    if (timeoutID.current && !isSSR$4) {
      var _releaseRef$current;
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
      (_releaseRef$current = releaseRef.current) === null || _releaseRef$current === void 0 ? void 0 : _releaseRef$current.call(releaseRef);
      releaseRef.current = null;
    }
    return () => {
      window.setTimeout(release, 10);
    };
  }, [snapshot]);
  if (previousSnapshot !== snapshot && !isSSR$4) {
    if (timeoutID.current) {
      var _releaseRef$current2;
      window.clearTimeout(timeoutID.current);
      timeoutID.current = null;
      (_releaseRef$current2 = releaseRef.current) === null || _releaseRef$current2 === void 0 ? void 0 : _releaseRef$current2.call(releaseRef);
      releaseRef.current = null;
    }
    releaseRef.current = snapshot.retain();
    timeoutID.current = window.setTimeout(() => {
      var _releaseRef$current3;
      timeoutID.current = null;
      (_releaseRef$current3 = releaseRef.current) === null || _releaseRef$current3 === void 0 ? void 0 : _releaseRef$current3.call(releaseRef);
      releaseRef.current = null;
    }, SUSPENSE_TIMEOUT_MS$2);
  }
  return snapshot;
}
function gotoSnapshot(store, snapshot) {
  var _storeState$nextTree;
  const storeState = store.getState();
  const prev = (_storeState$nextTree = storeState.nextTree) !== null && _storeState$nextTree !== void 0 ? _storeState$nextTree : storeState.currentTree;
  const next = snapshot.getStore_INTERNAL().getState().currentTree;
  batchUpdates$3(() => {
    const keysToUpdate = /* @__PURE__ */ new Set();
    for (const keys of [prev.atomValues.keys(), next.atomValues.keys()]) {
      for (const key of keys) {
        var _prev$atomValues$get, _next$atomValues$get;
        if (((_prev$atomValues$get = prev.atomValues.get(key)) === null || _prev$atomValues$get === void 0 ? void 0 : _prev$atomValues$get.contents) !== ((_next$atomValues$get = next.atomValues.get(key)) === null || _next$atomValues$get === void 0 ? void 0 : _next$atomValues$get.contents) && getNode$4(key).shouldRestoreFromSnapshots) {
          keysToUpdate.add(key);
        }
      }
    }
    keysToUpdate.forEach((key) => {
      setRecoilValueLoadable$1(store, new AbstractRecoilValue$4(key), next.atomValues.has(key) ? Recoil_nullthrows(next.atomValues.get(key)) : DEFAULT_VALUE$3);
    });
    store.replaceState((state) => ({
      ...state,
      stateID: snapshot.getID()
    }));
  });
}
function useGotoRecoilSnapshot() {
  const storeRef = useStoreRef$3();
  return useCallback$2((snapshot) => gotoSnapshot(storeRef.current, snapshot), [storeRef]);
}
var Recoil_SnapshotHooks = {
  useRecoilSnapshot,
  gotoSnapshot,
  useGotoRecoilSnapshot,
  useRecoilTransactionObserver,
  useTransactionObservation_DEPRECATED,
  useTransactionSubscription_DEPRECATED: useTransactionSubscription
};
var {
  peekNodeInfo: peekNodeInfo$2
} = Recoil_FunctionalCore;
var {
  useStoreRef: useStoreRef$4
} = Recoil_RecoilRoot;
function useGetRecoilValueInfo() {
  const storeRef = useStoreRef$4();
  return ({
    key
  }) => peekNodeInfo$2(storeRef.current, storeRef.current.getState().currentTree, key);
}
var Recoil_useGetRecoilValueInfo = useGetRecoilValueInfo;
var {
  reactMode: reactMode$4
} = Recoil_ReactMode;
var {
  RecoilRoot: RecoilRoot$1,
  useStoreRef: useStoreRef$5
} = Recoil_RecoilRoot;
var {
  useMemo: useMemo$2
} = import_react.default;
function useRecoilBridgeAcrossReactRoots() {
  if (reactMode$4().mode === "MUTABLE_SOURCE") {
    console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");
  }
  const store = useStoreRef$5().current;
  return useMemo$2(() => {
    function RecoilBridge({
      children
    }) {
      return import_react.default.createElement(RecoilRoot$1, {
        store_INTERNAL: store
      }, children);
    }
    return RecoilBridge;
  }, [store]);
}
var Recoil_useRecoilBridgeAcrossReactRoots = useRecoilBridgeAcrossReactRoots;
var {
  loadableWithValue: loadableWithValue$1
} = Recoil_Loadable$1;
var {
  initializeNode: initializeNode$3
} = Recoil_FunctionalCore;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$4,
  getNode: getNode$5
} = Recoil_Node;
var {
  copyTreeState: copyTreeState$1,
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$3,
  invalidateDownstreams: invalidateDownstreams$1,
  writeLoadableToTreeState: writeLoadableToTreeState$1
} = Recoil_RecoilValueInterface;
function isAtom(recoilValue) {
  return getNode$5(recoilValue.key).nodeType === "atom";
}
var TransactionInterfaceImpl = class {
  constructor(store, treeState) {
    _defineProperty(this, "_store", void 0);
    _defineProperty(this, "_treeState", void 0);
    _defineProperty(this, "_changes", void 0);
    _defineProperty(this, "get", (recoilValue) => {
      if (this._changes.has(recoilValue.key)) {
        return this._changes.get(recoilValue.key);
      }
      if (!isAtom(recoilValue)) {
        throw Recoil_err("Reading selectors within atomicUpdate is not supported");
      }
      const loadable = getRecoilValueAsLoadable$3(this._store, recoilValue, this._treeState);
      if (loadable.state === "hasValue") {
        return loadable.contents;
      } else if (loadable.state === "hasError") {
        throw loadable.contents;
      } else {
        throw Recoil_err(`Expected Recoil atom ${recoilValue.key} to have a value, but it is in a loading state.`);
      }
    });
    _defineProperty(this, "set", (recoilState, valueOrUpdater) => {
      if (!isAtom(recoilState)) {
        throw Recoil_err("Setting selectors within atomicUpdate is not supported");
      }
      if (typeof valueOrUpdater === "function") {
        const current = this.get(recoilState);
        this._changes.set(recoilState.key, valueOrUpdater(current));
      } else {
        initializeNode$3(this._store, recoilState.key, "set");
        this._changes.set(recoilState.key, valueOrUpdater);
      }
    });
    _defineProperty(this, "reset", (recoilState) => {
      this.set(recoilState, DEFAULT_VALUE$4);
    });
    this._store = store;
    this._treeState = treeState;
    this._changes = /* @__PURE__ */ new Map();
  }
  // Allow destructing
  // eslint-disable-next-line fb-www/extra-arrow-initializer
  newTreeState_INTERNAL() {
    if (this._changes.size === 0) {
      return this._treeState;
    }
    const newState = copyTreeState$1(this._treeState);
    for (const [k2, v2] of this._changes) {
      writeLoadableToTreeState$1(newState, k2, loadableWithValue$1(v2));
    }
    invalidateDownstreams$1(this._store, newState);
    return newState;
  }
};
function atomicUpdater(store) {
  return (fn2) => {
    store.replaceState((treeState) => {
      const changeset = new TransactionInterfaceImpl(store, treeState);
      fn2(changeset);
      return changeset.newTreeState_INTERNAL();
    });
  };
}
var Recoil_AtomicUpdates = {
  atomicUpdater
};
var Recoil_AtomicUpdates_1 = Recoil_AtomicUpdates.atomicUpdater;
var Recoil_AtomicUpdates$1 = Object.freeze({
  __proto__: null,
  atomicUpdater: Recoil_AtomicUpdates_1
});
function invariant(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}
var invariant_1 = invariant;
var Recoil_invariant = invariant_1;
var {
  atomicUpdater: atomicUpdater$1
} = Recoil_AtomicUpdates$1;
var {
  batchUpdates: batchUpdates$4
} = Recoil_Batching;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$5
} = Recoil_Node;
var {
  useStoreRef: useStoreRef$6
} = Recoil_RecoilRoot;
var {
  refreshRecoilValue: refreshRecoilValue$1,
  setRecoilValue: setRecoilValue$3
} = Recoil_RecoilValueInterface;
var {
  cloneSnapshot: cloneSnapshot$2
} = Recoil_Snapshot$1;
var {
  gotoSnapshot: gotoSnapshot$1
} = Recoil_SnapshotHooks;
var {
  useCallback: useCallback$3
} = import_react.default;
var Sentinel = class {
};
var SENTINEL = new Sentinel();
function recoilCallback(store, fn2, args, extraInterface) {
  let ret = SENTINEL;
  let releaseSnapshot;
  batchUpdates$4(() => {
    const errMsg = "useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";
    if (typeof fn2 !== "function") {
      throw Recoil_err(errMsg);
    }
    const callbackInterface = Recoil_lazyProxy({
      ...extraInterface !== null && extraInterface !== void 0 ? extraInterface : {},
      // flowlint-line unclear-type:off
      // $FlowFixMe[missing-local-annot]
      set: (node, newValue) => setRecoilValue$3(store, node, newValue),
      // $FlowFixMe[missing-local-annot]
      reset: (node) => setRecoilValue$3(store, node, DEFAULT_VALUE$5),
      // $FlowFixMe[missing-local-annot]
      refresh: (node) => refreshRecoilValue$1(store, node),
      gotoSnapshot: (snapshot) => gotoSnapshot$1(store, snapshot),
      transact_UNSTABLE: (transaction) => atomicUpdater$1(store)(transaction)
    }, {
      snapshot: () => {
        const snapshot = cloneSnapshot$2(store);
        releaseSnapshot = snapshot.retain();
        return snapshot;
      }
    });
    const callback = fn2(callbackInterface);
    if (typeof callback !== "function") {
      throw Recoil_err(errMsg);
    }
    ret = callback(...args);
  });
  !!(ret instanceof Sentinel) ? true ? Recoil_invariant(false, "batchUpdates should return immediately") : Recoil_invariant(false) : void 0;
  if (Recoil_isPromise(ret)) {
    ret = ret.finally(() => {
      var _releaseSnapshot;
      (_releaseSnapshot = releaseSnapshot) === null || _releaseSnapshot === void 0 ? void 0 : _releaseSnapshot();
    });
  } else {
    var _releaseSnapshot2;
    (_releaseSnapshot2 = releaseSnapshot) === null || _releaseSnapshot2 === void 0 ? void 0 : _releaseSnapshot2();
  }
  return ret;
}
function useRecoilCallback(fn2, deps) {
  const storeRef = useStoreRef$6();
  return useCallback$3(
    // $FlowIssue[incompatible-call]
    (...args) => {
      return recoilCallback(storeRef.current, fn2, args);
    },
    deps != null ? [...deps, storeRef] : void 0
    // eslint-disable-line fb-www/react-hooks-deps
  );
}
var Recoil_useRecoilCallback = {
  recoilCallback,
  useRecoilCallback
};
var {
  useStoreRef: useStoreRef$7
} = Recoil_RecoilRoot;
var {
  refreshRecoilValue: refreshRecoilValue$2
} = Recoil_RecoilValueInterface;
var {
  useCallback: useCallback$4
} = import_react.default;
function useRecoilRefresher(recoilValue) {
  const storeRef = useStoreRef$7();
  return useCallback$4(() => {
    const store = storeRef.current;
    refreshRecoilValue$2(store, recoilValue);
  }, [recoilValue, storeRef]);
}
var Recoil_useRecoilRefresher = useRecoilRefresher;
var {
  atomicUpdater: atomicUpdater$2
} = Recoil_AtomicUpdates$1;
var {
  useStoreRef: useStoreRef$8
} = Recoil_RecoilRoot;
var {
  useMemo: useMemo$3
} = import_react.default;
function useRecoilTransaction(fn2, deps) {
  const storeRef = useStoreRef$8();
  return useMemo$3(
    () => (...args) => {
      const atomicUpdate = atomicUpdater$2(storeRef.current);
      atomicUpdate((transactionInterface) => {
        fn2(transactionInterface)(...args);
      });
    },
    deps != null ? [...deps, storeRef] : void 0
    // eslint-disable-line fb-www/react-hooks-deps
  );
}
var Recoil_useRecoilTransaction = useRecoilTransaction;
var WrappedValue = class {
  constructor(value) {
    _defineProperty(this, "value", void 0);
    this.value = value;
  }
};
var Recoil_Wrapper = {
  WrappedValue
};
var Recoil_Wrapper_1 = Recoil_Wrapper.WrappedValue;
var Recoil_Wrapper$1 = Object.freeze({
  __proto__: null,
  WrappedValue: Recoil_Wrapper_1
});
var {
  isFastRefreshEnabled: isFastRefreshEnabled$2
} = Recoil_ReactMode;
var ChangedPathError = class extends Error {
};
var TreeCache = class {
  // $FlowIssue[unclear-type]
  constructor(options) {
    var _options$onHit, _options$onSet, _options$mapNodeValue;
    _defineProperty(this, "_name", void 0);
    _defineProperty(this, "_numLeafs", void 0);
    _defineProperty(this, "_root", void 0);
    _defineProperty(this, "_onHit", void 0);
    _defineProperty(this, "_onSet", void 0);
    _defineProperty(this, "_mapNodeValue", void 0);
    this._name = options === null || options === void 0 ? void 0 : options.name;
    this._numLeafs = 0;
    this._root = null;
    this._onHit = (_options$onHit = options === null || options === void 0 ? void 0 : options.onHit) !== null && _options$onHit !== void 0 ? _options$onHit : () => {
    };
    this._onSet = (_options$onSet = options === null || options === void 0 ? void 0 : options.onSet) !== null && _options$onSet !== void 0 ? _options$onSet : () => {
    };
    this._mapNodeValue = (_options$mapNodeValue = options === null || options === void 0 ? void 0 : options.mapNodeValue) !== null && _options$mapNodeValue !== void 0 ? _options$mapNodeValue : (val) => val;
  }
  size() {
    return this._numLeafs;
  }
  // $FlowIssue[unclear-type]
  root() {
    return this._root;
  }
  get(getNodeValue, handlers) {
    var _this$getLeafNode;
    return (_this$getLeafNode = this.getLeafNode(getNodeValue, handlers)) === null || _this$getLeafNode === void 0 ? void 0 : _this$getLeafNode.value;
  }
  getLeafNode(getNodeValue, handlers) {
    if (this._root == null) {
      return void 0;
    }
    let node = this._root;
    while (node) {
      handlers === null || handlers === void 0 ? void 0 : handlers.onNodeVisit(node);
      if (node.type === "leaf") {
        this._onHit(node);
        return node;
      }
      const nodeValue = this._mapNodeValue(getNodeValue(node.nodeKey));
      node = node.branches.get(nodeValue);
    }
    return void 0;
  }
  set(route, value, handlers) {
    const addLeaf = () => {
      var _node2, _node3, _this$_root2, _handlers$onNodeVisit2;
      let node;
      let branchKey;
      for (const [nodeKey, nodeValue] of route) {
        var _node, _handlers$onNodeVisit, _this$_root;
        const root = this._root;
        if ((root === null || root === void 0 ? void 0 : root.type) === "leaf") {
          throw this.invalidCacheError();
        }
        const parent = node;
        node = parent ? parent.branches.get(branchKey) : root;
        node = (_node = node) !== null && _node !== void 0 ? _node : {
          type: "branch",
          nodeKey,
          parent,
          branches: /* @__PURE__ */ new Map(),
          branchKey
        };
        if (node.type !== "branch" || node.nodeKey !== nodeKey) {
          throw this.invalidCacheError();
        }
        parent === null || parent === void 0 ? void 0 : parent.branches.set(branchKey, node);
        handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit = handlers.onNodeVisit) === null || _handlers$onNodeVisit === void 0 ? void 0 : _handlers$onNodeVisit.call(handlers, node);
        branchKey = this._mapNodeValue(nodeValue);
        this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : node;
      }
      const oldLeaf = node ? (_node2 = node) === null || _node2 === void 0 ? void 0 : _node2.branches.get(branchKey) : this._root;
      if (oldLeaf != null && (oldLeaf.type !== "leaf" || oldLeaf.branchKey !== branchKey)) {
        throw this.invalidCacheError();
      }
      const leafNode = {
        type: "leaf",
        value,
        parent: node,
        branchKey
      };
      (_node3 = node) === null || _node3 === void 0 ? void 0 : _node3.branches.set(branchKey, leafNode);
      this._root = (_this$_root2 = this._root) !== null && _this$_root2 !== void 0 ? _this$_root2 : leafNode;
      this._numLeafs++;
      this._onSet(leafNode);
      handlers === null || handlers === void 0 ? void 0 : (_handlers$onNodeVisit2 = handlers.onNodeVisit) === null || _handlers$onNodeVisit2 === void 0 ? void 0 : _handlers$onNodeVisit2.call(handlers, leafNode);
    };
    try {
      addLeaf();
    } catch (error) {
      if (error instanceof ChangedPathError) {
        this.clear();
        addLeaf();
      } else {
        throw error;
      }
    }
  }
  // Returns true if leaf was actually deleted from the tree
  delete(leaf) {
    const root = this.root();
    if (!root) {
      return false;
    }
    if (leaf === root) {
      this._root = null;
      this._numLeafs = 0;
      return true;
    }
    let node = leaf.parent;
    let branchKey = leaf.branchKey;
    while (node) {
      var _node4;
      node.branches.delete(branchKey);
      if (node === root) {
        if (node.branches.size === 0) {
          this._root = null;
          this._numLeafs = 0;
        } else {
          this._numLeafs--;
        }
        return true;
      }
      if (node.branches.size > 0) {
        break;
      }
      branchKey = (_node4 = node) === null || _node4 === void 0 ? void 0 : _node4.branchKey;
      node = node.parent;
    }
    for (; node !== root; node = node.parent) {
      if (node == null) {
        return false;
      }
    }
    this._numLeafs--;
    return true;
  }
  clear() {
    this._numLeafs = 0;
    this._root = null;
  }
  invalidCacheError() {
    const CHANGED_PATH_ERROR_MESSAGE = isFastRefreshEnabled$2() ? "Possible Fast Refresh module reload detected.  This may also be caused by an selector returning inconsistent values. Resetting cache." : "Invalid cache values.  This happens when selectors do not return consistent values for the same input dependency values.  That may also be caused when using Fast Refresh to change a selector implementation.  Resetting cache.";
    Recoil_recoverableViolation(CHANGED_PATH_ERROR_MESSAGE + (this._name != null ? ` - ${this._name}` : ""));
    throw new ChangedPathError();
  }
};
var Recoil_TreeCache = {
  TreeCache
};
var Recoil_TreeCache_1 = Recoil_TreeCache.TreeCache;
var Recoil_TreeCache$1 = Object.freeze({
  __proto__: null,
  TreeCache: Recoil_TreeCache_1
});
var LRUCache = class {
  constructor(options) {
    var _options$mapKey;
    _defineProperty(this, "_maxSize", void 0);
    _defineProperty(this, "_size", void 0);
    _defineProperty(this, "_head", void 0);
    _defineProperty(this, "_tail", void 0);
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_keyMapper", void 0);
    this._maxSize = options.maxSize;
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = /* @__PURE__ */ new Map();
    this._keyMapper = (_options$mapKey = options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v2) => v2;
  }
  head() {
    return this._head;
  }
  tail() {
    return this._tail;
  }
  size() {
    return this._size;
  }
  maxSize() {
    return this._maxSize;
  }
  has(key) {
    return this._map.has(this._keyMapper(key));
  }
  get(key) {
    const mappedKey = this._keyMapper(key);
    const node = this._map.get(mappedKey);
    if (!node) {
      return void 0;
    }
    this.set(key, node.value);
    return node.value;
  }
  set(key, val) {
    const mappedKey = this._keyMapper(key);
    const existingNode = this._map.get(mappedKey);
    if (existingNode) {
      this.delete(key);
    }
    const head = this.head();
    const node = {
      key,
      right: head,
      left: null,
      value: val
    };
    if (head) {
      head.left = node;
    } else {
      this._tail = node;
    }
    this._map.set(mappedKey, node);
    this._head = node;
    this._size++;
    this._maybeDeleteLRU();
  }
  _maybeDeleteLRU() {
    if (this.size() > this.maxSize()) {
      this.deleteLru();
    }
  }
  deleteLru() {
    const tail = this.tail();
    if (tail) {
      this.delete(tail.key);
    }
  }
  delete(key) {
    const mappedKey = this._keyMapper(key);
    if (!this._size || !this._map.has(mappedKey)) {
      return;
    }
    const node = Recoil_nullthrows(this._map.get(mappedKey));
    const right = node.right;
    const left = node.left;
    if (right) {
      right.left = node.left;
    }
    if (left) {
      left.right = node.right;
    }
    if (node === this.head()) {
      this._head = right;
    }
    if (node === this.tail()) {
      this._tail = left;
    }
    this._map.delete(mappedKey);
    this._size--;
  }
  clear() {
    this._size = 0;
    this._head = null;
    this._tail = null;
    this._map = /* @__PURE__ */ new Map();
  }
};
var Recoil_LRUCache = {
  LRUCache
};
var Recoil_LRUCache_1 = Recoil_LRUCache.LRUCache;
var Recoil_LRUCache$1 = Object.freeze({
  __proto__: null,
  LRUCache: Recoil_LRUCache_1
});
var {
  LRUCache: LRUCache$1
} = Recoil_LRUCache$1;
var {
  TreeCache: TreeCache$1
} = Recoil_TreeCache$1;
function treeCacheLRU({
  name,
  maxSize,
  mapNodeValue = (v2) => v2
}) {
  const lruCache = new LRUCache$1({
    maxSize
  });
  const cache = new TreeCache$1({
    name,
    mapNodeValue,
    onHit: (node) => {
      lruCache.set(node, true);
    },
    onSet: (node) => {
      const lruNode = lruCache.tail();
      lruCache.set(node, true);
      if (lruNode && cache.size() > maxSize) {
        cache.delete(lruNode.key);
      }
    }
  });
  return cache;
}
var Recoil_treeCacheLRU = treeCacheLRU;
var TIME_WARNING_THRESHOLD_MS = 15;
function stringify(x2, opt, key) {
  if (typeof x2 === "string" && !x2.includes('"') && !x2.includes("\\")) {
    return `"${x2}"`;
  }
  switch (typeof x2) {
    case "undefined":
      return "";
    case "boolean":
      return x2 ? "true" : "false";
    case "number":
    case "symbol":
      return String(x2);
    case "string":
      return JSON.stringify(x2);
    case "function":
      if ((opt === null || opt === void 0 ? void 0 : opt.allowFunctions) !== true) {
        throw Recoil_err("Attempt to serialize function in a Recoil cache key");
      }
      return `__FUNCTION(${x2.name})__`;
  }
  if (x2 === null) {
    return "null";
  }
  if (typeof x2 !== "object") {
    var _JSON$stringify;
    return (_JSON$stringify = JSON.stringify(x2)) !== null && _JSON$stringify !== void 0 ? _JSON$stringify : "";
  }
  if (Recoil_isPromise(x2)) {
    return "__PROMISE__";
  }
  if (Array.isArray(x2)) {
    return `[${x2.map((v2, i2) => stringify(v2, opt, i2.toString()))}]`;
  }
  if (typeof x2.toJSON === "function") {
    return stringify(x2.toJSON(key), opt, key);
  }
  if (x2 instanceof Map) {
    const obj = {};
    for (const [k2, v2] of x2) {
      obj[typeof k2 === "string" ? k2 : stringify(k2, opt)] = v2;
    }
    return stringify(obj, opt, key);
  }
  if (x2 instanceof Set) {
    return stringify(
      // $FlowFixMe[missing-local-annot]
      Array.from(x2).sort((a2, b2) => stringify(a2, opt).localeCompare(stringify(b2, opt))),
      opt,
      key
    );
  }
  if (Symbol !== void 0 && x2[Symbol.iterator] != null && typeof x2[Symbol.iterator] === "function") {
    return stringify(Array.from(x2), opt, key);
  }
  return `{${Object.keys(x2).filter((k2) => x2[k2] !== void 0).sort().map((k2) => `${stringify(k2, opt)}:${stringify(x2[k2], opt, k2)}`).join(",")}}`;
}
function stableStringify(x2, opt = {
  allowFunctions: false
}) {
  if (true) {
    if (typeof window !== "undefined") {
      const startTime = window.performance ? window.performance.now() : 0;
      const str = stringify(x2, opt);
      const endTime = window.performance ? window.performance.now() : 0;
      if (endTime - startTime > TIME_WARNING_THRESHOLD_MS) {
        console.groupCollapsed(`Recoil: Spent ${endTime - startTime}ms computing a cache key`);
        console.warn(x2, str);
        console.groupEnd();
      }
      return str;
    }
  }
  return stringify(x2, opt);
}
var Recoil_stableStringify = stableStringify;
var {
  TreeCache: TreeCache$2
} = Recoil_TreeCache$1;
var defaultPolicy = {
  equality: "reference",
  eviction: "keep-all",
  maxSize: Infinity
};
function treeCacheFromPolicy({
  equality = defaultPolicy.equality,
  eviction = defaultPolicy.eviction,
  maxSize = defaultPolicy.maxSize
} = defaultPolicy, name) {
  const valueMapper = getValueMapper(equality);
  return getTreeCache(eviction, maxSize, valueMapper, name);
}
function getValueMapper(equality) {
  switch (equality) {
    case "reference":
      return (val) => val;
    case "value":
      return (val) => Recoil_stableStringify(val);
  }
  throw Recoil_err(`Unrecognized equality policy ${equality}`);
}
function getTreeCache(eviction, maxSize, mapNodeValue, name) {
  switch (eviction) {
    case "keep-all":
      return new TreeCache$2({
        name,
        mapNodeValue
      });
    case "lru":
      return Recoil_treeCacheLRU({
        name,
        maxSize: Recoil_nullthrows(maxSize),
        mapNodeValue
      });
    case "most-recent":
      return Recoil_treeCacheLRU({
        name,
        maxSize: 1,
        mapNodeValue
      });
  }
  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
}
var Recoil_treeCacheFromPolicy = treeCacheFromPolicy;
function isNode(object) {
  var _ownerDocument, _doc$defaultView;
  if (typeof window === "undefined") {
    return false;
  }
  const doc = object != null ? (_ownerDocument = object.ownerDocument) !== null && _ownerDocument !== void 0 ? _ownerDocument : object : document;
  const defaultView = (_doc$defaultView = doc.defaultView) !== null && _doc$defaultView !== void 0 ? _doc$defaultView : window;
  return !!(object != null && (typeof defaultView.Node === "function" ? object instanceof defaultView.Node : typeof object === "object" && typeof object.nodeType === "number" && typeof object.nodeName === "string"));
}
var Recoil_isNode = isNode;
var {
  isReactNative: isReactNative$1,
  isWindow: isWindow$1
} = Recoil_Environment;
function shouldNotBeFrozen(value) {
  if (value === null || typeof value !== "object") {
    return true;
  }
  switch (typeof value.$$typeof) {
    case "symbol":
      return true;
    case "number":
      return true;
  }
  if (value["@@__IMMUTABLE_ITERABLE__@@"] != null || value["@@__IMMUTABLE_KEYED__@@"] != null || value["@@__IMMUTABLE_INDEXED__@@"] != null || value["@@__IMMUTABLE_ORDERED__@@"] != null || value["@@__IMMUTABLE_RECORD__@@"] != null) {
    return true;
  }
  if (Recoil_isNode(value)) {
    return true;
  }
  if (Recoil_isPromise(value)) {
    return true;
  }
  if (value instanceof Error) {
    return true;
  }
  if (ArrayBuffer.isView(value)) {
    return true;
  }
  if (!isReactNative$1 && isWindow$1(value)) {
    return true;
  }
  return false;
}
function deepFreezeValue(value) {
  if (typeof value !== "object" || shouldNotBeFrozen(value)) {
    return;
  }
  Object.freeze(value);
  for (const key in value) {
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      const prop = value[key];
      if (typeof prop === "object" && prop != null && !Object.isFrozen(prop)) {
        deepFreezeValue(prop);
      }
    }
  }
  Object.seal(value);
}
var Recoil_deepFreezeValue = deepFreezeValue;
function startPerfBlock(_id) {
  return () => null;
}
var Recoil_PerformanceTimings = {
  startPerfBlock
};
var {
  isLoadable: isLoadable$1,
  loadableWithError: loadableWithError$1,
  loadableWithPromise: loadableWithPromise$1,
  loadableWithValue: loadableWithValue$2
} = Recoil_Loadable$1;
var {
  WrappedValue: WrappedValue$1
} = Recoil_Wrapper$1;
var {
  getNodeLoadable: getNodeLoadable$2,
  peekNodeLoadable: peekNodeLoadable$1,
  setNodeValue: setNodeValue$3
} = Recoil_FunctionalCore;
var {
  saveDepsToStore: saveDepsToStore$1
} = Recoil_Graph;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$6,
  getConfigDeletionHandler: getConfigDeletionHandler$1,
  getNode: getNode$6,
  registerNode: registerNode$1
} = Recoil_Node;
var {
  isRecoilValue: isRecoilValue$3
} = Recoil_RecoilValue$1;
var {
  markRecoilValueModified: markRecoilValueModified$1
} = Recoil_RecoilValueInterface;
var {
  retainedByOptionWithDefault: retainedByOptionWithDefault$1
} = Recoil_Retention;
var {
  recoilCallback: recoilCallback$1
} = Recoil_useRecoilCallback;
var {
  startPerfBlock: startPerfBlock$1
} = Recoil_PerformanceTimings;
var Canceled = class {
};
var CANCELED = new Canceled();
var dependencyStack = [];
var waitingStores = /* @__PURE__ */ new Map();
var getNewExecutionID = /* @__PURE__ */ (() => {
  let executionID = 0;
  return () => executionID++;
})();
function selector(options) {
  let recoilValue = null;
  const {
    key,
    get: get5,
    cachePolicy_UNSTABLE: cachePolicy
  } = options;
  const set = options.set != null ? options.set : void 0;
  if (true) {
    if (typeof key !== "string") {
      throw Recoil_err("A key option with a unique string value must be provided when creating a selector.");
    }
    if (typeof get5 !== "function") {
      throw Recoil_err("Selectors must specify a get callback option to get the selector value.");
    }
  }
  const discoveredDependencyNodeKeys = /* @__PURE__ */ new Set();
  const cache = Recoil_treeCacheFromPolicy(cachePolicy !== null && cachePolicy !== void 0 ? cachePolicy : {
    equality: "reference",
    eviction: "keep-all"
  }, key);
  const retainedBy = retainedByOptionWithDefault$1(options.retainedBy_UNSTABLE);
  const executionInfoMap = /* @__PURE__ */ new Map();
  let liveStoresCount = 0;
  function selectorIsLive() {
    return !Recoil_gkx("recoil_memory_managament_2020") || liveStoresCount > 0;
  }
  function selectorInit(store) {
    store.getState().knownSelectors.add(key);
    liveStoresCount++;
    return () => {
      liveStoresCount--;
    };
  }
  function selectorShouldDeleteConfigOnRelease() {
    return getConfigDeletionHandler$1(key) !== void 0 && !selectorIsLive();
  }
  function resolveAsync(store, state, executionID, loadable, depValues) {
    setCache(state, loadable, depValues);
    notifyStoresOfResolvedAsync(store, executionID);
  }
  function notifyStoresOfResolvedAsync(store, executionID) {
    if (isLatestExecution(store, executionID)) {
      clearExecutionInfo(store);
    }
    notifyWaitingStores(executionID, true);
  }
  function notifyStoresOfNewAsyncDep(store, executionID) {
    if (isLatestExecution(store, executionID)) {
      const executionInfo = Recoil_nullthrows(getExecutionInfo(store));
      executionInfo.stateVersions.clear();
      notifyWaitingStores(executionID, false);
    }
  }
  function notifyWaitingStores(executionID, clearWaitlist) {
    const stores = waitingStores.get(executionID);
    if (stores != null) {
      for (const waitingStore of stores) {
        markRecoilValueModified$1(waitingStore, Recoil_nullthrows(recoilValue));
      }
      if (clearWaitlist) {
        waitingStores.delete(executionID);
      }
    }
  }
  function markStoreWaitingForResolvedAsync(store, executionID) {
    let stores = waitingStores.get(executionID);
    if (stores == null) {
      waitingStores.set(executionID, stores = /* @__PURE__ */ new Set());
    }
    stores.add(store);
  }
  function wrapResultPromise(store, promise, state, depValues, executionID, loadingDepsState) {
    return promise.then((value) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      const loadable = loadableWithValue$2(value);
      resolveAsync(store, state, executionID, loadable, depValues);
      return value;
    }).catch((errorOrPromise) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      if (Recoil_isPromise(errorOrPromise)) {
        return wrapPendingDependencyPromise(store, errorOrPromise, state, depValues, executionID, loadingDepsState);
      }
      const loadable = loadableWithError$1(errorOrPromise);
      resolveAsync(store, state, executionID, loadable, depValues);
      throw errorOrPromise;
    });
  }
  function wrapPendingDependencyPromise(store, promise, state, existingDeps, executionID, loadingDepsState) {
    return promise.then((resolvedDep) => {
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      if (loadingDepsState.loadingDepKey != null && loadingDepsState.loadingDepPromise === promise) {
        state.atomValues.set(loadingDepsState.loadingDepKey, loadableWithValue$2(resolvedDep));
      } else {
        store.getState().knownSelectors.forEach((nodeKey) => {
          state.atomValues.delete(nodeKey);
        });
      }
      const cachedLoadable = getLoadableFromCacheAndUpdateDeps(store, state);
      if (cachedLoadable && cachedLoadable.state !== "loading") {
        if (isLatestExecution(store, executionID) || getExecutionInfo(store) == null) {
          notifyStoresOfResolvedAsync(store, executionID);
        }
        if (cachedLoadable.state === "hasValue") {
          return cachedLoadable.contents;
        } else {
          throw cachedLoadable.contents;
        }
      }
      if (!isLatestExecution(store, executionID)) {
        const executionInfo = getInProgressExecutionInfo(store, state);
        if (executionInfo != null) {
          return executionInfo.loadingLoadable.contents;
        }
      }
      const [loadable, depValues] = evaluateSelectorGetter(store, state, executionID);
      if (loadable.state !== "loading") {
        resolveAsync(store, state, executionID, loadable, depValues);
      }
      if (loadable.state === "hasError") {
        throw loadable.contents;
      }
      return loadable.contents;
    }).catch((error) => {
      if (error instanceof Canceled) {
        throw CANCELED;
      }
      if (!selectorIsLive()) {
        clearExecutionInfo(store);
        throw CANCELED;
      }
      const loadable = loadableWithError$1(error);
      resolveAsync(store, state, executionID, loadable, existingDeps);
      throw error;
    });
  }
  function updateDeps(store, state, deps, executionID) {
    var _store$getState, _store$getState$curre, _store$getState2, _store$getState2$next;
    if (isLatestExecution(store, executionID) || state.version === ((_store$getState = store.getState()) === null || _store$getState === void 0 ? void 0 : (_store$getState$curre = _store$getState.currentTree) === null || _store$getState$curre === void 0 ? void 0 : _store$getState$curre.version) || state.version === ((_store$getState2 = store.getState()) === null || _store$getState2 === void 0 ? void 0 : (_store$getState2$next = _store$getState2.nextTree) === null || _store$getState2$next === void 0 ? void 0 : _store$getState2$next.version)) {
      var _store$getState$nextT, _store$getState3, _store$getState3$next;
      saveDepsToStore$1(key, deps, store, (_store$getState$nextT = (_store$getState3 = store.getState()) === null || _store$getState3 === void 0 ? void 0 : (_store$getState3$next = _store$getState3.nextTree) === null || _store$getState3$next === void 0 ? void 0 : _store$getState3$next.version) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree.version);
    }
    for (const nodeKey of deps) {
      discoveredDependencyNodeKeys.add(nodeKey);
    }
  }
  function evaluateSelectorGetter(store, state, executionID) {
    const endPerfBlock = startPerfBlock$1(key);
    let duringSynchronousExecution = true;
    let duringAsynchronousExecution = true;
    const finishEvaluation = () => {
      endPerfBlock();
      duringAsynchronousExecution = false;
    };
    let result;
    let resultIsError = false;
    let loadable;
    const loadingDepsState = {
      loadingDepKey: null,
      loadingDepPromise: null
    };
    const depValues = /* @__PURE__ */ new Map();
    function getRecoilValue({
      key: depKey
    }) {
      const depLoadable = getNodeLoadable$2(store, state, depKey);
      depValues.set(depKey, depLoadable);
      if (!duringSynchronousExecution) {
        updateDeps(store, state, new Set(depValues.keys()), executionID);
        notifyStoresOfNewAsyncDep(store, executionID);
      }
      switch (depLoadable.state) {
        case "hasValue":
          return depLoadable.contents;
        case "hasError":
          throw depLoadable.contents;
        case "loading":
          loadingDepsState.loadingDepKey = depKey;
          loadingDepsState.loadingDepPromise = depLoadable.contents;
          throw depLoadable.contents;
      }
      throw Recoil_err("Invalid Loadable state");
    }
    const getCallback = (fn2) => {
      return (...args) => {
        if (duringAsynchronousExecution) {
          throw Recoil_err("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");
        }
        !(recoilValue != null) ? true ? Recoil_invariant(false, "Recoil Value can never be null") : Recoil_invariant(false) : void 0;
        return recoilCallback$1(
          store,
          fn2,
          args,
          {
            node: recoilValue
          }
          // flowlint-line unclear-type:off
        );
      };
    };
    try {
      result = get5({
        get: getRecoilValue,
        getCallback
      });
      result = isRecoilValue$3(result) ? getRecoilValue(result) : result;
      if (isLoadable$1(result)) {
        if (result.state === "hasError") {
          resultIsError = true;
        }
        result = result.contents;
      }
      if (Recoil_isPromise(result)) {
        result = wrapResultPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
      } else {
        finishEvaluation();
      }
      result = result instanceof WrappedValue$1 ? result.value : result;
    } catch (errorOrDepPromise) {
      result = errorOrDepPromise;
      if (Recoil_isPromise(result)) {
        result = wrapPendingDependencyPromise(store, result, state, depValues, executionID, loadingDepsState).finally(finishEvaluation);
      } else {
        resultIsError = true;
        finishEvaluation();
      }
    }
    if (resultIsError) {
      loadable = loadableWithError$1(result);
    } else if (Recoil_isPromise(result)) {
      loadable = loadableWithPromise$1(result);
    } else {
      loadable = loadableWithValue$2(result);
    }
    duringSynchronousExecution = false;
    updateExecutionInfoDepValues(store, executionID, depValues);
    updateDeps(store, state, new Set(depValues.keys()), executionID);
    return [loadable, depValues];
  }
  function getLoadableFromCacheAndUpdateDeps(store, state) {
    let cachedLoadable = state.atomValues.get(key);
    if (cachedLoadable != null) {
      return cachedLoadable;
    }
    const depsAfterCacheLookup = /* @__PURE__ */ new Set();
    try {
      cachedLoadable = cache.get((nodeKey) => {
        !(typeof nodeKey === "string") ? true ? Recoil_invariant(false, "Cache nodeKey is type string") : Recoil_invariant(false) : void 0;
        return getNodeLoadable$2(store, state, nodeKey).contents;
      }, {
        onNodeVisit: (node) => {
          if (node.type === "branch" && node.nodeKey !== key) {
            depsAfterCacheLookup.add(node.nodeKey);
          }
        }
      });
    } catch (error) {
      throw Recoil_err(`Problem with cache lookup for selector "${key}": ${error.message}`);
    }
    if (cachedLoadable) {
      var _getExecutionInfo;
      state.atomValues.set(key, cachedLoadable);
      updateDeps(store, state, depsAfterCacheLookup, (_getExecutionInfo = getExecutionInfo(store)) === null || _getExecutionInfo === void 0 ? void 0 : _getExecutionInfo.executionID);
    }
    return cachedLoadable;
  }
  function getSelectorLoadableAndUpdateDeps(store, state) {
    const cachedVal = getLoadableFromCacheAndUpdateDeps(store, state);
    if (cachedVal != null) {
      clearExecutionInfo(store);
      return cachedVal;
    }
    const inProgressExecutionInfo = getInProgressExecutionInfo(store, state);
    if (inProgressExecutionInfo != null) {
      var _inProgressExecutionI;
      if (((_inProgressExecutionI = inProgressExecutionInfo.loadingLoadable) === null || _inProgressExecutionI === void 0 ? void 0 : _inProgressExecutionI.state) === "loading") {
        markStoreWaitingForResolvedAsync(store, inProgressExecutionInfo.executionID);
      }
      return inProgressExecutionInfo.loadingLoadable;
    }
    const newExecutionID = getNewExecutionID();
    const [loadable, newDepValues] = evaluateSelectorGetter(store, state, newExecutionID);
    if (loadable.state === "loading") {
      setExecutionInfo(store, newExecutionID, loadable, newDepValues, state);
      markStoreWaitingForResolvedAsync(store, newExecutionID);
    } else {
      clearExecutionInfo(store);
      setCache(state, loadable, newDepValues);
    }
    return loadable;
  }
  function getInProgressExecutionInfo(store, state) {
    const pendingExecutions = Recoil_concatIterables([executionInfoMap.has(store) ? [Recoil_nullthrows(executionInfoMap.get(store))] : [], Recoil_mapIterable(Recoil_filterIterable(executionInfoMap, ([s2]) => s2 !== store), ([, execInfo]) => execInfo)]);
    function anyDepChanged(execDepValues) {
      for (const [depKey, execLoadable] of execDepValues) {
        if (!getNodeLoadable$2(store, state, depKey).is(execLoadable)) {
          return true;
        }
      }
      return false;
    }
    for (const execInfo of pendingExecutions) {
      if (
        // If this execution was already checked to be valid with this version
        // of state, then let's use it!
        execInfo.stateVersions.get(state.version) || // If the deps for the execution match our current state, then it's valid
        !anyDepChanged(execInfo.depValuesDiscoveredSoFarDuringAsyncWork)
      ) {
        execInfo.stateVersions.set(state.version, true);
        return execInfo;
      } else {
        execInfo.stateVersions.set(state.version, false);
      }
    }
    return void 0;
  }
  function getExecutionInfo(store) {
    return executionInfoMap.get(store);
  }
  function setExecutionInfo(store, newExecutionID, loadable, depValues, state) {
    executionInfoMap.set(store, {
      depValuesDiscoveredSoFarDuringAsyncWork: depValues,
      executionID: newExecutionID,
      loadingLoadable: loadable,
      stateVersions: /* @__PURE__ */ new Map([[state.version, true]])
    });
  }
  function updateExecutionInfoDepValues(store, executionID, depValues) {
    if (isLatestExecution(store, executionID)) {
      const executionInfo = getExecutionInfo(store);
      if (executionInfo != null) {
        executionInfo.depValuesDiscoveredSoFarDuringAsyncWork = depValues;
      }
    }
  }
  function clearExecutionInfo(store) {
    executionInfoMap.delete(store);
  }
  function isLatestExecution(store, executionID) {
    var _getExecutionInfo2;
    return executionID === ((_getExecutionInfo2 = getExecutionInfo(store)) === null || _getExecutionInfo2 === void 0 ? void 0 : _getExecutionInfo2.executionID);
  }
  function depValuesToDepRoute(depValues) {
    return Array.from(depValues.entries()).map(([depKey, valLoadable]) => [depKey, valLoadable.contents]);
  }
  function setCache(state, loadable, depValues) {
    if (true) {
      if (loadable.state !== "loading" && Boolean(options.dangerouslyAllowMutability) === false) {
        Recoil_deepFreezeValue(loadable.contents);
      }
    }
    state.atomValues.set(key, loadable);
    try {
      cache.set(depValuesToDepRoute(depValues), loadable);
    } catch (error) {
      throw Recoil_err(`Problem with setting cache for selector "${key}": ${error.message}`);
    }
  }
  function detectCircularDependencies(fn2) {
    if (dependencyStack.includes(key)) {
      const message = `Recoil selector has circular dependencies: ${dependencyStack.slice(dependencyStack.indexOf(key)).join("  ")}`;
      return loadableWithError$1(Recoil_err(message));
    }
    dependencyStack.push(key);
    try {
      return fn2();
    } finally {
      dependencyStack.pop();
    }
  }
  function selectorPeek(store, state) {
    const cachedLoadable = state.atomValues.get(key);
    if (cachedLoadable != null) {
      return cachedLoadable;
    }
    return cache.get((nodeKey) => {
      var _peekNodeLoadable;
      !(typeof nodeKey === "string") ? true ? Recoil_invariant(false, "Cache nodeKey is type string") : Recoil_invariant(false) : void 0;
      return (_peekNodeLoadable = peekNodeLoadable$1(store, state, nodeKey)) === null || _peekNodeLoadable === void 0 ? void 0 : _peekNodeLoadable.contents;
    });
  }
  function selectorGet(store, state) {
    return detectCircularDependencies(() => getSelectorLoadableAndUpdateDeps(store, state));
  }
  function invalidateSelector(state) {
    state.atomValues.delete(key);
  }
  function clearSelectorCache(store, treeState) {
    !(recoilValue != null) ? true ? Recoil_invariant(false, "Recoil Value can never be null") : Recoil_invariant(false) : void 0;
    for (const nodeKey of discoveredDependencyNodeKeys) {
      var _node$clearCache;
      const node = getNode$6(nodeKey);
      (_node$clearCache = node.clearCache) === null || _node$clearCache === void 0 ? void 0 : _node$clearCache.call(node, store, treeState);
    }
    discoveredDependencyNodeKeys.clear();
    invalidateSelector(treeState);
    cache.clear();
    markRecoilValueModified$1(store, recoilValue);
  }
  if (set != null) {
    const selectorSet = (store, state, newValue) => {
      let syncSelectorSetFinished = false;
      const writes = /* @__PURE__ */ new Map();
      function getRecoilValue({
        key: depKey
      }) {
        if (syncSelectorSetFinished) {
          throw Recoil_err("Recoil: Async selector sets are not currently supported.");
        }
        const loadable = getNodeLoadable$2(store, state, depKey);
        if (loadable.state === "hasValue") {
          return loadable.contents;
        } else if (loadable.state === "loading") {
          const msg = `Getting value of asynchronous atom or selector "${depKey}" in a pending state while setting selector "${key}" is not yet supported.`;
          Recoil_recoverableViolation(msg);
          throw Recoil_err(msg);
        } else {
          throw loadable.contents;
        }
      }
      function setRecoilState(recoilState, valueOrUpdater) {
        if (syncSelectorSetFinished) {
          const msg = "Recoil: Async selector sets are not currently supported.";
          Recoil_recoverableViolation(msg);
          throw Recoil_err(msg);
        }
        const setValue = typeof valueOrUpdater === "function" ? (
          // cast to any because we can't restrict type S from being a function itself without losing support for opaque types
          // flowlint-next-line unclear-type:off
          valueOrUpdater(getRecoilValue(recoilState))
        ) : valueOrUpdater;
        const upstreamWrites = setNodeValue$3(store, state, recoilState.key, setValue);
        upstreamWrites.forEach((v2, k2) => writes.set(k2, v2));
      }
      function resetRecoilState(recoilState) {
        setRecoilState(recoilState, DEFAULT_VALUE$6);
      }
      const ret = set({
        set: setRecoilState,
        get: getRecoilValue,
        reset: resetRecoilState
      }, newValue);
      if (ret !== void 0) {
        throw Recoil_isPromise(ret) ? Recoil_err("Recoil: Async selector sets are not currently supported.") : Recoil_err("Recoil: selector set should be a void function.");
      }
      syncSelectorSetFinished = true;
      return writes;
    };
    return recoilValue = registerNode$1({
      key,
      nodeType: "selector",
      peek: selectorPeek,
      get: selectorGet,
      set: selectorSet,
      init: selectorInit,
      invalidate: invalidateSelector,
      clearCache: clearSelectorCache,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  } else {
    return recoilValue = registerNode$1({
      key,
      nodeType: "selector",
      peek: selectorPeek,
      get: selectorGet,
      init: selectorInit,
      invalidate: invalidateSelector,
      clearCache: clearSelectorCache,
      shouldDeleteConfigOnRelease: selectorShouldDeleteConfigOnRelease,
      dangerouslyAllowMutability: options.dangerouslyAllowMutability,
      shouldRestoreFromSnapshots: false,
      retainedBy
    });
  }
}
selector.value = (value) => new WrappedValue$1(value);
var Recoil_selector = selector;
var {
  isLoadable: isLoadable$2,
  loadableWithError: loadableWithError$2,
  loadableWithPromise: loadableWithPromise$2,
  loadableWithValue: loadableWithValue$3
} = Recoil_Loadable$1;
var {
  WrappedValue: WrappedValue$2
} = Recoil_Wrapper$1;
var {
  peekNodeInfo: peekNodeInfo$3
} = Recoil_FunctionalCore;
var {
  DEFAULT_VALUE: DEFAULT_VALUE$7,
  DefaultValue: DefaultValue$2,
  getConfigDeletionHandler: getConfigDeletionHandler$2,
  registerNode: registerNode$2,
  setConfigDeletionHandler: setConfigDeletionHandler$1
} = Recoil_Node;
var {
  isRecoilValue: isRecoilValue$4
} = Recoil_RecoilValue$1;
var {
  getRecoilValueAsLoadable: getRecoilValueAsLoadable$4,
  markRecoilValueModified: markRecoilValueModified$2,
  setRecoilValue: setRecoilValue$4,
  setRecoilValueLoadable: setRecoilValueLoadable$2
} = Recoil_RecoilValueInterface;
var {
  retainedByOptionWithDefault: retainedByOptionWithDefault$2
} = Recoil_Retention;
var unwrap = (x2) => x2 instanceof WrappedValue$2 ? x2.value : x2;
function baseAtom(options) {
  const {
    key,
    persistence_UNSTABLE: persistence
  } = options;
  const retainedBy = retainedByOptionWithDefault$2(options.retainedBy_UNSTABLE);
  let liveStoresCount = 0;
  function unwrapPromise(promise) {
    return loadableWithPromise$2(promise.then((value) => {
      defaultLoadable = loadableWithValue$3(value);
      return value;
    }).catch((error) => {
      defaultLoadable = loadableWithError$2(error);
      throw error;
    }));
  }
  let defaultLoadable = Recoil_isPromise(options.default) ? unwrapPromise(options.default) : isLoadable$2(options.default) ? options.default.state === "loading" ? unwrapPromise(options.default.contents) : options.default : (
    // $FlowFixMe[incompatible-call]
    loadableWithValue$3(unwrap(options.default))
  );
  maybeFreezeValueOrPromise(defaultLoadable.contents);
  let cachedAnswerForUnvalidatedValue = void 0;
  const cleanupEffectsByStore = /* @__PURE__ */ new Map();
  function maybeFreezeValueOrPromise(valueOrPromise) {
    if (true) {
      if (options.dangerouslyAllowMutability !== true) {
        if (Recoil_isPromise(valueOrPromise)) {
          return valueOrPromise.then((value) => {
            Recoil_deepFreezeValue(value);
            return value;
          });
        } else {
          Recoil_deepFreezeValue(valueOrPromise);
          return valueOrPromise;
        }
      }
    }
    return valueOrPromise;
  }
  function wrapPendingPromise(store, promise) {
    const wrappedPromise = promise.then((value) => {
      var _store$getState$nextT, _state$atomValues$get;
      const state = (_store$getState$nextT = store.getState().nextTree) !== null && _store$getState$nextT !== void 0 ? _store$getState$nextT : store.getState().currentTree;
      if (((_state$atomValues$get = state.atomValues.get(key)) === null || _state$atomValues$get === void 0 ? void 0 : _state$atomValues$get.contents) === wrappedPromise) {
        setRecoilValue$4(store, node, value);
      }
      return value;
    }).catch((error) => {
      var _store$getState$nextT2, _state$atomValues$get2;
      const state = (_store$getState$nextT2 = store.getState().nextTree) !== null && _store$getState$nextT2 !== void 0 ? _store$getState$nextT2 : store.getState().currentTree;
      if (((_state$atomValues$get2 = state.atomValues.get(key)) === null || _state$atomValues$get2 === void 0 ? void 0 : _state$atomValues$get2.contents) === wrappedPromise) {
        setRecoilValueLoadable$2(store, node, loadableWithError$2(error));
      }
      throw error;
    });
    return wrappedPromise;
  }
  function initAtom(store, initState, trigger) {
    var _options$effects;
    liveStoresCount++;
    const cleanupAtom = () => {
      var _cleanupEffectsByStor;
      liveStoresCount--;
      (_cleanupEffectsByStor = cleanupEffectsByStore.get(store)) === null || _cleanupEffectsByStor === void 0 ? void 0 : _cleanupEffectsByStor.forEach((cleanup) => cleanup());
      cleanupEffectsByStore.delete(store);
    };
    store.getState().knownAtoms.add(key);
    if (defaultLoadable.state === "loading") {
      const notifyDefaultSubscribers = () => {
        var _store$getState$nextT3;
        const state = (_store$getState$nextT3 = store.getState().nextTree) !== null && _store$getState$nextT3 !== void 0 ? _store$getState$nextT3 : store.getState().currentTree;
        if (!state.atomValues.has(key)) {
          markRecoilValueModified$2(store, node);
        }
      };
      defaultLoadable.contents.finally(notifyDefaultSubscribers);
    }
    const effects = (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE;
    if (effects != null) {
      let getLoadable = function(recoilValue) {
        if (isDuringInit && recoilValue.key === key) {
          const retValue = initValue;
          return retValue instanceof DefaultValue$2 ? peekAtom(store, initState) : Recoil_isPromise(retValue) ? loadableWithPromise$2(retValue.then((v2) => v2 instanceof DefaultValue$2 ? (
            // Cast T to S
            defaultLoadable.toPromise()
          ) : v2)) : (
            // $FlowFixMe[incompatible-call]
            loadableWithValue$3(retValue)
          );
        }
        return getRecoilValueAsLoadable$4(store, recoilValue);
      }, getPromise = function(recoilValue) {
        return getLoadable(recoilValue).toPromise();
      }, getInfo_UNSTABLE = function(recoilValue) {
        var _store$getState$nextT4;
        const info = peekNodeInfo$3(store, (_store$getState$nextT4 = store.getState().nextTree) !== null && _store$getState$nextT4 !== void 0 ? _store$getState$nextT4 : store.getState().currentTree, recoilValue.key);
        return isDuringInit && recoilValue.key === key && !(initValue instanceof DefaultValue$2) ? {
          ...info,
          isSet: true,
          loadable: getLoadable(recoilValue)
        } : info;
      };
      let initValue = DEFAULT_VALUE$7;
      let isDuringInit = true;
      let isInitError = false;
      let pendingSetSelf = null;
      const setSelf = (effect) => (valueOrUpdater) => {
        if (isDuringInit) {
          const currentLoadable = getLoadable(node);
          const currentValue = currentLoadable.state === "hasValue" ? currentLoadable.contents : DEFAULT_VALUE$7;
          initValue = typeof valueOrUpdater === "function" ? (
            // cast to any because we can't restrict T from being a function without losing support for opaque types
            valueOrUpdater(currentValue)
          ) : valueOrUpdater;
          if (Recoil_isPromise(initValue)) {
            initValue = initValue.then((value) => {
              pendingSetSelf = {
                effect,
                value
              };
              return value;
            });
          }
        } else {
          if (Recoil_isPromise(valueOrUpdater)) {
            throw Recoil_err("Setting atoms to async values is not implemented.");
          }
          if (typeof valueOrUpdater !== "function") {
            pendingSetSelf = {
              effect,
              value: unwrap(valueOrUpdater)
            };
          }
          setRecoilValue$4(store, node, typeof valueOrUpdater === "function" ? (currentValue) => {
            const newValue = unwrap(
              // cast to any because we can't restrict T from being a function without losing support for opaque types
              valueOrUpdater(currentValue)
              // flowlint-line unclear-type:off
            );
            pendingSetSelf = {
              effect,
              value: newValue
            };
            return newValue;
          } : unwrap(valueOrUpdater));
        }
      };
      const resetSelf = (effect) => () => setSelf(effect)(DEFAULT_VALUE$7);
      const onSet = (effect) => (handler) => {
        var _cleanupEffectsByStor2;
        const {
          release
        } = store.subscribeToTransactions((currentStore) => {
          var _currentTree$atomValu;
          let {
            currentTree,
            previousTree
          } = currentStore.getState();
          if (!previousTree) {
            Recoil_recoverableViolation("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil");
            previousTree = currentTree;
          }
          const newLoadable = (_currentTree$atomValu = currentTree.atomValues.get(key)) !== null && _currentTree$atomValu !== void 0 ? _currentTree$atomValu : defaultLoadable;
          if (newLoadable.state === "hasValue") {
            var _previousTree$atomVal, _pendingSetSelf, _pendingSetSelf2, _pendingSetSelf3;
            const newValue = newLoadable.contents;
            const oldLoadable = (_previousTree$atomVal = previousTree.atomValues.get(key)) !== null && _previousTree$atomVal !== void 0 ? _previousTree$atomVal : defaultLoadable;
            const oldValue = oldLoadable.state === "hasValue" ? oldLoadable.contents : DEFAULT_VALUE$7;
            if (((_pendingSetSelf = pendingSetSelf) === null || _pendingSetSelf === void 0 ? void 0 : _pendingSetSelf.effect) !== effect || ((_pendingSetSelf2 = pendingSetSelf) === null || _pendingSetSelf2 === void 0 ? void 0 : _pendingSetSelf2.value) !== newValue) {
              handler(newValue, oldValue, !currentTree.atomValues.has(key));
            } else if (((_pendingSetSelf3 = pendingSetSelf) === null || _pendingSetSelf3 === void 0 ? void 0 : _pendingSetSelf3.effect) === effect) {
              pendingSetSelf = null;
            }
          }
        }, key);
        cleanupEffectsByStore.set(store, [...(_cleanupEffectsByStor2 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor2 !== void 0 ? _cleanupEffectsByStor2 : [], release]);
      };
      for (const effect of effects) {
        try {
          const cleanup = effect({
            node,
            storeID: store.storeID,
            parentStoreID_UNSTABLE: store.parentStoreID,
            trigger,
            setSelf: setSelf(effect),
            resetSelf: resetSelf(effect),
            onSet: onSet(effect),
            getPromise,
            getLoadable,
            getInfo_UNSTABLE
          });
          if (cleanup != null) {
            var _cleanupEffectsByStor3;
            cleanupEffectsByStore.set(store, [...(_cleanupEffectsByStor3 = cleanupEffectsByStore.get(store)) !== null && _cleanupEffectsByStor3 !== void 0 ? _cleanupEffectsByStor3 : [], cleanup]);
          }
        } catch (error) {
          initValue = error;
          isInitError = true;
        }
      }
      isDuringInit = false;
      if (!(initValue instanceof DefaultValue$2)) {
        var _store$getState$nextT5;
        const initLoadable = isInitError ? loadableWithError$2(initValue) : Recoil_isPromise(initValue) ? loadableWithPromise$2(wrapPendingPromise(store, initValue)) : loadableWithValue$3(unwrap(initValue));
        maybeFreezeValueOrPromise(initLoadable.contents);
        initState.atomValues.set(key, initLoadable);
        (_store$getState$nextT5 = store.getState().nextTree) === null || _store$getState$nextT5 === void 0 ? void 0 : _store$getState$nextT5.atomValues.set(key, initLoadable);
      }
    }
    return cleanupAtom;
  }
  function peekAtom(_store, state) {
    var _ref, _state$atomValues$get3;
    return (_ref = (_state$atomValues$get3 = state.atomValues.get(key)) !== null && _state$atomValues$get3 !== void 0 ? _state$atomValues$get3 : cachedAnswerForUnvalidatedValue) !== null && _ref !== void 0 ? _ref : defaultLoadable;
  }
  function getAtom(_store, state) {
    if (state.atomValues.has(key)) {
      return Recoil_nullthrows(state.atomValues.get(key));
    } else if (state.nonvalidatedAtoms.has(key)) {
      if (cachedAnswerForUnvalidatedValue != null) {
        return cachedAnswerForUnvalidatedValue;
      }
      if (persistence == null) {
        Recoil_expectationViolation(`Tried to restore a persisted value for atom ${key} but it has no persistence settings.`);
        return defaultLoadable;
      }
      const nonvalidatedValue = state.nonvalidatedAtoms.get(key);
      const validatorResult = persistence.validator(nonvalidatedValue, DEFAULT_VALUE$7);
      const validatedValueLoadable = validatorResult instanceof DefaultValue$2 ? defaultLoadable : loadableWithValue$3(validatorResult);
      cachedAnswerForUnvalidatedValue = validatedValueLoadable;
      return cachedAnswerForUnvalidatedValue;
    } else {
      return defaultLoadable;
    }
  }
  function invalidateAtom() {
    cachedAnswerForUnvalidatedValue = void 0;
  }
  function setAtom(_store, state, newValue) {
    if (state.atomValues.has(key)) {
      const existing = Recoil_nullthrows(state.atomValues.get(key));
      if (existing.state === "hasValue" && newValue === existing.contents) {
        return /* @__PURE__ */ new Map();
      }
    } else if (!state.nonvalidatedAtoms.has(key) && newValue instanceof DefaultValue$2) {
      return /* @__PURE__ */ new Map();
    }
    maybeFreezeValueOrPromise(newValue);
    cachedAnswerForUnvalidatedValue = void 0;
    return (/* @__PURE__ */ new Map()).set(key, loadableWithValue$3(newValue));
  }
  function shouldDeleteConfigOnReleaseAtom() {
    return getConfigDeletionHandler$2(key) !== void 0 && liveStoresCount <= 0;
  }
  const node = registerNode$2({
    key,
    nodeType: "atom",
    peek: peekAtom,
    get: getAtom,
    set: setAtom,
    init: initAtom,
    invalidate: invalidateAtom,
    shouldDeleteConfigOnRelease: shouldDeleteConfigOnReleaseAtom,
    dangerouslyAllowMutability: options.dangerouslyAllowMutability,
    persistence_UNSTABLE: options.persistence_UNSTABLE ? {
      type: options.persistence_UNSTABLE.type,
      backButton: options.persistence_UNSTABLE.backButton
    } : void 0,
    shouldRestoreFromSnapshots: true,
    retainedBy
  });
  return node;
}
function atom(options) {
  if (true) {
    if (typeof options.key !== "string") {
      throw Recoil_err("A key option with a unique string value must be provided when creating an atom.");
    }
  }
  const {
    // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,
    ...restOptions
  } = options;
  const optionsDefault = "default" in options ? (
    // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined
    options.default
  ) : new Promise(() => {
  });
  if (isRecoilValue$4(optionsDefault)) {
    return atomWithFallback({
      ...restOptions,
      default: optionsDefault
      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS,
    });
  } else {
    return baseAtom({
      ...restOptions,
      default: optionsDefault
    });
  }
}
function atomWithFallback(options) {
  const base = atom({
    ...options,
    default: DEFAULT_VALUE$7,
    persistence_UNSTABLE: options.persistence_UNSTABLE === void 0 ? void 0 : {
      ...options.persistence_UNSTABLE,
      validator: (storedValue) => storedValue instanceof DefaultValue$2 ? storedValue : Recoil_nullthrows(options.persistence_UNSTABLE).validator(storedValue, DEFAULT_VALUE$7)
    },
    // TODO Hack for now.
    effects: options.effects,
    // flowlint-line unclear-type: off
    effects_UNSTABLE: options.effects_UNSTABLE
    // flowlint-line unclear-type: off
  });
  const sel = Recoil_selector({
    key: `${options.key}__withFallback`,
    get: ({
      get: get5
    }) => {
      const baseValue = get5(base);
      return baseValue instanceof DefaultValue$2 ? options.default : baseValue;
    },
    // $FlowFixMe[incompatible-call]
    set: ({
      set
    }, newValue) => set(base, newValue),
    // This selector does not need to cache as it is a wrapper selector
    // and the selector within the wrapper selector will have a cache
    // option by default
    cachePolicy_UNSTABLE: {
      eviction: "most-recent"
    },
    dangerouslyAllowMutability: options.dangerouslyAllowMutability
  });
  setConfigDeletionHandler$1(sel.key, getConfigDeletionHandler$2(options.key));
  return sel;
}
atom.value = (value) => new WrappedValue$2(value);
var Recoil_atom = atom;
var MapCache = class {
  constructor(options) {
    var _options$mapKey;
    _defineProperty(this, "_map", void 0);
    _defineProperty(this, "_keyMapper", void 0);
    this._map = /* @__PURE__ */ new Map();
    this._keyMapper = (_options$mapKey = options === null || options === void 0 ? void 0 : options.mapKey) !== null && _options$mapKey !== void 0 ? _options$mapKey : (v2) => v2;
  }
  size() {
    return this._map.size;
  }
  has(key) {
    return this._map.has(this._keyMapper(key));
  }
  get(key) {
    return this._map.get(this._keyMapper(key));
  }
  set(key, val) {
    this._map.set(this._keyMapper(key), val);
  }
  delete(key) {
    this._map.delete(this._keyMapper(key));
  }
  clear() {
    this._map.clear();
  }
};
var Recoil_MapCache = {
  MapCache
};
var Recoil_MapCache_1 = Recoil_MapCache.MapCache;
var Recoil_MapCache$1 = Object.freeze({
  __proto__: null,
  MapCache: Recoil_MapCache_1
});
var {
  LRUCache: LRUCache$2
} = Recoil_LRUCache$1;
var {
  MapCache: MapCache$1
} = Recoil_MapCache$1;
var defaultPolicy$1 = {
  equality: "reference",
  eviction: "none",
  maxSize: Infinity
};
function cacheFromPolicy({
  equality = defaultPolicy$1.equality,
  eviction = defaultPolicy$1.eviction,
  maxSize = defaultPolicy$1.maxSize
} = defaultPolicy$1) {
  const valueMapper = getValueMapper$1(equality);
  const cache = getCache(eviction, maxSize, valueMapper);
  return cache;
}
function getValueMapper$1(equality) {
  switch (equality) {
    case "reference":
      return (val) => val;
    case "value":
      return (val) => Recoil_stableStringify(val);
  }
  throw Recoil_err(`Unrecognized equality policy ${equality}`);
}
function getCache(eviction, maxSize, mapKey) {
  switch (eviction) {
    case "keep-all":
      return new MapCache$1({
        mapKey
      });
    case "lru":
      return new LRUCache$2({
        mapKey,
        maxSize: Recoil_nullthrows(maxSize)
      });
    case "most-recent":
      return new LRUCache$2({
        mapKey,
        maxSize: 1
      });
  }
  throw Recoil_err(`Unrecognized eviction policy ${eviction}`);
}
var Recoil_cacheFromPolicy = cacheFromPolicy;
var {
  setConfigDeletionHandler: setConfigDeletionHandler$2
} = Recoil_Node;
function atomFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;
  const atomCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : "value",
    eviction: "keep-all"
  });
  return (params) => {
    var _stableStringify, _options$effects;
    const cachedAtom = atomCache.get(params);
    if (cachedAtom != null) {
      return cachedAtom;
    }
    const {
      cachePolicyForParams_UNSTABLE,
      ...atomOptions
    } = options;
    const optionsDefault = "default" in options ? (
      // $FlowIssue[incompatible-type] No way to refine in Flow that property is not defined
      options.default
    ) : new Promise(() => {
    });
    const newAtom = Recoil_atom({
      ...atomOptions,
      key: `${options.key}__${(_stableStringify = Recoil_stableStringify(params)) !== null && _stableStringify !== void 0 ? _stableStringify : "void"}`,
      default: typeof optionsDefault === "function" ? (
        // The default was parameterized
        // Flow doesn't know that T isn't a function, so we need to case to any
        // $FlowIssue[incompatible-use]
        optionsDefault(params)
      ) : (
        // Default may be a static value, promise, or RecoilValue
        optionsDefault
      ),
      retainedBy_UNSTABLE: typeof options.retainedBy_UNSTABLE === "function" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE,
      effects: typeof options.effects === "function" ? options.effects(params) : typeof options.effects_UNSTABLE === "function" ? options.effects_UNSTABLE(params) : (_options$effects = options.effects) !== null && _options$effects !== void 0 ? _options$effects : options.effects_UNSTABLE
      // prettier-ignore
      // @fb-only: scopeRules_APPEND_ONLY_READ_THE_DOCS: mapScopeRules(
      // @fb-only: options.scopeRules_APPEND_ONLY_READ_THE_DOCS,
      // @fb-only: params,
      // @fb-only: ),
    });
    atomCache.set(params, newAtom);
    setConfigDeletionHandler$2(newAtom.key, () => {
      atomCache.delete(params);
    });
    return newAtom;
  };
}
var Recoil_atomFamily = atomFamily;
var {
  setConfigDeletionHandler: setConfigDeletionHandler$3
} = Recoil_Node;
var nextIndex = 0;
function selectorFamily(options) {
  var _options$cachePolicyF, _options$cachePolicyF2;
  const selectorCache = Recoil_cacheFromPolicy({
    equality: (_options$cachePolicyF = (_options$cachePolicyF2 = options.cachePolicyForParams_UNSTABLE) === null || _options$cachePolicyF2 === void 0 ? void 0 : _options$cachePolicyF2.equality) !== null && _options$cachePolicyF !== void 0 ? _options$cachePolicyF : "value",
    eviction: "keep-all"
  });
  return (params) => {
    var _stableStringify;
    let cachedSelector;
    try {
      cachedSelector = selectorCache.get(params);
    } catch (error) {
      throw Recoil_err(`Problem with cache lookup for selector ${options.key}: ${error.message}`);
    }
    if (cachedSelector != null) {
      return cachedSelector;
    }
    const myKey = `${options.key}__selectorFamily/${(_stableStringify = Recoil_stableStringify(params, {
      // It is possible to use functions in parameters if the user uses
      // a cache with reference equality thanks to the incrementing index.
      allowFunctions: true
    })) !== null && _stableStringify !== void 0 ? _stableStringify : "void"}/${nextIndex++}`;
    const myGet = (callbacks) => options.get(params)(callbacks);
    const myCachePolicy = options.cachePolicy_UNSTABLE;
    const retainedBy = typeof options.retainedBy_UNSTABLE === "function" ? options.retainedBy_UNSTABLE(params) : options.retainedBy_UNSTABLE;
    let newSelector;
    if (options.set != null) {
      const set = options.set;
      const mySet = (callbacks, newValue) => set(params)(callbacks, newValue);
      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        set: mySet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    } else {
      newSelector = Recoil_selector({
        key: myKey,
        get: myGet,
        cachePolicy_UNSTABLE: myCachePolicy,
        dangerouslyAllowMutability: options.dangerouslyAllowMutability,
        retainedBy_UNSTABLE: retainedBy
      });
    }
    selectorCache.set(params, newSelector);
    setConfigDeletionHandler$3(newSelector.key, () => {
      selectorCache.delete(params);
    });
    return newSelector;
  };
}
var Recoil_selectorFamily = selectorFamily;
var constantSelector = Recoil_selectorFamily({
  key: "__constant",
  get: (constant) => () => constant,
  cachePolicyForParams_UNSTABLE: {
    equality: "reference"
  }
});
function constSelector(constant) {
  return constantSelector(constant);
}
var Recoil_constSelector = constSelector;
var throwingSelector = Recoil_selectorFamily({
  key: "__error",
  get: (message) => () => {
    throw Recoil_err(message);
  },
  // TODO Why?
  cachePolicyForParams_UNSTABLE: {
    equality: "reference"
  }
});
function errorSelector(message) {
  return throwingSelector(message);
}
var Recoil_errorSelector = errorSelector;
function readOnlySelector(atom2) {
  return atom2;
}
var Recoil_readOnlySelector = readOnlySelector;
var {
  loadableWithError: loadableWithError$3,
  loadableWithPromise: loadableWithPromise$3,
  loadableWithValue: loadableWithValue$4
} = Recoil_Loadable$1;
function concurrentRequests(getRecoilValue, deps) {
  const results = Array(deps.length).fill(void 0);
  const exceptions = Array(deps.length).fill(void 0);
  for (const [i2, dep] of deps.entries()) {
    try {
      results[i2] = getRecoilValue(dep);
    } catch (e2) {
      exceptions[i2] = e2;
    }
  }
  return [results, exceptions];
}
function isError(exp) {
  return exp != null && !Recoil_isPromise(exp);
}
function unwrapDependencies(dependencies) {
  return Array.isArray(dependencies) ? dependencies : Object.getOwnPropertyNames(dependencies).map((key) => dependencies[key]);
}
function wrapResults(dependencies, results) {
  return Array.isArray(dependencies) ? results : (
    // Object.getOwnPropertyNames() has consistent key ordering with ES6
    Object.getOwnPropertyNames(dependencies).reduce((out, key, idx) => ({
      ...out,
      [key]: results[idx]
    }), {})
  );
}
function wrapLoadables(dependencies, results, exceptions) {
  const output = exceptions.map((exception, idx) => exception == null ? loadableWithValue$4(results[idx]) : Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
  return wrapResults(dependencies, output);
}
function combineAsyncResultsWithSyncResults(syncResults, asyncResults) {
  return asyncResults.map((result, idx) => (
    /**
     * it's important we use === undefined as opposed to == null, because the
     * resolved value of the async promise could be `null`, in which case we
     * don't want to use syncResults[idx], which would be undefined. If async
     * promise resolves to `undefined`, that's ok because `syncResults[idx]`
     * will also be `undefined`. That's a little hacky, but it works.
     */
    result === void 0 ? syncResults[idx] : result
  ));
}
var waitForNone = Recoil_selectorFamily({
  key: "__waitForNone",
  get: (dependencies) => ({
    get: get5
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get5, deps);
    return wrapLoadables(dependencies, results, exceptions);
  },
  dangerouslyAllowMutability: true
});
var waitForAny = Recoil_selectorFamily({
  key: "__waitForAny",
  get: (dependencies) => ({
    get: get5
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get5, deps);
    if (exceptions.some((exp) => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    }
    return new Promise((resolve) => {
      for (const [i2, exp] of exceptions.entries()) {
        if (Recoil_isPromise(exp)) {
          exp.then((result) => {
            results[i2] = result;
            exceptions[i2] = void 0;
            resolve(wrapLoadables(dependencies, results, exceptions));
          }).catch((error) => {
            exceptions[i2] = error;
            resolve(wrapLoadables(dependencies, results, exceptions));
          });
        }
      }
    });
  },
  dangerouslyAllowMutability: true
});
var waitForAll = Recoil_selectorFamily({
  key: "__waitForAll",
  get: (dependencies) => ({
    get: get5
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get5, deps);
    if (exceptions.every((exp) => exp == null)) {
      return wrapResults(dependencies, results);
    }
    const error = exceptions.find(isError);
    if (error != null) {
      throw error;
    }
    return Promise.all(exceptions).then((exceptionResults) => wrapResults(dependencies, combineAsyncResultsWithSyncResults(results, exceptionResults)));
  },
  dangerouslyAllowMutability: true
});
var waitForAllSettled = Recoil_selectorFamily({
  key: "__waitForAllSettled",
  get: (dependencies) => ({
    get: get5
  }) => {
    const deps = unwrapDependencies(dependencies);
    const [results, exceptions] = concurrentRequests(get5, deps);
    if (exceptions.every((exp) => !Recoil_isPromise(exp))) {
      return wrapLoadables(dependencies, results, exceptions);
    }
    return Promise.all(exceptions.map((exp, i2) => Recoil_isPromise(exp) ? exp.then((result) => {
      results[i2] = result;
      exceptions[i2] = void 0;
    }).catch((error) => {
      results[i2] = void 0;
      exceptions[i2] = error;
    }) : null)).then(() => wrapLoadables(dependencies, results, exceptions));
  },
  dangerouslyAllowMutability: true
});
var noWait = Recoil_selectorFamily({
  key: "__noWait",
  get: (dependency) => ({
    get: get5
  }) => {
    try {
      return Recoil_selector.value(loadableWithValue$4(get5(dependency)));
    } catch (exception) {
      return Recoil_selector.value(Recoil_isPromise(exception) ? loadableWithPromise$3(exception) : loadableWithError$3(exception));
    }
  },
  dangerouslyAllowMutability: true
});
var Recoil_WaitFor = {
  waitForNone,
  waitForAny,
  waitForAll,
  waitForAllSettled,
  noWait
};
var {
  RecoilLoadable
} = Recoil_Loadable$1;
var {
  DefaultValue: DefaultValue$3
} = Recoil_Node;
var {
  RecoilRoot: RecoilRoot$2,
  useRecoilStoreID: useRecoilStoreID$1
} = Recoil_RecoilRoot;
var {
  isRecoilValue: isRecoilValue$5
} = Recoil_RecoilValue$1;
var {
  retentionZone: retentionZone$1
} = Recoil_RetentionZone;
var {
  freshSnapshot: freshSnapshot$2
} = Recoil_Snapshot$1;
var {
  useRecoilState: useRecoilState$1,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useRecoilValue: useRecoilValue$1,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,
  useResetRecoilState: useResetRecoilState$1,
  useSetRecoilState: useSetRecoilState$1
} = Recoil_Hooks;
var {
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilTransactionObserver: useRecoilTransactionObserver$1
} = Recoil_SnapshotHooks;
var {
  useRecoilCallback: useRecoilCallback$1
} = Recoil_useRecoilCallback;
var {
  noWait: noWait$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  waitForAny: waitForAny$1,
  waitForNone: waitForNone$1
} = Recoil_WaitFor;
var Recoil_index = {
  // Types
  DefaultValue: DefaultValue$3,
  isRecoilValue: isRecoilValue$5,
  RecoilLoadable,
  // Global Recoil environment settiongs
  RecoilEnv: Recoil_RecoilEnv,
  // Recoil Root
  RecoilRoot: RecoilRoot$2,
  useRecoilStoreID: useRecoilStoreID$1,
  useRecoilBridgeAcrossReactRoots_UNSTABLE: Recoil_useRecoilBridgeAcrossReactRoots,
  // Atoms/Selectors
  atom: Recoil_atom,
  selector: Recoil_selector,
  // Convenience Atoms/Selectors
  atomFamily: Recoil_atomFamily,
  selectorFamily: Recoil_selectorFamily,
  constSelector: Recoil_constSelector,
  errorSelector: Recoil_errorSelector,
  readOnlySelector: Recoil_readOnlySelector,
  // Concurrency Helpers for Atoms/Selectors
  noWait: noWait$1,
  waitForNone: waitForNone$1,
  waitForAny: waitForAny$1,
  waitForAll: waitForAll$1,
  waitForAllSettled: waitForAllSettled$1,
  // Hooks for Atoms/Selectors
  useRecoilValue: useRecoilValue$1,
  useRecoilValueLoadable: useRecoilValueLoadable$1,
  useRecoilState: useRecoilState$1,
  useRecoilStateLoadable: useRecoilStateLoadable$1,
  useSetRecoilState: useSetRecoilState$1,
  useResetRecoilState: useResetRecoilState$1,
  useGetRecoilValueInfo_UNSTABLE: Recoil_useGetRecoilValueInfo,
  useRecoilRefresher_UNSTABLE: Recoil_useRecoilRefresher,
  useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE: useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilValue_TRANSITION_SUPPORT_UNSTABLE: useRecoilValue_TRANSITION_SUPPORT_UNSTABLE$1,
  useRecoilState_TRANSITION_SUPPORT_UNSTABLE: useRecoilState_TRANSITION_SUPPORT_UNSTABLE$1,
  // Hooks for complex operations
  useRecoilCallback: useRecoilCallback$1,
  useRecoilTransaction_UNSTABLE: Recoil_useRecoilTransaction,
  // Snapshots
  useGotoRecoilSnapshot: useGotoRecoilSnapshot$1,
  useRecoilSnapshot: useRecoilSnapshot$1,
  useRecoilTransactionObserver_UNSTABLE: useRecoilTransactionObserver$1,
  snapshot_UNSTABLE: freshSnapshot$2,
  // Memory Management
  useRetain: Recoil_useRetain,
  retentionZone: retentionZone$1
};
var Recoil_index_1 = Recoil_index.DefaultValue;
var Recoil_index_2 = Recoil_index.isRecoilValue;
var Recoil_index_3 = Recoil_index.RecoilLoadable;
var Recoil_index_4 = Recoil_index.RecoilEnv;
var Recoil_index_5 = Recoil_index.RecoilRoot;
var Recoil_index_6 = Recoil_index.useRecoilStoreID;
var Recoil_index_7 = Recoil_index.useRecoilBridgeAcrossReactRoots_UNSTABLE;
var Recoil_index_8 = Recoil_index.atom;
var Recoil_index_9 = Recoil_index.selector;
var Recoil_index_10 = Recoil_index.atomFamily;
var Recoil_index_11 = Recoil_index.selectorFamily;
var Recoil_index_12 = Recoil_index.constSelector;
var Recoil_index_13 = Recoil_index.errorSelector;
var Recoil_index_14 = Recoil_index.readOnlySelector;
var Recoil_index_15 = Recoil_index.noWait;
var Recoil_index_16 = Recoil_index.waitForNone;
var Recoil_index_17 = Recoil_index.waitForAny;
var Recoil_index_18 = Recoil_index.waitForAll;
var Recoil_index_19 = Recoil_index.waitForAllSettled;
var Recoil_index_20 = Recoil_index.useRecoilValue;
var Recoil_index_21 = Recoil_index.useRecoilValueLoadable;
var Recoil_index_22 = Recoil_index.useRecoilState;
var Recoil_index_23 = Recoil_index.useRecoilStateLoadable;
var Recoil_index_24 = Recoil_index.useSetRecoilState;
var Recoil_index_25 = Recoil_index.useResetRecoilState;
var Recoil_index_26 = Recoil_index.useGetRecoilValueInfo_UNSTABLE;
var Recoil_index_27 = Recoil_index.useRecoilRefresher_UNSTABLE;
var Recoil_index_28 = Recoil_index.useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE;
var Recoil_index_29 = Recoil_index.useRecoilValue_TRANSITION_SUPPORT_UNSTABLE;
var Recoil_index_30 = Recoil_index.useRecoilState_TRANSITION_SUPPORT_UNSTABLE;
var Recoil_index_31 = Recoil_index.useRecoilCallback;
var Recoil_index_32 = Recoil_index.useRecoilTransaction_UNSTABLE;
var Recoil_index_33 = Recoil_index.useGotoRecoilSnapshot;
var Recoil_index_34 = Recoil_index.useRecoilSnapshot;
var Recoil_index_35 = Recoil_index.useRecoilTransactionObserver_UNSTABLE;
var Recoil_index_36 = Recoil_index.snapshot_UNSTABLE;
var Recoil_index_37 = Recoil_index.useRetain;
var Recoil_index_38 = Recoil_index.retentionZone;

// node_modules/@daily-co/daily-react/dist/daily-react.esm.js
var import_lodash = __toESM(require_lodash());

// node_modules/@daily-co/daily-js/dist/daily-esm.js
function e(e2, t2) {
  if (null == e2) return {};
  var n2, r2, i2 = function(e3, t3) {
    if (null == e3) return {};
    var n3, r3, i3 = {}, o3 = Object.keys(e3);
    for (r3 = 0; r3 < o3.length; r3++) n3 = o3[r3], t3.indexOf(n3) >= 0 || (i3[n3] = e3[n3]);
    return i3;
  }(e2, t2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    for (r2 = 0; r2 < o2.length; r2++) n2 = o2[r2], t2.indexOf(n2) >= 0 || Object.prototype.propertyIsEnumerable.call(e2, n2) && (i2[n2] = e2[n2]);
  }
  return i2;
}
function t(e2, t2) {
  if (!(e2 instanceof t2)) throw new TypeError("Cannot call a class as a function");
}
function n(e2) {
  return n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
    return typeof e3;
  } : function(e3) {
    return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
  }, n(e2);
}
function r(e2) {
  var t2 = function(e3, t3) {
    if ("object" !== n(e3) || null === e3) return e3;
    var r2 = e3[Symbol.toPrimitive];
    if (void 0 !== r2) {
      var i2 = r2.call(e3, t3 || "default");
      if ("object" !== n(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t3 ? String : Number)(e3);
  }(e2, "string");
  return "symbol" === n(t2) ? t2 : String(t2);
}
function i(e2, t2) {
  for (var n2 = 0; n2 < t2.length; n2++) {
    var i2 = t2[n2];
    i2.enumerable = i2.enumerable || false, i2.configurable = true, "value" in i2 && (i2.writable = true), Object.defineProperty(e2, r(i2.key), i2);
  }
}
function o(e2, t2, n2) {
  return t2 && i(e2.prototype, t2), n2 && i(e2, n2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
}
function a(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}
function s(e2, t2) {
  return s = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
    return e3.__proto__ = t3, e3;
  }, s(e2, t2);
}
function c(e2, t2) {
  if ("function" != typeof t2 && null !== t2) throw new TypeError("Super expression must either be null or a function");
  e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t2 && s(e2, t2);
}
function l(e2, t2) {
  if (t2 && ("object" === n(t2) || "function" == typeof t2)) return t2;
  if (void 0 !== t2) throw new TypeError("Derived constructors may only return object or undefined");
  return a(e2);
}
function u(e2) {
  return u = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e3) {
    return e3.__proto__ || Object.getPrototypeOf(e3);
  }, u(e2);
}
function d(e2, t2, n2) {
  return (t2 = r(t2)) in e2 ? Object.defineProperty(e2, t2, { value: n2, enumerable: true, configurable: true, writable: true }) : e2[t2] = n2, e2;
}
function h(e2, t2, n2, r2, i2, o2, a2) {
  try {
    var s2 = e2[o2](a2), c2 = s2.value;
  } catch (e3) {
    return void n2(e3);
  }
  s2.done ? t2(c2) : Promise.resolve(c2).then(r2, i2);
}
function p(e2) {
  return function() {
    var t2 = this, n2 = arguments;
    return new Promise(function(r2, i2) {
      var o2 = e2.apply(t2, n2);
      function a2(e3) {
        h(o2, r2, i2, a2, s2, "next", e3);
      }
      function s2(e3) {
        h(o2, r2, i2, a2, s2, "throw", e3);
      }
      a2(void 0);
    });
  };
}
function f(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++) r2[n2] = e2[n2];
  return r2;
}
function g(e2, t2) {
  return function(e3) {
    if (Array.isArray(e3)) return e3;
  }(e2) || function(e3, t3) {
    var n2 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
    if (null != n2) {
      var r2, i2, o2, a2, s2 = [], c2 = true, l2 = false;
      try {
        if (o2 = (n2 = n2.call(e3)).next, 0 === t3) {
          if (Object(n2) !== n2) return;
          c2 = false;
        } else for (; !(c2 = (r2 = o2.call(n2)).done) && (s2.push(r2.value), s2.length !== t3); c2 = true) ;
      } catch (e4) {
        l2 = true, i2 = e4;
      } finally {
        try {
          if (!c2 && null != n2.return && (a2 = n2.return(), Object(a2) !== a2)) return;
        } finally {
          if (l2) throw i2;
        }
      }
      return s2;
    }
  }(e2, t2) || function(e3, t3) {
    if (e3) {
      if ("string" == typeof e3) return f(e3, t3);
      var n2 = Object.prototype.toString.call(e3).slice(8, -1);
      return "Object" === n2 && e3.constructor && (n2 = e3.constructor.name), "Map" === n2 || "Set" === n2 ? Array.from(e3) : "Arguments" === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2) ? f(e3, t3) : void 0;
    }
  }(e2, t2) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
var v;
var m = {};
var y = { get exports() {
  return m;
}, set exports(e2) {
  m = e2;
} };
var _ = "object" == typeof Reflect ? Reflect : null;
var b = _ && "function" == typeof _.apply ? _.apply : function(e2, t2, n2) {
  return Function.prototype.apply.call(e2, t2, n2);
};
v = _ && "function" == typeof _.ownKeys ? _.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
  return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
} : function(e2) {
  return Object.getOwnPropertyNames(e2);
};
var w = Number.isNaN || function(e2) {
  return e2 != e2;
};
function S() {
  S.init.call(this);
}
y.exports = S, m.once = function(e2, t2) {
  return new Promise(function(n2, r2) {
    function i2(n3) {
      e2.removeListener(t2, o2), r2(n3);
    }
    function o2() {
      "function" == typeof e2.removeListener && e2.removeListener("error", i2), n2([].slice.call(arguments));
    }
    j(e2, t2, o2, { once: true }), "error" !== t2 && function(e3, t3, n3) {
      "function" == typeof e3.on && j(e3, "error", t3, n3);
    }(e2, i2, { once: true });
  });
}, S.EventEmitter = S, S.prototype._events = void 0, S.prototype._eventsCount = 0, S.prototype._maxListeners = void 0;
var k = 10;
function E(e2) {
  if ("function" != typeof e2) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
}
function C(e2) {
  return void 0 === e2._maxListeners ? S.defaultMaxListeners : e2._maxListeners;
}
function M(e2, t2, n2, r2) {
  var i2, o2, a2, s2;
  if (E(n2), void 0 === (o2 = e2._events) ? (o2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== o2.newListener && (e2.emit("newListener", t2, n2.listener ? n2.listener : n2), o2 = e2._events), a2 = o2[t2]), void 0 === a2) a2 = o2[t2] = n2, ++e2._eventsCount;
  else if ("function" == typeof a2 ? a2 = o2[t2] = r2 ? [n2, a2] : [a2, n2] : r2 ? a2.unshift(n2) : a2.push(n2), (i2 = C(e2)) > 0 && a2.length > i2 && !a2.warned) {
    a2.warned = true;
    var c2 = new Error("Possible EventEmitter memory leak detected. " + a2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c2.name = "MaxListenersExceededWarning", c2.emitter = e2, c2.type = t2, c2.count = a2.length, s2 = c2, console && console.warn && console.warn(s2);
  }
  return e2;
}
function T() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function O(e2, t2, n2) {
  var r2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: n2 }, i2 = T.bind(r2);
  return i2.listener = n2, r2.wrapFn = i2, i2;
}
function P(e2, t2, n2) {
  var r2 = e2._events;
  if (void 0 === r2) return [];
  var i2 = r2[t2];
  return void 0 === i2 ? [] : "function" == typeof i2 ? n2 ? [i2.listener || i2] : [i2] : n2 ? function(e3) {
    for (var t3 = new Array(e3.length), n3 = 0; n3 < t3.length; ++n3) t3[n3] = e3[n3].listener || e3[n3];
    return t3;
  }(i2) : D(i2, i2.length);
}
function A(e2) {
  var t2 = this._events;
  if (void 0 !== t2) {
    var n2 = t2[e2];
    if ("function" == typeof n2) return 1;
    if (void 0 !== n2) return n2.length;
  }
  return 0;
}
function D(e2, t2) {
  for (var n2 = new Array(t2), r2 = 0; r2 < t2; ++r2) n2[r2] = e2[r2];
  return n2;
}
function j(e2, t2, n2, r2) {
  if ("function" == typeof e2.on) r2.once ? e2.once(t2, n2) : e2.on(t2, n2);
  else {
    if ("function" != typeof e2.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
    e2.addEventListener(t2, function i2(o2) {
      r2.once && e2.removeEventListener(t2, i2), n2(o2);
    });
  }
}
Object.defineProperty(S, "defaultMaxListeners", { enumerable: true, get: function() {
  return k;
}, set: function(e2) {
  if ("number" != typeof e2 || e2 < 0 || w(e2)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
  k = e2;
} }), S.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, S.prototype.setMaxListeners = function(e2) {
  if ("number" != typeof e2 || e2 < 0 || w(e2)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
  return this._maxListeners = e2, this;
}, S.prototype.getMaxListeners = function() {
  return C(this);
}, S.prototype.emit = function(e2) {
  for (var t2 = [], n2 = 1; n2 < arguments.length; n2++) t2.push(arguments[n2]);
  var r2 = "error" === e2, i2 = this._events;
  if (void 0 !== i2) r2 = r2 && void 0 === i2.error;
  else if (!r2) return false;
  if (r2) {
    var o2;
    if (t2.length > 0 && (o2 = t2[0]), o2 instanceof Error) throw o2;
    var a2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
    throw a2.context = o2, a2;
  }
  var s2 = i2[e2];
  if (void 0 === s2) return false;
  if ("function" == typeof s2) b(s2, this, t2);
  else {
    var c2 = s2.length, l2 = D(s2, c2);
    for (n2 = 0; n2 < c2; ++n2) b(l2[n2], this, t2);
  }
  return true;
}, S.prototype.addListener = function(e2, t2) {
  return M(this, e2, t2, false);
}, S.prototype.on = S.prototype.addListener, S.prototype.prependListener = function(e2, t2) {
  return M(this, e2, t2, true);
}, S.prototype.once = function(e2, t2) {
  return E(t2), this.on(e2, O(this, e2, t2)), this;
}, S.prototype.prependOnceListener = function(e2, t2) {
  return E(t2), this.prependListener(e2, O(this, e2, t2)), this;
}, S.prototype.removeListener = function(e2, t2) {
  var n2, r2, i2, o2, a2;
  if (E(t2), void 0 === (r2 = this._events)) return this;
  if (void 0 === (n2 = r2[e2])) return this;
  if (n2 === t2 || n2.listener === t2) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r2[e2], r2.removeListener && this.emit("removeListener", e2, n2.listener || t2));
  else if ("function" != typeof n2) {
    for (i2 = -1, o2 = n2.length - 1; o2 >= 0; o2--) if (n2[o2] === t2 || n2[o2].listener === t2) {
      a2 = n2[o2].listener, i2 = o2;
      break;
    }
    if (i2 < 0) return this;
    0 === i2 ? n2.shift() : function(e3, t3) {
      for (; t3 + 1 < e3.length; t3++) e3[t3] = e3[t3 + 1];
      e3.pop();
    }(n2, i2), 1 === n2.length && (r2[e2] = n2[0]), void 0 !== r2.removeListener && this.emit("removeListener", e2, a2 || t2);
  }
  return this;
}, S.prototype.off = S.prototype.removeListener, S.prototype.removeAllListeners = function(e2) {
  var t2, n2, r2;
  if (void 0 === (n2 = this._events)) return this;
  if (void 0 === n2.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n2[e2]), this;
  if (0 === arguments.length) {
    var i2, o2 = Object.keys(n2);
    for (r2 = 0; r2 < o2.length; ++r2) "removeListener" !== (i2 = o2[r2]) && this.removeAllListeners(i2);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t2 = n2[e2])) this.removeListener(e2, t2);
  else if (void 0 !== t2) for (r2 = t2.length - 1; r2 >= 0; r2--) this.removeListener(e2, t2[r2]);
  return this;
}, S.prototype.listeners = function(e2) {
  return P(this, e2, true);
}, S.prototype.rawListeners = function(e2) {
  return P(this, e2, false);
}, S.listenerCount = function(e2, t2) {
  return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : A.call(e2, t2);
}, S.prototype.listenerCount = A, S.prototype.eventNames = function() {
  return this._eventsCount > 0 ? v(this._events) : [];
};
var x = Object.prototype.hasOwnProperty;
function L(e2, t2, n2) {
  for (n2 of e2.keys()) if (I(n2, t2)) return n2;
}
function I(e2, t2) {
  var n2, r2, i2;
  if (e2 === t2) return true;
  if (e2 && t2 && (n2 = e2.constructor) === t2.constructor) {
    if (n2 === Date) return e2.getTime() === t2.getTime();
    if (n2 === RegExp) return e2.toString() === t2.toString();
    if (n2 === Array) {
      if ((r2 = e2.length) === t2.length) for (; r2-- && I(e2[r2], t2[r2]); ) ;
      return -1 === r2;
    }
    if (n2 === Set) {
      if (e2.size !== t2.size) return false;
      for (r2 of e2) {
        if ((i2 = r2) && "object" == typeof i2 && !(i2 = L(t2, i2))) return false;
        if (!t2.has(i2)) return false;
      }
      return true;
    }
    if (n2 === Map) {
      if (e2.size !== t2.size) return false;
      for (r2 of e2) {
        if ((i2 = r2[0]) && "object" == typeof i2 && !(i2 = L(t2, i2))) return false;
        if (!I(r2[1], t2.get(i2))) return false;
      }
      return true;
    }
    if (n2 === ArrayBuffer) e2 = new Uint8Array(e2), t2 = new Uint8Array(t2);
    else if (n2 === DataView) {
      if ((r2 = e2.byteLength) === t2.byteLength) for (; r2-- && e2.getInt8(r2) === t2.getInt8(r2); ) ;
      return -1 === r2;
    }
    if (ArrayBuffer.isView(e2)) {
      if ((r2 = e2.byteLength) === t2.byteLength) for (; r2-- && e2[r2] === t2[r2]; ) ;
      return -1 === r2;
    }
    if (!n2 || "object" == typeof e2) {
      for (n2 in r2 = 0, e2) {
        if (x.call(e2, n2) && ++r2 && !x.call(t2, n2)) return false;
        if (!(n2 in t2) || !I(e2[n2], t2[n2])) return false;
      }
      return Object.keys(t2).length === r2;
    }
  }
  return e2 != e2 && t2 != t2;
}
var N = { "Amazon Silk": "amazon_silk", "Android Browser": "android", Bada: "bada", BlackBerry: "blackberry", Chrome: "chrome", Chromium: "chromium", Electron: "electron", Epiphany: "epiphany", Firefox: "firefox", Focus: "focus", Generic: "generic", "Google Search": "google_search", Googlebot: "googlebot", "Internet Explorer": "ie", "K-Meleon": "k_meleon", Maxthon: "maxthon", "Microsoft Edge": "edge", "MZ Browser": "mz", "NAVER Whale Browser": "naver", Opera: "opera", "Opera Coast": "opera_coast", PhantomJS: "phantomjs", Puffin: "puffin", QupZilla: "qupzilla", QQ: "qq", QQLite: "qqlite", Safari: "safari", Sailfish: "sailfish", "Samsung Internet for Android": "samsung_internet", SeaMonkey: "seamonkey", Sleipnir: "sleipnir", Swing: "swing", Tizen: "tizen", "UC Browser": "uc", Vivaldi: "vivaldi", "WebOS Browser": "webos", WeChat: "wechat", "Yandex Browser": "yandex", Roku: "roku" };
var R = { amazon_silk: "Amazon Silk", android: "Android Browser", bada: "Bada", blackberry: "BlackBerry", chrome: "Chrome", chromium: "Chromium", electron: "Electron", epiphany: "Epiphany", firefox: "Firefox", focus: "Focus", generic: "Generic", googlebot: "Googlebot", google_search: "Google Search", ie: "Internet Explorer", k_meleon: "K-Meleon", maxthon: "Maxthon", edge: "Microsoft Edge", mz: "MZ Browser", naver: "NAVER Whale Browser", opera: "Opera", opera_coast: "Opera Coast", phantomjs: "PhantomJS", puffin: "Puffin", qupzilla: "QupZilla", qq: "QQ Browser", qqlite: "QQ Browser Lite", safari: "Safari", sailfish: "Sailfish", samsung_internet: "Samsung Internet for Android", seamonkey: "SeaMonkey", sleipnir: "Sleipnir", swing: "Swing", tizen: "Tizen", uc: "UC Browser", vivaldi: "Vivaldi", webos: "WebOS Browser", wechat: "WeChat", yandex: "Yandex Browser" };
var B = { tablet: "tablet", mobile: "mobile", desktop: "desktop", tv: "tv" };
var F = { WindowsPhone: "Windows Phone", Windows: "Windows", MacOS: "macOS", iOS: "iOS", Android: "Android", WebOS: "WebOS", BlackBerry: "BlackBerry", Bada: "Bada", Tizen: "Tizen", Linux: "Linux", ChromeOS: "Chrome OS", PlayStation4: "PlayStation 4", Roku: "Roku" };
var U = { EdgeHTML: "EdgeHTML", Blink: "Blink", Trident: "Trident", Presto: "Presto", Gecko: "Gecko", WebKit: "WebKit" };
var V = class _V {
  static getFirstMatch(e2, t2) {
    const n2 = t2.match(e2);
    return n2 && n2.length > 0 && n2[1] || "";
  }
  static getSecondMatch(e2, t2) {
    const n2 = t2.match(e2);
    return n2 && n2.length > 1 && n2[2] || "";
  }
  static matchAndReturnConst(e2, t2, n2) {
    if (e2.test(t2)) return n2;
  }
  static getWindowsVersionName(e2) {
    switch (e2) {
      case "NT":
        return "NT";
      case "XP":
      case "NT 5.1":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  static getMacOSVersionName(e2) {
    const t2 = e2.split(".").splice(0, 2).map((e3) => parseInt(e3, 10) || 0);
    if (t2.push(0), 10 === t2[0]) switch (t2[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return;
    }
  }
  static getAndroidVersionName(e2) {
    const t2 = e2.split(".").splice(0, 2).map((e3) => parseInt(e3, 10) || 0);
    if (t2.push(0), !(1 === t2[0] && t2[1] < 5)) return 1 === t2[0] && t2[1] < 6 ? "Cupcake" : 1 === t2[0] && t2[1] >= 6 ? "Donut" : 2 === t2[0] && t2[1] < 2 ? "Eclair" : 2 === t2[0] && 2 === t2[1] ? "Froyo" : 2 === t2[0] && t2[1] > 2 ? "Gingerbread" : 3 === t2[0] ? "Honeycomb" : 4 === t2[0] && t2[1] < 1 ? "Ice Cream Sandwich" : 4 === t2[0] && t2[1] < 4 ? "Jelly Bean" : 4 === t2[0] && t2[1] >= 4 ? "KitKat" : 5 === t2[0] ? "Lollipop" : 6 === t2[0] ? "Marshmallow" : 7 === t2[0] ? "Nougat" : 8 === t2[0] ? "Oreo" : 9 === t2[0] ? "Pie" : void 0;
  }
  static getVersionPrecision(e2) {
    return e2.split(".").length;
  }
  static compareVersions(e2, t2, n2 = false) {
    const r2 = _V.getVersionPrecision(e2), i2 = _V.getVersionPrecision(t2);
    let o2 = Math.max(r2, i2), a2 = 0;
    const s2 = _V.map([e2, t2], (e3) => {
      const t3 = o2 - _V.getVersionPrecision(e3), n3 = e3 + new Array(t3 + 1).join(".0");
      return _V.map(n3.split("."), (e4) => new Array(20 - e4.length).join("0") + e4).reverse();
    });
    for (n2 && (a2 = o2 - Math.min(r2, i2)), o2 -= 1; o2 >= a2; ) {
      if (s2[0][o2] > s2[1][o2]) return 1;
      if (s2[0][o2] === s2[1][o2]) {
        if (o2 === a2) return 0;
        o2 -= 1;
      } else if (s2[0][o2] < s2[1][o2]) return -1;
    }
  }
  static map(e2, t2) {
    const n2 = [];
    let r2;
    if (Array.prototype.map) return Array.prototype.map.call(e2, t2);
    for (r2 = 0; r2 < e2.length; r2 += 1) n2.push(t2(e2[r2]));
    return n2;
  }
  static find(e2, t2) {
    let n2, r2;
    if (Array.prototype.find) return Array.prototype.find.call(e2, t2);
    for (n2 = 0, r2 = e2.length; n2 < r2; n2 += 1) {
      const r3 = e2[n2];
      if (t2(r3, n2)) return r3;
    }
  }
  static assign(e2, ...t2) {
    const n2 = e2;
    let r2, i2;
    if (Object.assign) return Object.assign(e2, ...t2);
    for (r2 = 0, i2 = t2.length; r2 < i2; r2 += 1) {
      const e3 = t2[r2];
      if ("object" == typeof e3 && null !== e3) {
        Object.keys(e3).forEach((t3) => {
          n2[t3] = e3[t3];
        });
      }
    }
    return e2;
  }
  static getBrowserAlias(e2) {
    return N[e2];
  }
  static getBrowserTypeByAlias(e2) {
    return R[e2] || "";
  }
};
var J = /version\/(\d+(\.?_?\d+)+)/i;
var $ = [{ test: [/googlebot/i], describe(e2) {
  const t2 = { name: "Googlebot" }, n2 = V.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/opera/i], describe(e2) {
  const t2 = { name: "Opera" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/opr\/|opios/i], describe(e2) {
  const t2 = { name: "Opera" }, n2 = V.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/SamsungBrowser/i], describe(e2) {
  const t2 = { name: "Samsung Internet for Android" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/Whale/i], describe(e2) {
  const t2 = { name: "NAVER Whale Browser" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/MZBrowser/i], describe(e2) {
  const t2 = { name: "MZ Browser" }, n2 = V.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/focus/i], describe(e2) {
  const t2 = { name: "Focus" }, n2 = V.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/swing/i], describe(e2) {
  const t2 = { name: "Swing" }, n2 = V.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/coast/i], describe(e2) {
  const t2 = { name: "Opera Coast" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/opt\/\d+(?:.?_?\d+)+/i], describe(e2) {
  const t2 = { name: "Opera Touch" }, n2 = V.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/yabrowser/i], describe(e2) {
  const t2 = { name: "Yandex Browser" }, n2 = V.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/ucbrowser/i], describe(e2) {
  const t2 = { name: "UC Browser" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/Maxthon|mxios/i], describe(e2) {
  const t2 = { name: "Maxthon" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/epiphany/i], describe(e2) {
  const t2 = { name: "Epiphany" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/puffin/i], describe(e2) {
  const t2 = { name: "Puffin" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/sleipnir/i], describe(e2) {
  const t2 = { name: "Sleipnir" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/k-meleon/i], describe(e2) {
  const t2 = { name: "K-Meleon" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/micromessenger/i], describe(e2) {
  const t2 = { name: "WeChat" }, n2 = V.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/qqbrowser/i], describe(e2) {
  const t2 = { name: /qqbrowserlite/i.test(e2) ? "QQ Browser Lite" : "QQ Browser" }, n2 = V.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/msie|trident/i], describe(e2) {
  const t2 = { name: "Internet Explorer" }, n2 = V.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/\sedg\//i], describe(e2) {
  const t2 = { name: "Microsoft Edge" }, n2 = V.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/edg([ea]|ios)/i], describe(e2) {
  const t2 = { name: "Microsoft Edge" }, n2 = V.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/vivaldi/i], describe(e2) {
  const t2 = { name: "Vivaldi" }, n2 = V.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/seamonkey/i], describe(e2) {
  const t2 = { name: "SeaMonkey" }, n2 = V.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/sailfish/i], describe(e2) {
  const t2 = { name: "Sailfish" }, n2 = V.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/silk/i], describe(e2) {
  const t2 = { name: "Amazon Silk" }, n2 = V.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/phantom/i], describe(e2) {
  const t2 = { name: "PhantomJS" }, n2 = V.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/slimerjs/i], describe(e2) {
  const t2 = { name: "SlimerJS" }, n2 = V.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e2) {
  const t2 = { name: "BlackBerry" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/(web|hpw)[o0]s/i], describe(e2) {
  const t2 = { name: "WebOS Browser" }, n2 = V.getFirstMatch(J, e2) || V.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/bada/i], describe(e2) {
  const t2 = { name: "Bada" }, n2 = V.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/tizen/i], describe(e2) {
  const t2 = { name: "Tizen" }, n2 = V.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/qupzilla/i], describe(e2) {
  const t2 = { name: "QupZilla" }, n2 = V.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/firefox|iceweasel|fxios/i], describe(e2) {
  const t2 = { name: "Firefox" }, n2 = V.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/electron/i], describe(e2) {
  const t2 = { name: "Electron" }, n2 = V.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/MiuiBrowser/i], describe(e2) {
  const t2 = { name: "Miui" }, n2 = V.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/chromium/i], describe(e2) {
  const t2 = { name: "Chromium" }, n2 = V.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, e2) || V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/chrome|crios|crmo/i], describe(e2) {
  const t2 = { name: "Chrome" }, n2 = V.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/GSA/i], describe(e2) {
  const t2 = { name: "Google Search" }, n2 = V.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test(e2) {
  const t2 = !e2.test(/like android/i), n2 = e2.test(/android/i);
  return t2 && n2;
}, describe(e2) {
  const t2 = { name: "Android Browser" }, n2 = V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/playstation 4/i], describe(e2) {
  const t2 = { name: "PlayStation 4" }, n2 = V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/safari|applewebkit/i], describe(e2) {
  const t2 = { name: "Safari" }, n2 = V.getFirstMatch(J, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/.*/i], describe(e2) {
  const t2 = -1 !== e2.search("\\(") ? /^(.*)\/(.*)[ \t]\((.*)/ : /^(.*)\/(.*) /;
  return { name: V.getFirstMatch(t2, e2), version: V.getSecondMatch(t2, e2) };
} }];
var G = [{ test: [/Roku\/DVP/], describe(e2) {
  const t2 = V.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, e2);
  return { name: F.Roku, version: t2 };
} }, { test: [/windows phone/i], describe(e2) {
  const t2 = V.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, e2);
  return { name: F.WindowsPhone, version: t2 };
} }, { test: [/windows /i], describe(e2) {
  const t2 = V.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, e2), n2 = V.getWindowsVersionName(t2);
  return { name: F.Windows, version: t2, versionName: n2 };
} }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe(e2) {
  const t2 = { name: F.iOS }, n2 = V.getSecondMatch(/(Version\/)(\d[\d.]+)/, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/macintosh/i], describe(e2) {
  const t2 = V.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, e2).replace(/[_\s]/g, "."), n2 = V.getMacOSVersionName(t2), r2 = { name: F.MacOS, version: t2 };
  return n2 && (r2.versionName = n2), r2;
} }, { test: [/(ipod|iphone|ipad)/i], describe(e2) {
  const t2 = V.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, e2).replace(/[_\s]/g, ".");
  return { name: F.iOS, version: t2 };
} }, { test(e2) {
  const t2 = !e2.test(/like android/i), n2 = e2.test(/android/i);
  return t2 && n2;
}, describe(e2) {
  const t2 = V.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, e2), n2 = V.getAndroidVersionName(t2), r2 = { name: F.Android, version: t2 };
  return n2 && (r2.versionName = n2), r2;
} }, { test: [/(web|hpw)[o0]s/i], describe(e2) {
  const t2 = V.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, e2), n2 = { name: F.WebOS };
  return t2 && t2.length && (n2.version = t2), n2;
} }, { test: [/blackberry|\bbb\d+/i, /rim\stablet/i], describe(e2) {
  const t2 = V.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, e2) || V.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, e2) || V.getFirstMatch(/\bbb(\d+)/i, e2);
  return { name: F.BlackBerry, version: t2 };
} }, { test: [/bada/i], describe(e2) {
  const t2 = V.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, e2);
  return { name: F.Bada, version: t2 };
} }, { test: [/tizen/i], describe(e2) {
  const t2 = V.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, e2);
  return { name: F.Tizen, version: t2 };
} }, { test: [/linux/i], describe: () => ({ name: F.Linux }) }, { test: [/CrOS/], describe: () => ({ name: F.ChromeOS }) }, { test: [/PlayStation 4/], describe(e2) {
  const t2 = V.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, e2);
  return { name: F.PlayStation4, version: t2 };
} }];
var q = [{ test: [/googlebot/i], describe: () => ({ type: "bot", vendor: "Google" }) }, { test: [/huawei/i], describe(e2) {
  const t2 = V.getFirstMatch(/(can-l01)/i, e2) && "Nova", n2 = { type: B.mobile, vendor: "Huawei" };
  return t2 && (n2.model = t2), n2;
} }, { test: [/nexus\s*(?:7|8|9|10).*/i], describe: () => ({ type: B.tablet, vendor: "Nexus" }) }, { test: [/ipad/i], describe: () => ({ type: B.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/Macintosh(.*?) FxiOS(.*?)\//], describe: () => ({ type: B.tablet, vendor: "Apple", model: "iPad" }) }, { test: [/kftt build/i], describe: () => ({ type: B.tablet, vendor: "Amazon", model: "Kindle Fire HD 7" }) }, { test: [/silk/i], describe: () => ({ type: B.tablet, vendor: "Amazon" }) }, { test: [/tablet(?! pc)/i], describe: () => ({ type: B.tablet }) }, { test(e2) {
  const t2 = e2.test(/ipod|iphone/i), n2 = e2.test(/like (ipod|iphone)/i);
  return t2 && !n2;
}, describe(e2) {
  const t2 = V.getFirstMatch(/(ipod|iphone)/i, e2);
  return { type: B.mobile, vendor: "Apple", model: t2 };
} }, { test: [/nexus\s*[0-6].*/i, /galaxy nexus/i], describe: () => ({ type: B.mobile, vendor: "Nexus" }) }, { test: [/[^-]mobi/i], describe: () => ({ type: B.mobile }) }, { test: (e2) => "blackberry" === e2.getBrowserName(true), describe: () => ({ type: B.mobile, vendor: "BlackBerry" }) }, { test: (e2) => "bada" === e2.getBrowserName(true), describe: () => ({ type: B.mobile }) }, { test: (e2) => "windows phone" === e2.getBrowserName(), describe: () => ({ type: B.mobile, vendor: "Microsoft" }) }, { test(e2) {
  const t2 = Number(String(e2.getOSVersion()).split(".")[0]);
  return "android" === e2.getOSName(true) && t2 >= 3;
}, describe: () => ({ type: B.tablet }) }, { test: (e2) => "android" === e2.getOSName(true), describe: () => ({ type: B.mobile }) }, { test: (e2) => "macos" === e2.getOSName(true), describe: () => ({ type: B.desktop, vendor: "Apple" }) }, { test: (e2) => "windows" === e2.getOSName(true), describe: () => ({ type: B.desktop }) }, { test: (e2) => "linux" === e2.getOSName(true), describe: () => ({ type: B.desktop }) }, { test: (e2) => "playstation 4" === e2.getOSName(true), describe: () => ({ type: B.tv }) }, { test: (e2) => "roku" === e2.getOSName(true), describe: () => ({ type: B.tv }) }];
var Y = [{ test: (e2) => "microsoft edge" === e2.getBrowserName(true), describe(e2) {
  if (/\sedg\//i.test(e2)) return { name: U.Blink };
  const t2 = V.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, e2);
  return { name: U.EdgeHTML, version: t2 };
} }, { test: [/trident/i], describe(e2) {
  const t2 = { name: U.Trident }, n2 = V.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: (e2) => e2.test(/presto/i), describe(e2) {
  const t2 = { name: U.Presto }, n2 = V.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test(e2) {
  const t2 = e2.test(/gecko/i), n2 = e2.test(/like gecko/i);
  return t2 && !n2;
}, describe(e2) {
  const t2 = { name: U.Gecko }, n2 = V.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }, { test: [/(apple)?webkit\/537\.36/i], describe: () => ({ name: U.Blink }) }, { test: [/(apple)?webkit/i], describe(e2) {
  const t2 = { name: U.WebKit }, n2 = V.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, e2);
  return n2 && (t2.version = n2), t2;
} }];
var z = class {
  constructor(e2, t2 = false) {
    if (null == e2 || "" === e2) throw new Error("UserAgent parameter can't be empty");
    this._ua = e2, this.parsedResult = {}, true !== t2 && this.parse();
  }
  getUA() {
    return this._ua;
  }
  test(e2) {
    return e2.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const e2 = V.find($, (e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some((e4) => this.test(e4));
      throw new Error("Browser's test function is not valid");
    });
    return e2 && (this.parsedResult.browser = e2.describe(this.getUA())), this.parsedResult.browser;
  }
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  getBrowserName(e2) {
    return e2 ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const e2 = V.find(G, (e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some((e4) => this.test(e4));
      throw new Error("Browser's test function is not valid");
    });
    return e2 && (this.parsedResult.os = e2.describe(this.getUA())), this.parsedResult.os;
  }
  getOSName(e2) {
    const { name: t2 } = this.getOS();
    return e2 ? String(t2).toLowerCase() || "" : t2 || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  getPlatformType(e2 = false) {
    const { type: t2 } = this.getPlatform();
    return e2 ? String(t2).toLowerCase() || "" : t2 || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const e2 = V.find(q, (e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some((e4) => this.test(e4));
      throw new Error("Browser's test function is not valid");
    });
    return e2 && (this.parsedResult.platform = e2.describe(this.getUA())), this.parsedResult.platform;
  }
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  getEngineName(e2) {
    return e2 ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const e2 = V.find(Y, (e3) => {
      if ("function" == typeof e3.test) return e3.test(this);
      if (e3.test instanceof Array) return e3.test.some((e4) => this.test(e4));
      throw new Error("Browser's test function is not valid");
    });
    return e2 && (this.parsedResult.engine = e2.describe(this.getUA())), this.parsedResult.engine;
  }
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  getResult() {
    return V.assign({}, this.parsedResult);
  }
  satisfies(e2) {
    const t2 = {};
    let n2 = 0;
    const r2 = {};
    let i2 = 0;
    if (Object.keys(e2).forEach((o2) => {
      const a2 = e2[o2];
      "string" == typeof a2 ? (r2[o2] = a2, i2 += 1) : "object" == typeof a2 && (t2[o2] = a2, n2 += 1);
    }), n2 > 0) {
      const e3 = Object.keys(t2), n3 = V.find(e3, (e4) => this.isOS(e4));
      if (n3) {
        const e4 = this.satisfies(t2[n3]);
        if (void 0 !== e4) return e4;
      }
      const r3 = V.find(e3, (e4) => this.isPlatform(e4));
      if (r3) {
        const e4 = this.satisfies(t2[r3]);
        if (void 0 !== e4) return e4;
      }
    }
    if (i2 > 0) {
      const e3 = Object.keys(r2), t3 = V.find(e3, (e4) => this.isBrowser(e4, true));
      if (void 0 !== t3) return this.compareVersion(r2[t3]);
    }
  }
  isBrowser(e2, t2 = false) {
    const n2 = this.getBrowserName().toLowerCase();
    let r2 = e2.toLowerCase();
    const i2 = V.getBrowserTypeByAlias(r2);
    return t2 && i2 && (r2 = i2.toLowerCase()), r2 === n2;
  }
  compareVersion(e2) {
    let t2 = [0], n2 = e2, r2 = false;
    const i2 = this.getBrowserVersion();
    if ("string" == typeof i2) return ">" === e2[0] || "<" === e2[0] ? (n2 = e2.substr(1), "=" === e2[1] ? (r2 = true, n2 = e2.substr(2)) : t2 = [], ">" === e2[0] ? t2.push(1) : t2.push(-1)) : "=" === e2[0] ? n2 = e2.substr(1) : "~" === e2[0] && (r2 = true, n2 = e2.substr(1)), t2.indexOf(V.compareVersions(i2, n2, r2)) > -1;
  }
  isOS(e2) {
    return this.getOSName(true) === String(e2).toLowerCase();
  }
  isPlatform(e2) {
    return this.getPlatformType(true) === String(e2).toLowerCase();
  }
  isEngine(e2) {
    return this.getEngineName(true) === String(e2).toLowerCase();
  }
  is(e2, t2 = false) {
    return this.isBrowser(e2, t2) || this.isOS(e2) || this.isPlatform(e2);
  }
  some(e2 = []) {
    return e2.some((e3) => this.is(e3));
  }
};
var W = class {
  static getParser(e2, t2 = false) {
    if ("string" != typeof e2) throw new Error("UserAgent should be a string");
    return new z(e2, t2);
  }
  static parse(e2) {
    return new z(e2).getResult();
  }
  static get BROWSER_MAP() {
    return R;
  }
  static get ENGINE_MAP() {
    return U;
  }
  static get OS_MAP() {
    return F;
  }
  static get PLATFORMS_MAP() {
    return B;
  }
};
function H() {
  return Date.now() + Math.random().toString();
}
function Q() {
  throw new Error("Method must be implemented in subclass");
}
function K(e2, t2) {
  return null != t2 && t2.proxyUrl ? t2.proxyUrl + ("/" === t2.proxyUrl.slice(-1) ? "" : "/") + e2.substring(8) : e2;
}
function X(e2) {
  return null != e2 && e2.callObjectBundleUrlOverride ? e2.callObjectBundleUrlOverride : K("https://c.daily.co/call-machine/versioned/".concat("0.70.0", "/static/call-machine-object-bundle.js"), e2);
}
function Z(e2) {
  try {
    new URL(e2);
  } catch (e3) {
    return false;
  }
  return true;
}
var ee = Object.prototype.toString;
function te(e2) {
  switch (ee.call(e2)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return true;
    default:
      return ue(e2, Error);
  }
}
function ne(e2, t2) {
  return ee.call(e2) === `[object ${t2}]`;
}
function re(e2) {
  return ne(e2, "ErrorEvent");
}
function ie(e2) {
  return ne(e2, "DOMError");
}
function oe(e2) {
  return ne(e2, "String");
}
function ae(e2) {
  return null === e2 || "object" != typeof e2 && "function" != typeof e2;
}
function se(e2) {
  return ne(e2, "Object");
}
function ce(e2) {
  return "undefined" != typeof Event && ue(e2, Event);
}
function le(e2) {
  return Boolean(e2 && e2.then && "function" == typeof e2.then);
}
function ue(e2, t2) {
  try {
    return e2 instanceof t2;
  } catch (e3) {
    return false;
  }
}
function de(e2, t2 = 0) {
  return "string" != typeof e2 || 0 === t2 || e2.length <= t2 ? e2 : `${e2.slice(0, t2)}...`;
}
function he(e2, t2) {
  if (!Array.isArray(e2)) return "";
  const n2 = [];
  for (let t3 = 0; t3 < e2.length; t3++) {
    const r2 = e2[t3];
    try {
      n2.push(String(r2));
    } catch (e3) {
      n2.push("[value cannot be serialized]");
    }
  }
  return n2.join(t2);
}
function pe(e2, t2, n2 = false) {
  return !!oe(e2) && (ne(t2, "RegExp") ? t2.test(e2) : !!oe(t2) && (n2 ? e2 === t2 : e2.includes(t2)));
}
function fe(e2, t2 = [], n2 = false) {
  return t2.some((t3) => pe(e2, t3, n2));
}
function ge(e2, t2, n2 = 250, r2, i2, o2, a2) {
  if (!(o2.exception && o2.exception.values && a2 && ue(a2.originalException, Error))) return;
  const s2 = o2.exception.values.length > 0 ? o2.exception.values[o2.exception.values.length - 1] : void 0;
  var c2, l2;
  s2 && (o2.exception.values = (c2 = ve(e2, t2, i2, a2.originalException, r2, o2.exception.values, s2, 0), l2 = n2, c2.map((e3) => (e3.value && (e3.value = de(e3.value, l2)), e3))));
}
function ve(e2, t2, n2, r2, i2, o2, a2, s2) {
  if (o2.length >= n2 + 1) return o2;
  let c2 = [...o2];
  if (ue(r2[i2], Error)) {
    me(a2, s2);
    const o3 = e2(t2, r2[i2]), l2 = c2.length;
    ye(o3, i2, l2, s2), c2 = ve(e2, t2, n2, r2[i2], i2, [o3, ...c2], o3, l2);
  }
  return Array.isArray(r2.errors) && r2.errors.forEach((r3, o3) => {
    if (ue(r3, Error)) {
      me(a2, s2);
      const l2 = e2(t2, r3), u2 = c2.length;
      ye(l2, `errors[${o3}]`, u2, s2), c2 = ve(e2, t2, n2, r3, i2, [l2, ...c2], l2, u2);
    }
  }), c2;
}
function me(e2, t2) {
  e2.mechanism = e2.mechanism || { type: "generic", handled: true }, e2.mechanism = { ...e2.mechanism, is_exception_group: true, exception_id: t2 };
}
function ye(e2, t2, n2, r2) {
  e2.mechanism = e2.mechanism || { type: "generic", handled: true }, e2.mechanism = { ...e2.mechanism, type: "chained", source: t2, exception_id: n2, parent_id: r2 };
}
function _e(e2) {
  return e2 && e2.Math == Math ? e2 : void 0;
}
var be = "object" == typeof globalThis && _e(globalThis) || "object" == typeof window && _e(window) || "object" == typeof self && _e(self) || "object" == typeof global && _e(global) || /* @__PURE__ */ function() {
  return this;
}() || {};
function we() {
  return be;
}
function Se(e2, t2, n2) {
  const r2 = n2 || be, i2 = r2.__SENTRY__ = r2.__SENTRY__ || {};
  return i2[e2] || (i2[e2] = t2());
}
var ke = we();
var Ee = 80;
function Ce(e2, t2 = {}) {
  try {
    let n2 = e2;
    const r2 = 5, i2 = [];
    let o2 = 0, a2 = 0;
    const s2 = " > ", c2 = s2.length;
    let l2;
    const u2 = Array.isArray(t2) ? t2 : t2.keyAttrs, d2 = !Array.isArray(t2) && t2.maxStringLength || Ee;
    for (; n2 && o2++ < r2 && (l2 = Me(n2, u2), !("html" === l2 || o2 > 1 && a2 + i2.length * c2 + l2.length >= d2)); ) i2.push(l2), a2 += l2.length, n2 = n2.parentNode;
    return i2.reverse().join(s2);
  } catch (e3) {
    return "<unknown>";
  }
}
function Me(e2, t2) {
  const n2 = e2, r2 = [];
  let i2, o2, a2, s2, c2;
  if (!n2 || !n2.tagName) return "";
  r2.push(n2.tagName.toLowerCase());
  const l2 = t2 && t2.length ? t2.filter((e3) => n2.getAttribute(e3)).map((e3) => [e3, n2.getAttribute(e3)]) : null;
  if (l2 && l2.length) l2.forEach((e3) => {
    r2.push(`[${e3[0]}="${e3[1]}"]`);
  });
  else if (n2.id && r2.push(`#${n2.id}`), i2 = n2.className, i2 && oe(i2)) for (o2 = i2.split(/\s+/), c2 = 0; c2 < o2.length; c2++) r2.push(`.${o2[c2]}`);
  const u2 = ["aria-label", "type", "name", "title", "alt"];
  for (c2 = 0; c2 < u2.length; c2++) a2 = u2[c2], s2 = n2.getAttribute(a2), s2 && r2.push(`[${a2}="${s2}"]`);
  return r2.join("");
}
var Te = ["debug", "info", "warn", "error", "log", "assert", "trace"];
function Oe(e2) {
  if (!("console" in be)) return e2();
  const t2 = be.console, n2 = {};
  Te.forEach((e3) => {
    const r2 = t2[e3] && t2[e3].__sentry_original__;
    e3 in t2 && r2 && (n2[e3] = t2[e3], t2[e3] = r2);
  });
  try {
    return e2();
  } finally {
    Object.keys(n2).forEach((e3) => {
      t2[e3] = n2[e3];
    });
  }
}
function Pe() {
  let e2 = false;
  const t2 = { enable: () => {
    e2 = true;
  }, disable: () => {
    e2 = false;
  } };
  return "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__ ? Te.forEach((n2) => {
    t2[n2] = (...t3) => {
      e2 && Oe(() => {
        be.console[n2](`Sentry Logger [${n2}]:`, ...t3);
      });
    };
  }) : Te.forEach((e3) => {
    t2[e3] = () => {
    };
  }), t2;
}
var Ae;
Ae = "undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__ ? Se("logger", Pe) : Pe();
var De = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function je(e2, t2 = false) {
  const { host: n2, path: r2, pass: i2, port: o2, projectId: a2, protocol: s2, publicKey: c2 } = e2;
  return `${s2}://${c2}${t2 && i2 ? `:${i2}` : ""}@${n2}${o2 ? `:${o2}` : ""}/${r2 ? `${r2}/` : r2}${a2}`;
}
function xe(e2) {
  return { protocol: e2.protocol, publicKey: e2.publicKey || "", pass: e2.pass || "", host: e2.host, port: e2.port || "", path: e2.path || "", projectId: e2.projectId };
}
function Le(e2) {
  const t2 = "string" == typeof e2 ? function(e3) {
    const t3 = De.exec(e3);
    if (!t3) return void console.error(`Invalid Sentry Dsn: ${e3}`);
    const [n2, r2, i2 = "", o2, a2 = "", s2] = t3.slice(1);
    let c2 = "", l2 = s2;
    const u2 = l2.split("/");
    if (u2.length > 1 && (c2 = u2.slice(0, -1).join("/"), l2 = u2.pop()), l2) {
      const e4 = l2.match(/^\d+/);
      e4 && (l2 = e4[0]);
    }
    return xe({ host: o2, pass: i2, path: c2, projectId: l2, port: a2, protocol: n2, publicKey: r2 });
  }(e2) : xe(e2);
  if (t2 && function(e3) {
    if ("undefined" != typeof __SENTRY_DEBUG__ && !__SENTRY_DEBUG__) return true;
    const { port: t3, projectId: n2, protocol: r2 } = e3;
    return !(["protocol", "publicKey", "host", "projectId"].find((t4) => !e3[t4] && (Ae.error(`Invalid Sentry Dsn: ${t4} missing`), true)) || (n2.match(/^\d+$/) ? /* @__PURE__ */ function(e4) {
      return "http" === e4 || "https" === e4;
    }(r2) ? t3 && isNaN(parseInt(t3, 10)) && (Ae.error(`Invalid Sentry Dsn: Invalid port ${t3}`), 1) : (Ae.error(`Invalid Sentry Dsn: Invalid protocol ${r2}`), 1) : (Ae.error(`Invalid Sentry Dsn: Invalid projectId ${n2}`), 1)));
  }(t2)) return t2;
}
var Ie = class extends Error {
  constructor(e2, t2 = "warn") {
    super(e2), this.message = e2, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = t2;
  }
};
function Ne(e2, t2, n2) {
  if (!(t2 in e2)) return;
  const r2 = e2[t2], i2 = n2(r2);
  if ("function" == typeof i2) try {
    Be(i2, r2);
  } catch (e3) {
  }
  e2[t2] = i2;
}
function Re(e2, t2, n2) {
  Object.defineProperty(e2, t2, { value: n2, writable: true, configurable: true });
}
function Be(e2, t2) {
  const n2 = t2.prototype || {};
  e2.prototype = t2.prototype = n2, Re(e2, "__sentry_original__", t2);
}
function Fe(e2) {
  return e2.__sentry_original__;
}
function Ue(e2) {
  if (te(e2)) return { message: e2.message, name: e2.name, stack: e2.stack, ...Je(e2) };
  if (ce(e2)) {
    const t2 = { type: e2.type, target: Ve(e2.target), currentTarget: Ve(e2.currentTarget), ...Je(e2) };
    return "undefined" != typeof CustomEvent && ue(e2, CustomEvent) && (t2.detail = e2.detail), t2;
  }
  return e2;
}
function Ve(e2) {
  try {
    return t2 = e2, "undefined" != typeof Element && ue(t2, Element) ? Ce(e2) : Object.prototype.toString.call(e2);
  } catch (e3) {
    return "<unknown>";
  }
  var t2;
}
function Je(e2) {
  if ("object" == typeof e2 && null !== e2) {
    const t2 = {};
    for (const n2 in e2) Object.prototype.hasOwnProperty.call(e2, n2) && (t2[n2] = e2[n2]);
    return t2;
  }
  return {};
}
function $e(e2) {
  return Ge(e2, /* @__PURE__ */ new Map());
}
function Ge(e2, t2) {
  if (se(e2)) {
    const n2 = t2.get(e2);
    if (void 0 !== n2) return n2;
    const r2 = {};
    t2.set(e2, r2);
    for (const n3 of Object.keys(e2)) void 0 !== e2[n3] && (r2[n3] = Ge(e2[n3], t2));
    return r2;
  }
  if (Array.isArray(e2)) {
    const n2 = t2.get(e2);
    if (void 0 !== n2) return n2;
    const r2 = [];
    return t2.set(e2, r2), e2.forEach((e3) => {
      r2.push(Ge(e3, t2));
    }), r2;
  }
  return e2;
}
var qe = "<anonymous>";
function Ye(e2) {
  try {
    return e2 && "function" == typeof e2 && e2.name || qe;
  } catch (e3) {
    return qe;
  }
}
var ze = we();
function We(e2) {
  return e2 && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(e2.toString());
}
function He() {
  if (!function() {
    if (!("fetch" in ze)) return false;
    try {
      return new Headers(), new Request("http://www.example.com"), new Response(), true;
    } catch (e3) {
      return false;
    }
  }()) return false;
  if (We(ze.fetch)) return true;
  let e2 = false;
  const t2 = ze.document;
  if (t2 && "function" == typeof t2.createElement) try {
    const n2 = t2.createElement("iframe");
    n2.hidden = true, t2.head.appendChild(n2), n2.contentWindow && n2.contentWindow.fetch && (e2 = We(n2.contentWindow.fetch)), t2.head.removeChild(n2);
  } catch (e3) {
    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e3);
  }
  return e2;
}
var Qe = we();
var Ke = we();
var Xe = "__sentry_xhr_v2__";
var Ze = {};
var et = {};
function tt(e2) {
  if (!et[e2]) switch (et[e2] = true, e2) {
    case "console":
      !function() {
        if (!("console" in Ke)) return;
        Te.forEach(function(e3) {
          e3 in Ke.console && Ne(Ke.console, e3, function(t2) {
            return function(...n2) {
              rt("console", { args: n2, level: e3 }), t2 && t2.apply(Ke.console, n2);
            };
          });
        });
      }();
      break;
    case "dom":
      !function() {
        if (!("document" in Ke)) return;
        const e3 = rt.bind(null, "dom"), t2 = ut(e3, true);
        Ke.document.addEventListener("click", t2, false), Ke.document.addEventListener("keypress", t2, false), ["EventTarget", "Node"].forEach((t3) => {
          const n2 = Ke[t3] && Ke[t3].prototype;
          n2 && n2.hasOwnProperty && n2.hasOwnProperty("addEventListener") && (Ne(n2, "addEventListener", function(t4) {
            return function(n3, r2, i2) {
              if ("click" === n3 || "keypress" == n3) try {
                const r3 = this, o2 = r3.__sentry_instrumentation_handlers__ = r3.__sentry_instrumentation_handlers__ || {}, a2 = o2[n3] = o2[n3] || { refCount: 0 };
                if (!a2.handler) {
                  const r4 = ut(e3);
                  a2.handler = r4, t4.call(this, n3, r4, i2);
                }
                a2.refCount++;
              } catch (e4) {
              }
              return t4.call(this, n3, r2, i2);
            };
          }), Ne(n2, "removeEventListener", function(e4) {
            return function(t4, n3, r2) {
              if ("click" === t4 || "keypress" == t4) try {
                const n4 = this, i2 = n4.__sentry_instrumentation_handlers__ || {}, o2 = i2[t4];
                o2 && (o2.refCount--, o2.refCount <= 0 && (e4.call(this, t4, o2.handler, r2), o2.handler = void 0, delete i2[t4]), 0 === Object.keys(i2).length && delete n4.__sentry_instrumentation_handlers__);
              } catch (e5) {
              }
              return e4.call(this, t4, n3, r2);
            };
          }));
        });
      }();
      break;
    case "xhr":
      !function() {
        if (!("XMLHttpRequest" in Ke)) return;
        const e3 = XMLHttpRequest.prototype;
        Ne(e3, "open", function(e4) {
          return function(...t2) {
            const n2 = t2[1], r2 = this[Xe] = { method: oe(t2[0]) ? t2[0].toUpperCase() : t2[0], url: t2[1], request_headers: {} };
            oe(n2) && "POST" === r2.method && n2.match(/sentry_key/) && (this.__sentry_own_request__ = true);
            const i2 = () => {
              const e5 = this[Xe];
              if (e5 && 4 === this.readyState) {
                try {
                  e5.status_code = this.status;
                } catch (e6) {
                }
                rt("xhr", { args: t2, endTimestamp: Date.now(), startTimestamp: Date.now(), xhr: this });
              }
            };
            return "onreadystatechange" in this && "function" == typeof this.onreadystatechange ? Ne(this, "onreadystatechange", function(e5) {
              return function(...t3) {
                return i2(), e5.apply(this, t3);
              };
            }) : this.addEventListener("readystatechange", i2), Ne(this, "setRequestHeader", function(e5) {
              return function(...t3) {
                const [n3, r3] = t3, i3 = this[Xe];
                return i3 && (i3.request_headers[n3.toLowerCase()] = r3), e5.apply(this, t3);
              };
            }), e4.apply(this, t2);
          };
        }), Ne(e3, "send", function(e4) {
          return function(...t2) {
            const n2 = this[Xe];
            return n2 && void 0 !== t2[0] && (n2.body = t2[0]), rt("xhr", { args: t2, startTimestamp: Date.now(), xhr: this }), e4.apply(this, t2);
          };
        });
      }();
      break;
    case "fetch":
      !function() {
        if (!He()) return;
        Ne(Ke, "fetch", function(e3) {
          return function(...t2) {
            const { method: n2, url: r2 } = function(e4) {
              if (0 === e4.length) return { method: "GET", url: "" };
              if (2 === e4.length) {
                const [t4, n3] = e4;
                return { url: ot(t4), method: it(n3, "method") ? String(n3.method).toUpperCase() : "GET" };
              }
              const t3 = e4[0];
              return { url: ot(t3), method: it(t3, "method") ? String(t3.method).toUpperCase() : "GET" };
            }(t2), i2 = { args: t2, fetchData: { method: n2, url: r2 }, startTimestamp: Date.now() };
            return rt("fetch", { ...i2 }), e3.apply(Ke, t2).then((e4) => (rt("fetch", { ...i2, endTimestamp: Date.now(), response: e4 }), e4), (e4) => {
              throw rt("fetch", { ...i2, endTimestamp: Date.now(), error: e4 }), e4;
            });
          };
        });
      }();
      break;
    case "history":
      !function() {
        if (!function() {
          const e4 = Qe.chrome, t3 = e4 && e4.app && e4.app.runtime, n2 = "history" in Qe && !!Qe.history.pushState && !!Qe.history.replaceState;
          return !t3 && n2;
        }()) return;
        const e3 = Ke.onpopstate;
        function t2(e4) {
          return function(...t3) {
            const n2 = t3.length > 2 ? t3[2] : void 0;
            if (n2) {
              const e5 = at, t4 = String(n2);
              at = t4, rt("history", { from: e5, to: t4 });
            }
            return e4.apply(this, t3);
          };
        }
        Ke.onpopstate = function(...t3) {
          const n2 = Ke.location.href, r2 = at;
          if (at = n2, rt("history", { from: r2, to: n2 }), e3) try {
            return e3.apply(this, t3);
          } catch (e4) {
          }
        }, Ne(Ke.history, "pushState", t2), Ne(Ke.history, "replaceState", t2);
      }();
      break;
    case "error":
      dt = Ke.onerror, Ke.onerror = function(e3, t2, n2, r2, i2) {
        return rt("error", { column: r2, error: i2, line: n2, msg: e3, url: t2 }), !(!dt || dt.__SENTRY_LOADER__) && dt.apply(this, arguments);
      }, Ke.onerror.__SENTRY_INSTRUMENTED__ = true;
      break;
    case "unhandledrejection":
      ht = Ke.onunhandledrejection, Ke.onunhandledrejection = function(e3) {
        return rt("unhandledrejection", e3), !(ht && !ht.__SENTRY_LOADER__) || ht.apply(this, arguments);
      }, Ke.onunhandledrejection.__SENTRY_INSTRUMENTED__ = true;
      break;
    default:
      return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("unknown instrumentation type:", e2));
  }
}
function nt(e2, t2) {
  Ze[e2] = Ze[e2] || [], Ze[e2].push(t2), tt(e2);
}
function rt(e2, t2) {
  if (e2 && Ze[e2]) for (const n2 of Ze[e2] || []) try {
    n2(t2);
  } catch (t3) {
    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.error(`Error while triggering instrumentation handler.
Type: ${e2}
Name: ${Ye(n2)}
Error:`, t3);
  }
}
function it(e2, t2) {
  return !!e2 && "object" == typeof e2 && !!e2[t2];
}
function ot(e2) {
  return "string" == typeof e2 ? e2 : e2 ? it(e2, "url") ? e2.url : e2.toString ? e2.toString() : "" : "";
}
var at;
var st = 1e3;
var ct;
var lt;
function ut(e2, t2 = false) {
  return (n2) => {
    if (!n2 || lt === n2) return;
    if (function(e3) {
      if ("keypress" !== e3.type) return false;
      try {
        const t3 = e3.target;
        if (!t3 || !t3.tagName) return true;
        if ("INPUT" === t3.tagName || "TEXTAREA" === t3.tagName || t3.isContentEditable) return false;
      } catch (e4) {
      }
      return true;
    }(n2)) return;
    const r2 = "keypress" === n2.type ? "input" : n2.type;
    (void 0 === ct || function(e3, t3) {
      if (!e3) return true;
      if (e3.type !== t3.type) return true;
      try {
        if (e3.target !== t3.target) return true;
      } catch (e4) {
      }
      return false;
    }(lt, n2)) && (e2({ event: n2, name: r2, global: t2 }), lt = n2), clearTimeout(ct), ct = Ke.setTimeout(() => {
      ct = void 0;
    }, st);
  };
}
var dt = null;
var ht = null;
function pt() {
  const e2 = be, t2 = e2.crypto || e2.msCrypto;
  if (t2 && t2.randomUUID) return t2.randomUUID().replace(/-/g, "");
  const n2 = t2 && t2.getRandomValues ? () => t2.getRandomValues(new Uint8Array(1))[0] : () => 16 * Math.random();
  return ("10000000100040008000" + 1e11).replace(/[018]/g, (e3) => (e3 ^ (15 & n2()) >> e3 / 4).toString(16));
}
function ft(e2) {
  return e2.exception && e2.exception.values ? e2.exception.values[0] : void 0;
}
function gt(e2) {
  const { message: t2, event_id: n2 } = e2;
  if (t2) return t2;
  const r2 = ft(e2);
  return r2 ? r2.type && r2.value ? `${r2.type}: ${r2.value}` : r2.type || r2.value || n2 || "<unknown>" : n2 || "<unknown>";
}
function vt(e2, t2, n2) {
  const r2 = e2.exception = e2.exception || {}, i2 = r2.values = r2.values || [], o2 = i2[0] = i2[0] || {};
  o2.value || (o2.value = t2 || ""), o2.type || (o2.type = n2 || "Error");
}
function mt(e2, t2) {
  const n2 = ft(e2);
  if (!n2) return;
  const r2 = n2.mechanism;
  if (n2.mechanism = { type: "generic", handled: true, ...r2, ...t2 }, t2 && "data" in t2) {
    const e3 = { ...r2 && r2.data, ...t2.data };
    n2.mechanism.data = e3;
  }
}
function yt(e2) {
  if (e2 && e2.__sentry_captured__) return true;
  try {
    Re(e2, "__sentry_captured__", true);
  } catch (e3) {
  }
  return false;
}
function _t(e2, t2 = 100, n2 = 1 / 0) {
  try {
    return wt("", e2, t2, n2);
  } catch (e3) {
    return { ERROR: `**non-serializable** (${e3})` };
  }
}
function bt(e2, t2 = 3, n2 = 102400) {
  const r2 = _t(e2, t2);
  return i2 = r2, function(e3) {
    return ~-encodeURI(e3).split(/%..|./).length;
  }(JSON.stringify(i2)) > n2 ? bt(e2, t2 - 1, n2) : r2;
  var i2;
}
function wt(e2, t2, n2 = 1 / 0, r2 = 1 / 0, i2 = /* @__PURE__ */ function() {
  const e3 = "function" == typeof WeakSet, t3 = e3 ? /* @__PURE__ */ new WeakSet() : [];
  return [function(n3) {
    if (e3) return !!t3.has(n3) || (t3.add(n3), false);
    for (let e4 = 0; e4 < t3.length; e4++) if (t3[e4] === n3) return true;
    return t3.push(n3), false;
  }, function(n3) {
    if (e3) t3.delete(n3);
    else for (let e4 = 0; e4 < t3.length; e4++) if (t3[e4] === n3) {
      t3.splice(e4, 1);
      break;
    }
  }];
}()) {
  const [o2, a2] = i2;
  if (null == t2 || ["number", "boolean", "string"].includes(typeof t2) && ("number" != typeof (s2 = t2) || s2 == s2)) return t2;
  var s2;
  const c2 = function(e3, t3) {
    try {
      if ("domain" === e3 && t3 && "object" == typeof t3 && t3._events) return "[Domain]";
      if ("domainEmitter" === e3) return "[DomainEmitter]";
      if ("undefined" != typeof global && t3 === global) return "[Global]";
      if ("undefined" != typeof window && t3 === window) return "[Window]";
      if ("undefined" != typeof document && t3 === document) return "[Document]";
      if (function(e4) {
        return se(e4) && "nativeEvent" in e4 && "preventDefault" in e4 && "stopPropagation" in e4;
      }(t3)) return "[SyntheticEvent]";
      if ("number" == typeof t3 && t3 != t3) return "[NaN]";
      if ("function" == typeof t3) return `[Function: ${Ye(t3)}]`;
      if ("symbol" == typeof t3) return `[${String(t3)}]`;
      if ("bigint" == typeof t3) return `[BigInt: ${String(t3)}]`;
      const n3 = function(e4) {
        const t4 = Object.getPrototypeOf(e4);
        return t4 ? t4.constructor.name : "null prototype";
      }(t3);
      return /^HTML(\w*)Element$/.test(n3) ? `[HTMLElement: ${n3}]` : `[object ${n3}]`;
    } catch (e4) {
      return `**non-serializable** (${e4})`;
    }
  }(e2, t2);
  if (!c2.startsWith("[object ")) return c2;
  if (t2.__sentry_skip_normalization__) return t2;
  const l2 = "number" == typeof t2.__sentry_override_normalization_depth__ ? t2.__sentry_override_normalization_depth__ : n2;
  if (0 === l2) return c2.replace("object ", "");
  if (o2(t2)) return "[Circular ~]";
  const u2 = t2;
  if (u2 && "function" == typeof u2.toJSON) try {
    return wt("", u2.toJSON(), l2 - 1, r2, i2);
  } catch (e3) {
  }
  const d2 = Array.isArray(t2) ? [] : {};
  let h2 = 0;
  const p2 = Ue(t2);
  for (const e3 in p2) {
    if (!Object.prototype.hasOwnProperty.call(p2, e3)) continue;
    if (h2 >= r2) {
      d2[e3] = "[MaxProperties ~]";
      break;
    }
    const t3 = p2[e3];
    d2[e3] = wt(e3, t3, l2 - 1, r2, i2), h2++;
  }
  return a2(t2), d2;
}
var St;
function kt(e2) {
  return new Ct((t2) => {
    t2(e2);
  });
}
function Et(e2) {
  return new Ct((t2, n2) => {
    n2(e2);
  });
}
!function(e2) {
  e2[e2.PENDING = 0] = "PENDING";
  e2[e2.RESOLVED = 1] = "RESOLVED";
  e2[e2.REJECTED = 2] = "REJECTED";
}(St || (St = {}));
var Ct = class _Ct {
  __init() {
    this._state = St.PENDING;
  }
  __init2() {
    this._handlers = [];
  }
  constructor(e2) {
    _Ct.prototype.__init.call(this), _Ct.prototype.__init2.call(this), _Ct.prototype.__init3.call(this), _Ct.prototype.__init4.call(this), _Ct.prototype.__init5.call(this), _Ct.prototype.__init6.call(this);
    try {
      e2(this._resolve, this._reject);
    } catch (e3) {
      this._reject(e3);
    }
  }
  then(e2, t2) {
    return new _Ct((n2, r2) => {
      this._handlers.push([false, (t3) => {
        if (e2) try {
          n2(e2(t3));
        } catch (e3) {
          r2(e3);
        }
        else n2(t3);
      }, (e3) => {
        if (t2) try {
          n2(t2(e3));
        } catch (e4) {
          r2(e4);
        }
        else r2(e3);
      }]), this._executeHandlers();
    });
  }
  catch(e2) {
    return this.then((e3) => e3, e2);
  }
  finally(e2) {
    return new _Ct((t2, n2) => {
      let r2, i2;
      return this.then((t3) => {
        i2 = false, r2 = t3, e2 && e2();
      }, (t3) => {
        i2 = true, r2 = t3, e2 && e2();
      }).then(() => {
        i2 ? n2(r2) : t2(r2);
      });
    });
  }
  __init3() {
    this._resolve = (e2) => {
      this._setResult(St.RESOLVED, e2);
    };
  }
  __init4() {
    this._reject = (e2) => {
      this._setResult(St.REJECTED, e2);
    };
  }
  __init5() {
    this._setResult = (e2, t2) => {
      this._state === St.PENDING && (le(t2) ? t2.then(this._resolve, this._reject) : (this._state = e2, this._value = t2, this._executeHandlers()));
    };
  }
  __init6() {
    this._executeHandlers = () => {
      if (this._state === St.PENDING) return;
      const e2 = this._handlers.slice();
      this._handlers = [], e2.forEach((e3) => {
        e3[0] || (this._state === St.RESOLVED && e3[1](this._value), this._state === St.REJECTED && e3[2](this._value), e3[0] = true);
      });
    };
  }
};
function Mt(e2) {
  const t2 = [];
  function n2(e3) {
    return t2.splice(t2.indexOf(e3), 1)[0];
  }
  return { $: t2, add: function(r2) {
    if (!(void 0 === e2 || t2.length < e2)) return Et(new Ie("Not adding Promise because buffer limit was reached."));
    const i2 = r2();
    return -1 === t2.indexOf(i2) && t2.push(i2), i2.then(() => n2(i2)).then(null, () => n2(i2).then(null, () => {
    })), i2;
  }, drain: function(e3) {
    return new Ct((n3, r2) => {
      let i2 = t2.length;
      if (!i2) return n3(true);
      const o2 = setTimeout(() => {
        e3 && e3 > 0 && n3(false);
      }, e3);
      t2.forEach((e4) => {
        kt(e4).then(() => {
          --i2 || (clearTimeout(o2), n3(true));
        }, r2);
      });
    });
  } };
}
function Tt(e2) {
  if (!e2) return {};
  const t2 = e2.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t2) return {};
  const n2 = t2[6] || "", r2 = t2[8] || "";
  return { host: t2[4], path: t2[5], protocol: t2[2], search: n2, hash: r2, relative: t2[5] + n2 + r2 };
}
var Ot = ["fatal", "error", "warning", "log", "info", "debug"];
var Pt = we();
var At = { nowSeconds: () => Date.now() / 1e3 };
var Dt = "undefined" != typeof __SENTRY_BROWSER_BUNDLE__ && __SENTRY_BROWSER_BUNDLE__ || "[object process]" !== Object.prototype.toString.call("undefined" != typeof process ? process : 0) ? function() {
  const { performance: e2 } = Pt;
  if (!e2 || !e2.now) return;
  return { now: () => e2.now(), timeOrigin: Date.now() - e2.now() };
}() : function() {
  try {
    return (e2 = module, t2 = "perf_hooks", e2.require(t2)).performance;
  } catch (e3) {
    return;
  }
  var e2, t2;
}();
var jt = void 0 === Dt ? At : { nowSeconds: () => (Dt.timeOrigin + Dt.now()) / 1e3 };
var xt = At.nowSeconds.bind(At);
var Lt = jt.nowSeconds.bind(jt);
function It(e2, t2 = []) {
  return [e2, t2];
}
function Nt(e2, t2) {
  const [n2, r2] = e2;
  return [n2, [...r2, t2]];
}
function Rt(e2, t2) {
  const n2 = e2[1];
  for (const e3 of n2) {
    if (t2(e3, e3[0].type)) return true;
  }
  return false;
}
function Bt(e2, t2) {
  return (t2 || new TextEncoder()).encode(e2);
}
function Ft(e2, t2) {
  const [n2, r2] = e2;
  let i2 = JSON.stringify(n2);
  function o2(e3) {
    "string" == typeof i2 ? i2 = "string" == typeof e3 ? i2 + e3 : [Bt(i2, t2), e3] : i2.push("string" == typeof e3 ? Bt(e3, t2) : e3);
  }
  for (const e3 of r2) {
    const [t3, n3] = e3;
    if (o2(`
${JSON.stringify(t3)}
`), "string" == typeof n3 || n3 instanceof Uint8Array) o2(n3);
    else {
      let e4;
      try {
        e4 = JSON.stringify(n3);
      } catch (t4) {
        e4 = JSON.stringify(_t(n3));
      }
      o2(e4);
    }
  }
  return "string" == typeof i2 ? i2 : function(e3) {
    const t3 = e3.reduce((e4, t4) => e4 + t4.length, 0), n3 = new Uint8Array(t3);
    let r3 = 0;
    for (const t4 of e3) n3.set(t4, r3), r3 += t4.length;
    return n3;
  }(i2);
}
function Ut(e2, t2) {
  const n2 = "string" == typeof e2.data ? Bt(e2.data, t2) : e2.data;
  return [$e({ type: "attachment", length: n2.length, filename: e2.filename, content_type: e2.contentType, attachment_type: e2.attachmentType }), n2];
}
(() => {
  const { performance: e2 } = Pt;
  if (!e2 || !e2.now) return;
  const t2 = 36e5, n2 = e2.now(), r2 = Date.now(), i2 = e2.timeOrigin ? Math.abs(e2.timeOrigin + n2 - r2) : t2, o2 = i2 < t2, a2 = e2.timing && e2.timing.navigationStart, s2 = "number" == typeof a2 ? Math.abs(a2 + n2 - r2) : t2;
  (o2 || s2 < t2) && (i2 <= s2 && e2.timeOrigin);
})();
var Vt = { session: "session", sessions: "session", attachment: "attachment", transaction: "transaction", event: "error", client_report: "internal", user_report: "default", profile: "profile", replay_event: "replay", replay_recording: "replay", check_in: "monitor" };
function Jt(e2) {
  return Vt[e2];
}
function $t(e2) {
  if (!e2 || !e2.sdk) return;
  const { name: t2, version: n2 } = e2.sdk;
  return { name: t2, version: n2 };
}
var Gt = 6e4;
function qt(e2, { statusCode: t2, headers: n2 }, r2 = Date.now()) {
  const i2 = { ...e2 }, o2 = n2 && n2["x-sentry-rate-limits"], a2 = n2 && n2["retry-after"];
  if (o2) for (const e3 of o2.trim().split(",")) {
    const [t3, n3] = e3.split(":", 2), o3 = parseInt(t3, 10), a3 = 1e3 * (isNaN(o3) ? 60 : o3);
    if (n3) for (const e4 of n3.split(";")) i2[e4] = r2 + a3;
    else i2.all = r2 + a3;
  }
  else a2 ? i2.all = r2 + function(e3, t3 = Date.now()) {
    const n3 = parseInt(`${e3}`, 10);
    if (!isNaN(n3)) return 1e3 * n3;
    const r3 = Date.parse(`${e3}`);
    return isNaN(r3) ? Gt : r3 - t3;
  }(a2, r2) : 429 === t2 && (i2.all = r2 + 6e4);
  return i2;
}
var Yt = "production";
function zt(e2) {
  const t2 = Lt(), n2 = { sid: pt(), init: true, timestamp: t2, started: t2, duration: 0, status: "ok", errors: 0, ignoreDuration: false, toJSON: () => function(e3) {
    return $e({ sid: `${e3.sid}`, init: e3.init, started: new Date(1e3 * e3.started).toISOString(), timestamp: new Date(1e3 * e3.timestamp).toISOString(), status: e3.status, errors: e3.errors, did: "number" == typeof e3.did || "string" == typeof e3.did ? `${e3.did}` : void 0, duration: e3.duration, attrs: { release: e3.release, environment: e3.environment, ip_address: e3.ipAddress, user_agent: e3.userAgent } });
  }(n2) };
  return e2 && Wt(n2, e2), n2;
}
function Wt(e2, t2 = {}) {
  if (t2.user && (!e2.ipAddress && t2.user.ip_address && (e2.ipAddress = t2.user.ip_address), e2.did || t2.did || (e2.did = t2.user.id || t2.user.email || t2.user.username)), e2.timestamp = t2.timestamp || Lt(), t2.ignoreDuration && (e2.ignoreDuration = t2.ignoreDuration), t2.sid && (e2.sid = 32 === t2.sid.length ? t2.sid : pt()), void 0 !== t2.init && (e2.init = t2.init), !e2.did && t2.did && (e2.did = `${t2.did}`), "number" == typeof t2.started && (e2.started = t2.started), e2.ignoreDuration) e2.duration = void 0;
  else if ("number" == typeof t2.duration) e2.duration = t2.duration;
  else {
    const t3 = e2.timestamp - e2.started;
    e2.duration = t3 >= 0 ? t3 : 0;
  }
  t2.release && (e2.release = t2.release), t2.environment && (e2.environment = t2.environment), !e2.ipAddress && t2.ipAddress && (e2.ipAddress = t2.ipAddress), !e2.userAgent && t2.userAgent && (e2.userAgent = t2.userAgent), "number" == typeof t2.errors && (e2.errors = t2.errors), t2.status && (e2.status = t2.status);
}
var Ht = class _Ht {
  constructor() {
    this._notifyingListeners = false, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = Xt();
  }
  static clone(e2) {
    const t2 = new _Ht();
    return e2 && (t2._breadcrumbs = [...e2._breadcrumbs], t2._tags = { ...e2._tags }, t2._extra = { ...e2._extra }, t2._contexts = { ...e2._contexts }, t2._user = e2._user, t2._level = e2._level, t2._span = e2._span, t2._session = e2._session, t2._transactionName = e2._transactionName, t2._fingerprint = e2._fingerprint, t2._eventProcessors = [...e2._eventProcessors], t2._requestSession = e2._requestSession, t2._attachments = [...e2._attachments], t2._sdkProcessingMetadata = { ...e2._sdkProcessingMetadata }, t2._propagationContext = { ...e2._propagationContext }), t2;
  }
  addScopeListener(e2) {
    this._scopeListeners.push(e2);
  }
  addEventProcessor(e2) {
    return this._eventProcessors.push(e2), this;
  }
  setUser(e2) {
    return this._user = e2 || {}, this._session && Wt(this._session, { user: e2 }), this._notifyScopeListeners(), this;
  }
  getUser() {
    return this._user;
  }
  getRequestSession() {
    return this._requestSession;
  }
  setRequestSession(e2) {
    return this._requestSession = e2, this;
  }
  setTags(e2) {
    return this._tags = { ...this._tags, ...e2 }, this._notifyScopeListeners(), this;
  }
  setTag(e2, t2) {
    return this._tags = { ...this._tags, [e2]: t2 }, this._notifyScopeListeners(), this;
  }
  setExtras(e2) {
    return this._extra = { ...this._extra, ...e2 }, this._notifyScopeListeners(), this;
  }
  setExtra(e2, t2) {
    return this._extra = { ...this._extra, [e2]: t2 }, this._notifyScopeListeners(), this;
  }
  setFingerprint(e2) {
    return this._fingerprint = e2, this._notifyScopeListeners(), this;
  }
  setLevel(e2) {
    return this._level = e2, this._notifyScopeListeners(), this;
  }
  setTransactionName(e2) {
    return this._transactionName = e2, this._notifyScopeListeners(), this;
  }
  setContext(e2, t2) {
    return null === t2 ? delete this._contexts[e2] : this._contexts[e2] = t2, this._notifyScopeListeners(), this;
  }
  setSpan(e2) {
    return this._span = e2, this._notifyScopeListeners(), this;
  }
  getSpan() {
    return this._span;
  }
  getTransaction() {
    const e2 = this.getSpan();
    return e2 && e2.transaction;
  }
  setSession(e2) {
    return e2 ? this._session = e2 : delete this._session, this._notifyScopeListeners(), this;
  }
  getSession() {
    return this._session;
  }
  update(e2) {
    if (!e2) return this;
    if ("function" == typeof e2) {
      const t2 = e2(this);
      return t2 instanceof _Ht ? t2 : this;
    }
    return e2 instanceof _Ht ? (this._tags = { ...this._tags, ...e2._tags }, this._extra = { ...this._extra, ...e2._extra }, this._contexts = { ...this._contexts, ...e2._contexts }, e2._user && Object.keys(e2._user).length && (this._user = e2._user), e2._level && (this._level = e2._level), e2._fingerprint && (this._fingerprint = e2._fingerprint), e2._requestSession && (this._requestSession = e2._requestSession), e2._propagationContext && (this._propagationContext = e2._propagationContext)) : se(e2) && (this._tags = { ...this._tags, ...e2.tags }, this._extra = { ...this._extra, ...e2.extra }, this._contexts = { ...this._contexts, ...e2.contexts }, e2.user && (this._user = e2.user), e2.level && (this._level = e2.level), e2.fingerprint && (this._fingerprint = e2.fingerprint), e2.requestSession && (this._requestSession = e2.requestSession), e2.propagationContext && (this._propagationContext = e2.propagationContext)), this;
  }
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._span = void 0, this._session = void 0, this._notifyScopeListeners(), this._attachments = [], this._propagationContext = Xt(), this;
  }
  addBreadcrumb(e2, t2) {
    const n2 = "number" == typeof t2 ? t2 : 100;
    if (n2 <= 0) return this;
    const r2 = { timestamp: xt(), ...e2 };
    return this._breadcrumbs = [...this._breadcrumbs, r2].slice(-n2), this._notifyScopeListeners(), this;
  }
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  addAttachment(e2) {
    return this._attachments.push(e2), this;
  }
  getAttachments() {
    return this._attachments;
  }
  clearAttachments() {
    return this._attachments = [], this;
  }
  applyToEvent(e2, t2 = {}) {
    if (this._extra && Object.keys(this._extra).length && (e2.extra = { ...this._extra, ...e2.extra }), this._tags && Object.keys(this._tags).length && (e2.tags = { ...this._tags, ...e2.tags }), this._user && Object.keys(this._user).length && (e2.user = { ...this._user, ...e2.user }), this._contexts && Object.keys(this._contexts).length && (e2.contexts = { ...this._contexts, ...e2.contexts }), this._level && (e2.level = this._level), this._transactionName && (e2.transaction = this._transactionName), this._span) {
      e2.contexts = { trace: this._span.getTraceContext(), ...e2.contexts };
      const t3 = this._span.transaction;
      if (t3) {
        e2.sdkProcessingMetadata = { dynamicSamplingContext: t3.getDynamicSamplingContext(), ...e2.sdkProcessingMetadata };
        const n2 = t3.name;
        n2 && (e2.tags = { transaction: n2, ...e2.tags });
      }
    }
    return this._applyFingerprint(e2), e2.breadcrumbs = [...e2.breadcrumbs || [], ...this._breadcrumbs], e2.breadcrumbs = e2.breadcrumbs.length > 0 ? e2.breadcrumbs : void 0, e2.sdkProcessingMetadata = { ...e2.sdkProcessingMetadata, ...this._sdkProcessingMetadata, propagationContext: this._propagationContext }, this._notifyEventProcessors([...Qt(), ...this._eventProcessors], e2, t2);
  }
  setSDKProcessingMetadata(e2) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...e2 }, this;
  }
  setPropagationContext(e2) {
    return this._propagationContext = e2, this;
  }
  getPropagationContext() {
    return this._propagationContext;
  }
  _notifyEventProcessors(e2, t2, n2, r2 = 0) {
    return new Ct((i2, o2) => {
      const a2 = e2[r2];
      if (null === t2 || "function" != typeof a2) i2(t2);
      else {
        const s2 = a2({ ...t2 }, n2);
        ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && a2.id && null === s2 && Ae.log(`Event processor "${a2.id}" dropped event`), le(s2) ? s2.then((t3) => this._notifyEventProcessors(e2, t3, n2, r2 + 1).then(i2)).then(null, o2) : this._notifyEventProcessors(e2, s2, n2, r2 + 1).then(i2).then(null, o2);
      }
    });
  }
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = true, this._scopeListeners.forEach((e2) => {
      e2(this);
    }), this._notifyingListeners = false);
  }
  _applyFingerprint(e2) {
    var t2;
    e2.fingerprint = e2.fingerprint ? (t2 = e2.fingerprint, Array.isArray(t2) ? t2 : [t2]) : [], this._fingerprint && (e2.fingerprint = e2.fingerprint.concat(this._fingerprint)), e2.fingerprint && !e2.fingerprint.length && delete e2.fingerprint;
  }
};
function Qt() {
  return Se("globalEventProcessors", () => []);
}
function Kt(e2) {
  Qt().push(e2);
}
function Xt() {
  return { traceId: pt(), spanId: pt().substring(16), sampled: false };
}
var Zt = 4;
var en = 100;
var tn = class {
  constructor(e2, t2 = new Ht(), n2 = Zt) {
    this._version = n2, this._stack = [{ scope: t2 }], e2 && this.bindClient(e2);
  }
  isOlderThan(e2) {
    return this._version < e2;
  }
  bindClient(e2) {
    this.getStackTop().client = e2, e2 && e2.setupIntegrations && e2.setupIntegrations();
  }
  pushScope() {
    const e2 = Ht.clone(this.getScope());
    return this.getStack().push({ client: this.getClient(), scope: e2 }), e2;
  }
  popScope() {
    return !(this.getStack().length <= 1) && !!this.getStack().pop();
  }
  withScope(e2) {
    const t2 = this.pushScope();
    try {
      e2(t2);
    } finally {
      this.popScope();
    }
  }
  getClient() {
    return this.getStackTop().client;
  }
  getScope() {
    return this.getStackTop().scope;
  }
  getStack() {
    return this._stack;
  }
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  captureException(e2, t2) {
    const n2 = this._lastEventId = t2 && t2.event_id ? t2.event_id : pt(), r2 = new Error("Sentry syntheticException");
    return this._withClient((i2, o2) => {
      i2.captureException(e2, { originalException: e2, syntheticException: r2, ...t2, event_id: n2 }, o2);
    }), n2;
  }
  captureMessage(e2, t2, n2) {
    const r2 = this._lastEventId = n2 && n2.event_id ? n2.event_id : pt(), i2 = new Error(e2);
    return this._withClient((o2, a2) => {
      o2.captureMessage(e2, t2, { originalException: e2, syntheticException: i2, ...n2, event_id: r2 }, a2);
    }), r2;
  }
  captureEvent(e2, t2) {
    const n2 = t2 && t2.event_id ? t2.event_id : pt();
    return e2.type || (this._lastEventId = n2), this._withClient((r2, i2) => {
      r2.captureEvent(e2, { ...t2, event_id: n2 }, i2);
    }), n2;
  }
  lastEventId() {
    return this._lastEventId;
  }
  addBreadcrumb(e2, t2) {
    const { scope: n2, client: r2 } = this.getStackTop();
    if (!r2) return;
    const { beforeBreadcrumb: i2 = null, maxBreadcrumbs: o2 = en } = r2.getOptions && r2.getOptions() || {};
    if (o2 <= 0) return;
    const a2 = { timestamp: xt(), ...e2 }, s2 = i2 ? Oe(() => i2(a2, t2)) : a2;
    null !== s2 && (r2.emit && r2.emit("beforeAddBreadcrumb", s2, t2), n2.addBreadcrumb(s2, o2));
  }
  setUser(e2) {
    this.getScope().setUser(e2);
  }
  setTags(e2) {
    this.getScope().setTags(e2);
  }
  setExtras(e2) {
    this.getScope().setExtras(e2);
  }
  setTag(e2, t2) {
    this.getScope().setTag(e2, t2);
  }
  setExtra(e2, t2) {
    this.getScope().setExtra(e2, t2);
  }
  setContext(e2, t2) {
    this.getScope().setContext(e2, t2);
  }
  configureScope(e2) {
    const { scope: t2, client: n2 } = this.getStackTop();
    n2 && e2(t2);
  }
  run(e2) {
    const t2 = rn(this);
    try {
      e2(this);
    } finally {
      rn(t2);
    }
  }
  getIntegration(e2) {
    const t2 = this.getClient();
    if (!t2) return null;
    try {
      return t2.getIntegration(e2);
    } catch (t3) {
      return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Cannot retrieve integration ${e2.id} from the current Hub`), null;
    }
  }
  startTransaction(e2, t2) {
    const n2 = this._callExtensionMethod("startTransaction", e2, t2);
    return "undefined" != typeof __SENTRY_DEBUG__ && !__SENTRY_DEBUG__ || n2 || console.warn("Tracing extension 'startTransaction' has not been added. Call 'addTracingExtensions' before calling 'init':\nSentry.addTracingExtensions();\nSentry.init({...});\n"), n2;
  }
  traceHeaders() {
    return this._callExtensionMethod("traceHeaders");
  }
  captureSession(e2 = false) {
    if (e2) return this.endSession();
    this._sendSessionUpdate();
  }
  endSession() {
    const e2 = this.getStackTop().scope, t2 = e2.getSession();
    t2 && function(e3, t3) {
      let n2 = {};
      t3 ? n2 = { status: t3 } : "ok" === e3.status && (n2 = { status: "exited" }), Wt(e3, n2);
    }(t2), this._sendSessionUpdate(), e2.setSession();
  }
  startSession(e2) {
    const { scope: t2, client: n2 } = this.getStackTop(), { release: r2, environment: i2 = Yt } = n2 && n2.getOptions() || {}, { userAgent: o2 } = be.navigator || {}, a2 = zt({ release: r2, environment: i2, user: t2.getUser(), ...o2 && { userAgent: o2 }, ...e2 }), s2 = t2.getSession && t2.getSession();
    return s2 && "ok" === s2.status && Wt(s2, { status: "exited" }), this.endSession(), t2.setSession(a2), a2;
  }
  shouldSendDefaultPii() {
    const e2 = this.getClient(), t2 = e2 && e2.getOptions();
    return Boolean(t2 && t2.sendDefaultPii);
  }
  _sendSessionUpdate() {
    const { scope: e2, client: t2 } = this.getStackTop(), n2 = e2.getSession();
    n2 && t2 && t2.captureSession && t2.captureSession(n2);
  }
  _withClient(e2) {
    const { scope: t2, client: n2 } = this.getStackTop();
    n2 && e2(n2, t2);
  }
  _callExtensionMethod(e2, ...t2) {
    const n2 = nn().__SENTRY__;
    if (n2 && n2.extensions && "function" == typeof n2.extensions[e2]) return n2.extensions[e2].apply(this, t2);
    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Extension method ${e2} couldn't be found, doing nothing.`);
  }
};
function nn() {
  return be.__SENTRY__ = be.__SENTRY__ || { extensions: {}, hub: void 0 }, be;
}
function rn(e2) {
  const t2 = nn(), n2 = an(t2);
  return sn(t2, e2), n2;
}
function on() {
  const e2 = nn();
  if (e2.__SENTRY__ && e2.__SENTRY__.acs) {
    const t2 = e2.__SENTRY__.acs.getCurrentHub();
    if (t2) return t2;
  }
  return function(e3 = nn()) {
    t2 = e3, t2 && t2.__SENTRY__ && t2.__SENTRY__.hub && !an(e3).isOlderThan(Zt) || sn(e3, new tn());
    var t2;
    return an(e3);
  }(e2);
}
function an(e2) {
  return Se("hub", () => new tn(), e2);
}
function sn(e2, t2) {
  if (!e2) return false;
  return (e2.__SENTRY__ = e2.__SENTRY__ || {}).hub = t2, true;
}
var cn = "7";
function ln(e2, t2) {
  return n2 = { sentry_key: e2.publicKey, sentry_version: cn, ...t2 && { sentry_client: `${t2.name}/${t2.version}` } }, Object.keys(n2).map((e3) => `${encodeURIComponent(e3)}=${encodeURIComponent(n2[e3])}`).join("&");
  var n2;
}
function un(e2, t2, n2, r2) {
  const i2 = $t(n2), o2 = e2.type && "replay_event" !== e2.type ? e2.type : "event";
  !function(e3, t3) {
    t3 && (e3.sdk = e3.sdk || {}, e3.sdk.name = e3.sdk.name || t3.name, e3.sdk.version = e3.sdk.version || t3.version, e3.sdk.integrations = [...e3.sdk.integrations || [], ...t3.integrations || []], e3.sdk.packages = [...e3.sdk.packages || [], ...t3.packages || []]);
  }(e2, n2 && n2.sdk);
  const a2 = function(e3, t3, n3, r3) {
    const i3 = e3.sdkProcessingMetadata && e3.sdkProcessingMetadata.dynamicSamplingContext;
    return { event_id: e3.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t3 && { sdk: t3 }, ...!!n3 && { dsn: je(r3) }, ...i3 && { trace: $e({ ...i3 }) } };
  }(e2, i2, r2, t2);
  delete e2.sdkProcessingMetadata;
  return It(a2, [[{ type: o2 }, e2]]);
}
var dn = [];
function hn(e2, t2) {
  t2[e2.name] = e2, -1 === dn.indexOf(e2.name) && (e2.setupOnce(Kt, on), dn.push(e2.name), ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log(`Integration installed: ${e2.name}`));
}
function pn(e2, t2, n2, r2) {
  const { normalizeDepth: i2 = 3, normalizeMaxBreadth: o2 = 1e3 } = e2, a2 = { ...t2, event_id: t2.event_id || n2.event_id || pt(), timestamp: t2.timestamp || xt() }, s2 = n2.integrations || e2.integrations.map((e3) => e3.name);
  !function(e3, t3) {
    const { environment: n3, release: r3, dist: i3, maxValueLength: o3 = 250 } = t3;
    "environment" in e3 || (e3.environment = "environment" in t3 ? n3 : Yt);
    void 0 === e3.release && void 0 !== r3 && (e3.release = r3);
    void 0 === e3.dist && void 0 !== i3 && (e3.dist = i3);
    e3.message && (e3.message = de(e3.message, o3));
    const a3 = e3.exception && e3.exception.values && e3.exception.values[0];
    a3 && a3.value && (a3.value = de(a3.value, o3));
    const s3 = e3.request;
    s3 && s3.url && (s3.url = de(s3.url, o3));
  }(a2, e2), function(e3, t3) {
    t3.length > 0 && (e3.sdk = e3.sdk || {}, e3.sdk.integrations = [...e3.sdk.integrations || [], ...t3]);
  }(a2, s2), void 0 === t2.type && function(e3, t3) {
    const n3 = be._sentryDebugIds;
    if (!n3) return;
    let r3;
    const i3 = fn.get(t3);
    i3 ? r3 = i3 : (r3 = /* @__PURE__ */ new Map(), fn.set(t3, r3));
    const o3 = Object.keys(n3).reduce((e4, i4) => {
      let o4;
      const a3 = r3.get(i4);
      a3 ? o4 = a3 : (o4 = t3(i4), r3.set(i4, o4));
      for (let t4 = o4.length - 1; t4 >= 0; t4--) {
        const r4 = o4[t4];
        if (r4.filename) {
          e4[r4.filename] = n3[i4];
          break;
        }
      }
      return e4;
    }, {});
    try {
      e3.exception.values.forEach((e4) => {
        e4.stacktrace.frames.forEach((e5) => {
          e5.filename && (e5.debug_id = o3[e5.filename]);
        });
      });
    } catch (e4) {
    }
  }(a2, e2.stackParser);
  let c2 = r2;
  n2.captureContext && (c2 = Ht.clone(c2).update(n2.captureContext));
  let l2 = kt(a2);
  if (c2) {
    if (c2.getAttachments) {
      const e3 = [...n2.attachments || [], ...c2.getAttachments()];
      e3.length && (n2.attachments = e3);
    }
    l2 = c2.applyToEvent(a2, n2);
  }
  return l2.then((e3) => (e3 && function(e4) {
    const t3 = {};
    try {
      e4.exception.values.forEach((e5) => {
        e5.stacktrace.frames.forEach((e6) => {
          e6.debug_id && (e6.abs_path ? t3[e6.abs_path] = e6.debug_id : e6.filename && (t3[e6.filename] = e6.debug_id), delete e6.debug_id);
        });
      });
    } catch (e5) {
    }
    if (0 === Object.keys(t3).length) return;
    e4.debug_meta = e4.debug_meta || {}, e4.debug_meta.images = e4.debug_meta.images || [];
    const n3 = e4.debug_meta.images;
    Object.keys(t3).forEach((e5) => {
      n3.push({ type: "sourcemap", code_file: e5, debug_id: t3[e5] });
    });
  }(e3), "number" == typeof i2 && i2 > 0 ? function(e4, t3, n3) {
    if (!e4) return null;
    const r3 = { ...e4, ...e4.breadcrumbs && { breadcrumbs: e4.breadcrumbs.map((e5) => ({ ...e5, ...e5.data && { data: _t(e5.data, t3, n3) } })) }, ...e4.user && { user: _t(e4.user, t3, n3) }, ...e4.contexts && { contexts: _t(e4.contexts, t3, n3) }, ...e4.extra && { extra: _t(e4.extra, t3, n3) } };
    e4.contexts && e4.contexts.trace && r3.contexts && (r3.contexts.trace = e4.contexts.trace, e4.contexts.trace.data && (r3.contexts.trace.data = _t(e4.contexts.trace.data, t3, n3)));
    e4.spans && (r3.spans = e4.spans.map((e5) => (e5.data && (e5.data = _t(e5.data, t3, n3)), e5)));
    return r3;
  }(e3, i2, o2) : e3));
}
var fn = /* @__PURE__ */ new WeakMap();
var gn = "Not capturing exception because it's already been captured.";
var vn = class _vn {
  __init() {
    this._integrations = {};
  }
  __init2() {
    this._integrationsInitialized = false;
  }
  __init3() {
    this._numProcessing = 0;
  }
  __init4() {
    this._outcomes = {};
  }
  __init5() {
    this._hooks = {};
  }
  constructor(e2) {
    if (_vn.prototype.__init.call(this), _vn.prototype.__init2.call(this), _vn.prototype.__init3.call(this), _vn.prototype.__init4.call(this), _vn.prototype.__init5.call(this), this._options = e2, e2.dsn ? this._dsn = Le(e2.dsn) : ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("No DSN provided, client will not do anything."), this._dsn) {
      const t2 = function(e3, t3 = {}) {
        const n2 = "string" == typeof t3 ? t3 : t3.tunnel, r2 = "string" != typeof t3 && t3._metadata ? t3._metadata.sdk : void 0;
        return n2 || `${function(e4) {
          return `${function(e5) {
            const t4 = e5.protocol ? `${e5.protocol}:` : "", n3 = e5.port ? `:${e5.port}` : "";
            return `${t4}//${e5.host}${n3}${e5.path ? `/${e5.path}` : ""}/api/`;
          }(e4)}${e4.projectId}/envelope/`;
        }(e3)}?${ln(e3, r2)}`;
      }(this._dsn, e2);
      this._transport = e2.transport({ recordDroppedEvent: this.recordDroppedEvent.bind(this), ...e2.transportOptions, url: t2 });
    }
  }
  captureException(e2, t2, n2) {
    if (yt(e2)) return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log(gn));
    let r2 = t2 && t2.event_id;
    return this._process(this.eventFromException(e2, t2).then((e3) => this._captureEvent(e3, t2, n2)).then((e3) => {
      r2 = e3;
    })), r2;
  }
  captureMessage(e2, t2, n2, r2) {
    let i2 = n2 && n2.event_id;
    const o2 = ae(e2) ? this.eventFromMessage(String(e2), t2, n2) : this.eventFromException(e2, n2);
    return this._process(o2.then((e3) => this._captureEvent(e3, n2, r2)).then((e3) => {
      i2 = e3;
    })), i2;
  }
  captureEvent(e2, t2, n2) {
    if (t2 && t2.originalException && yt(t2.originalException)) return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log(gn));
    let r2 = t2 && t2.event_id;
    return this._process(this._captureEvent(e2, t2, n2).then((e3) => {
      r2 = e3;
    })), r2;
  }
  captureSession(e2) {
    this._isEnabled() ? "string" != typeof e2.release ? ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("Discarded session because of missing or non-string release") : (this.sendSession(e2), Wt(e2, { init: false })) : ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("SDK not enabled, will not capture session.");
  }
  getDsn() {
    return this._dsn;
  }
  getOptions() {
    return this._options;
  }
  getSdkMetadata() {
    return this._options._metadata;
  }
  getTransport() {
    return this._transport;
  }
  flush(e2) {
    const t2 = this._transport;
    return t2 ? this._isClientDoneProcessing(e2).then((n2) => t2.flush(e2).then((e3) => n2 && e3)) : kt(true);
  }
  close(e2) {
    return this.flush(e2).then((e3) => (this.getOptions().enabled = false, e3));
  }
  setupIntegrations() {
    this._isEnabled() && !this._integrationsInitialized && (this._integrations = function(e2) {
      const t2 = {};
      return e2.forEach((e3) => {
        e3 && hn(e3, t2);
      }), t2;
    }(this._options.integrations), this._integrationsInitialized = true);
  }
  getIntegrationById(e2) {
    return this._integrations[e2];
  }
  getIntegration(e2) {
    try {
      return this._integrations[e2.id] || null;
    } catch (t2) {
      return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Cannot retrieve integration ${e2.id} from the current Client`), null;
    }
  }
  addIntegration(e2) {
    hn(e2, this._integrations);
  }
  sendEvent(e2, t2 = {}) {
    if (this._dsn) {
      let n2 = un(e2, this._dsn, this._options._metadata, this._options.tunnel);
      for (const e3 of t2.attachments || []) n2 = Nt(n2, Ut(e3, this._options.transportOptions && this._options.transportOptions.textEncoder));
      const r2 = this._sendEnvelope(n2);
      r2 && r2.then((t3) => this.emit("afterSendEvent", e2, t3), null);
    }
  }
  sendSession(e2) {
    if (this._dsn) {
      const t2 = function(e3, t3, n2, r2) {
        const i2 = $t(n2);
        return It({ sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...i2 && { sdk: i2 }, ...!!r2 && { dsn: je(t3) } }, ["aggregates" in e3 ? [{ type: "sessions" }, e3] : [{ type: "session" }, e3.toJSON()]]);
      }(e2, this._dsn, this._options._metadata, this._options.tunnel);
      this._sendEnvelope(t2);
    }
  }
  recordDroppedEvent(e2, t2, n2) {
    if (this._options.sendClientReports) {
      const n3 = `${e2}:${t2}`;
      ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log(`Adding outcome: "${n3}"`), this._outcomes[n3] = this._outcomes[n3] + 1 || 1;
    }
  }
  on(e2, t2) {
    this._hooks[e2] || (this._hooks[e2] = []), this._hooks[e2].push(t2);
  }
  emit(e2, ...t2) {
    this._hooks[e2] && this._hooks[e2].forEach((e3) => e3(...t2));
  }
  _updateSessionFromEvent(e2, t2) {
    let n2 = false, r2 = false;
    const i2 = t2.exception && t2.exception.values;
    if (i2) {
      r2 = true;
      for (const e3 of i2) {
        const t3 = e3.mechanism;
        if (t3 && false === t3.handled) {
          n2 = true;
          break;
        }
      }
    }
    const o2 = "ok" === e2.status;
    (o2 && 0 === e2.errors || o2 && n2) && (Wt(e2, { ...n2 && { status: "crashed" }, errors: e2.errors || Number(r2 || n2) }), this.captureSession(e2));
  }
  _isClientDoneProcessing(e2) {
    return new Ct((t2) => {
      let n2 = 0;
      const r2 = setInterval(() => {
        0 == this._numProcessing ? (clearInterval(r2), t2(true)) : (n2 += 1, e2 && n2 >= e2 && (clearInterval(r2), t2(false)));
      }, 1);
    });
  }
  _isEnabled() {
    return false !== this.getOptions().enabled && void 0 !== this._dsn;
  }
  _prepareEvent(e2, t2, n2) {
    const r2 = this.getOptions(), i2 = Object.keys(this._integrations);
    return !t2.integrations && i2.length > 0 && (t2.integrations = i2), pn(r2, e2, t2, n2).then((e3) => {
      if (null === e3) return e3;
      const { propagationContext: t3 } = e3.sdkProcessingMetadata || {};
      if (!(e3.contexts && e3.contexts.trace) && t3) {
        const { traceId: r3, spanId: i3, parentSpanId: o2, dsc: a2 } = t3;
        e3.contexts = { trace: { trace_id: r3, span_id: i3, parent_span_id: o2 }, ...e3.contexts };
        const s2 = a2 || function(e4, t4, n3) {
          const r4 = t4.getOptions(), { publicKey: i4 } = t4.getDsn() || {}, { segment: o3 } = n3 && n3.getUser() || {}, a3 = $e({ environment: r4.environment || Yt, release: r4.release, user_segment: o3, public_key: i4, trace_id: e4 });
          return t4.emit && t4.emit("createDsc", a3), a3;
        }(r3, this, n2);
        e3.sdkProcessingMetadata = { dynamicSamplingContext: s2, ...e3.sdkProcessingMetadata };
      }
      return e3;
    });
  }
  _captureEvent(e2, t2 = {}, n2) {
    return this._processEvent(e2, t2, n2).then((e3) => e3.event_id, (e3) => {
      if ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) {
        const t3 = e3;
        "log" === t3.logLevel ? Ae.log(t3.message) : Ae.warn(t3);
      }
    });
  }
  _processEvent(e2, t2, n2) {
    const r2 = this.getOptions(), { sampleRate: i2 } = r2;
    if (!this._isEnabled()) return Et(new Ie("SDK not enabled, will not capture event.", "log"));
    const o2 = yn(e2), a2 = mn(e2), s2 = e2.type || "error", c2 = `before send for type \`${s2}\``;
    if (a2 && "number" == typeof i2 && Math.random() > i2) return this.recordDroppedEvent("sample_rate", "error", e2), Et(new Ie(`Discarding event because it's not included in the random sample (sampling rate = ${i2})`, "log"));
    const l2 = "replay_event" === s2 ? "replay" : s2;
    return this._prepareEvent(e2, t2, n2).then((n3) => {
      if (null === n3) throw this.recordDroppedEvent("event_processor", l2, e2), new Ie("An event processor returned `null`, will not send event.", "log");
      if (t2.data && true === t2.data.__sentry__) return n3;
      const i3 = function(e3, t3, n4) {
        const { beforeSend: r3, beforeSendTransaction: i4 } = e3;
        if (mn(t3) && r3) return r3(t3, n4);
        if (yn(t3) && i4) return i4(t3, n4);
        return t3;
      }(r2, n3, t2);
      return function(e3, t3) {
        const n4 = `${t3} must return \`null\` or a valid event.`;
        if (le(e3)) return e3.then((e4) => {
          if (!se(e4) && null !== e4) throw new Ie(n4);
          return e4;
        }, (e4) => {
          throw new Ie(`${t3} rejected with ${e4}`);
        });
        if (!se(e3) && null !== e3) throw new Ie(n4);
        return e3;
      }(i3, c2);
    }).then((r3) => {
      if (null === r3) throw this.recordDroppedEvent("before_send", l2, e2), new Ie(`${c2} returned \`null\`, will not send event.`, "log");
      const i3 = n2 && n2.getSession();
      !o2 && i3 && this._updateSessionFromEvent(i3, r3);
      const a3 = r3.transaction_info;
      if (o2 && a3 && r3.transaction !== e2.transaction) {
        const e3 = "custom";
        r3.transaction_info = { ...a3, source: e3 };
      }
      return this.sendEvent(r3, t2), r3;
    }).then(null, (e3) => {
      if (e3 instanceof Ie) throw e3;
      throw this.captureException(e3, { data: { __sentry__: true }, originalException: e3 }), new Ie(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${e3}`);
    });
  }
  _process(e2) {
    this._numProcessing++, e2.then((e3) => (this._numProcessing--, e3), (e3) => (this._numProcessing--, e3));
  }
  _sendEnvelope(e2) {
    if (this._transport && this._dsn) return this.emit("beforeEnvelope", e2), this._transport.send(e2).then(null, (e3) => {
      ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.error("Error while sending event:", e3);
    });
    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.error("Transport disabled");
  }
  _clearOutcomes() {
    const e2 = this._outcomes;
    return this._outcomes = {}, Object.keys(e2).map((t2) => {
      const [n2, r2] = t2.split(":");
      return { reason: n2, category: r2, quantity: e2[t2] };
    });
  }
};
function mn(e2) {
  return void 0 === e2.type;
}
function yn(e2) {
  return "transaction" === e2.type;
}
var _n = 30;
function bn(e2, t2, n2 = Mt(e2.bufferSize || _n)) {
  let r2 = {};
  function i2(i3) {
    const o2 = [];
    if (Rt(i3, (t3, n3) => {
      const i4 = Jt(n3);
      if (function(e3, t4, n4 = Date.now()) {
        return function(e4, t5) {
          return e4[t5] || e4.all || 0;
        }(e3, t4) > n4;
      }(r2, i4)) {
        const r3 = wn(t3, n3);
        e2.recordDroppedEvent("ratelimit_backoff", i4, r3);
      } else o2.push(t3);
    }), 0 === o2.length) return kt();
    const a2 = It(i3[0], o2), s2 = (t3) => {
      Rt(a2, (n3, r3) => {
        const i4 = wn(n3, r3);
        e2.recordDroppedEvent(t3, Jt(r3), i4);
      });
    };
    return n2.add(() => t2({ body: Ft(a2, e2.textEncoder) }).then((e3) => (void 0 !== e3.statusCode && (e3.statusCode < 200 || e3.statusCode >= 300) && ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Sentry responded with status code ${e3.statusCode} to sent event.`), r2 = qt(r2, e3), e3), (e3) => {
      throw s2("network_error"), e3;
    })).then((e3) => e3, (e3) => {
      if (e3 instanceof Ie) return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.error("Skipped sending event because buffer is full."), s2("queue_overflow"), kt();
      throw e3;
    });
  }
  return i2.__sentry__baseTransport__ = true, { send: i2, flush: (e3) => n2.drain(e3) };
}
function wn(e2, t2) {
  if ("event" === t2 || "transaction" === t2) return Array.isArray(e2) ? e2[1] : void 0;
}
var Sn = "7.60.1";
var kn;
var En = class _En {
  constructor() {
    _En.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "FunctionToString";
  }
  __init() {
    this.name = _En.id;
  }
  setupOnce() {
    kn = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...e2) {
        const t2 = Fe(this) || this;
        return kn.apply(t2, e2);
      };
    } catch (e2) {
    }
  }
};
En.__initStatic();
var Cn = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
var Mn = [/^.*healthcheck.*$/, /^.*healthy.*$/, /^.*live.*$/, /^.*ready.*$/, /^.*heartbeat.*$/, /^.*\/health$/, /^.*\/healthz$/];
var Tn = class _Tn {
  static __initStatic() {
    this.id = "InboundFilters";
  }
  __init() {
    this.name = _Tn.id;
  }
  constructor(e2 = {}) {
    this._options = e2, _Tn.prototype.__init.call(this);
  }
  setupOnce(e2, t2) {
    const n2 = (e3) => {
      const n3 = t2();
      if (n3) {
        const t3 = n3.getIntegration(_Tn);
        if (t3) {
          const r2 = n3.getClient(), i2 = r2 ? r2.getOptions() : {}, o2 = function(e4 = {}, t4 = {}) {
            return { allowUrls: [...e4.allowUrls || [], ...t4.allowUrls || []], denyUrls: [...e4.denyUrls || [], ...t4.denyUrls || []], ignoreErrors: [...e4.ignoreErrors || [], ...t4.ignoreErrors || [], ...e4.disableErrorDefaults ? [] : Cn], ignoreTransactions: [...e4.ignoreTransactions || [], ...t4.ignoreTransactions || [], ...e4.disableTransactionDefaults ? [] : Mn], ignoreInternal: void 0 === e4.ignoreInternal || e4.ignoreInternal };
          }(t3._options, i2);
          return function(e4, t4) {
            if (t4.ignoreInternal && function(e5) {
              try {
                return "SentryError" === e5.exception.values[0].type;
              } catch (e6) {
              }
              return false;
            }(e4)) return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Event dropped due to being internal Sentry Error.
Event: ${gt(e4)}`), true;
            if (function(e5, t5) {
              if (e5.type || !t5 || !t5.length) return false;
              return function(e6) {
                if (e6.message) return [e6.message];
                if (e6.exception) {
                  const { values: t6 } = e6.exception;
                  try {
                    const { type: e7 = "", value: n4 = "" } = t6 && t6[t6.length - 1] || {};
                    return [`${n4}`, `${e7}: ${n4}`];
                  } catch (t7) {
                    return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.error(`Cannot extract message for event ${gt(e6)}`), [];
                  }
                }
                return [];
              }(e5).some((e6) => fe(e6, t5));
            }(e4, t4.ignoreErrors)) return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${gt(e4)}`), true;
            if (function(e5, t5) {
              if ("transaction" !== e5.type || !t5 || !t5.length) return false;
              const n4 = e5.transaction;
              return !!n4 && fe(n4, t5);
            }(e4, t4.ignoreTransactions)) return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${gt(e4)}`), true;
            if (function(e5, t5) {
              if (!t5 || !t5.length) return false;
              const n4 = On(e5);
              return !!n4 && fe(n4, t5);
            }(e4, t4.denyUrls)) return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${gt(e4)}.
Url: ${On(e4)}`), true;
            if (!function(e5, t5) {
              if (!t5 || !t5.length) return true;
              const n4 = On(e5);
              return !n4 || fe(n4, t5);
            }(e4, t4.allowUrls)) return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${gt(e4)}.
Url: ${On(e4)}`), true;
            return false;
          }(e3, o2) ? null : e3;
        }
      }
      return e3;
    };
    n2.id = this.name, e2(n2);
  }
};
function On(e2) {
  try {
    let t2;
    try {
      t2 = e2.exception.values[0].stacktrace.frames;
    } catch (e3) {
    }
    return t2 ? function(e3 = []) {
      for (let t3 = e3.length - 1; t3 >= 0; t3--) {
        const n2 = e3[t3];
        if (n2 && "<anonymous>" !== n2.filename && "[native code]" !== n2.filename) return n2.filename || null;
      }
      return null;
    }(t2) : null;
  } catch (t2) {
    return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.error(`Cannot extract url for event ${gt(e2)}`), null;
  }
}
Tn.__initStatic();
var Pn = Object.freeze({ __proto__: null, FunctionToString: En, InboundFilters: Tn });
var An = be;
var Dn = 0;
function jn() {
  return Dn > 0;
}
function xn(e2, t2 = {}, n2) {
  if ("function" != typeof e2) return e2;
  try {
    const t3 = e2.__sentry_wrapped__;
    if (t3) return t3;
    if (Fe(e2)) return e2;
  } catch (t3) {
    return e2;
  }
  const r2 = function() {
    const r3 = Array.prototype.slice.call(arguments);
    try {
      n2 && "function" == typeof n2 && n2.apply(this, arguments);
      const i3 = r3.map((e3) => xn(e3, t2));
      return e2.apply(this, i3);
    } catch (e3) {
      throw Dn++, setTimeout(() => {
        Dn--;
      }), i2 = (n3) => {
        var i3, o2;
        n3.addEventProcessor((e4) => (t2.mechanism && (vt(e4, void 0, void 0), mt(e4, t2.mechanism)), e4.extra = { ...e4.extra, arguments: r3 }, e4)), i3 = e3, on().captureException(i3, { captureContext: o2 });
      }, on().withScope(i2), e3;
    }
    var i2;
  };
  try {
    for (const t3 in e2) Object.prototype.hasOwnProperty.call(e2, t3) && (r2[t3] = e2[t3]);
  } catch (e3) {
  }
  Be(r2, e2), Re(e2, "__sentry_wrapped__", r2);
  try {
    Object.getOwnPropertyDescriptor(r2, "name").configurable && Object.defineProperty(r2, "name", { get: () => e2.name });
  } catch (e3) {
  }
  return r2;
}
function Ln(e2, t2) {
  const n2 = Nn(e2, t2), r2 = { type: t2 && t2.name, value: Bn(t2) };
  return n2.length && (r2.stacktrace = { frames: n2 }), void 0 === r2.type && "" === r2.value && (r2.value = "Unrecoverable error caught"), r2;
}
function In(e2, t2) {
  return { exception: { values: [Ln(e2, t2)] } };
}
function Nn(e2, t2) {
  const n2 = t2.stacktrace || t2.stack || "", r2 = function(e3) {
    if (e3) {
      if ("number" == typeof e3.framesToPop) return e3.framesToPop;
      if (Rn.test(e3.message)) return 1;
    }
    return 0;
  }(t2);
  try {
    return e2(n2, r2);
  } catch (e3) {
  }
  return [];
}
var Rn = /Minified React error #\d+;/i;
function Bn(e2) {
  const t2 = e2 && e2.message;
  return t2 ? t2.error && "string" == typeof t2.error.message ? t2.error.message : t2 : "No error message";
}
function Fn(e2, t2, n2, r2, i2) {
  let o2;
  if (re(t2) && t2.error) {
    return In(e2, t2.error);
  }
  if (ie(t2) || ne(t2, "DOMException")) {
    const i3 = t2;
    if ("stack" in t2) o2 = In(e2, t2);
    else {
      const t3 = i3.name || (ie(i3) ? "DOMError" : "DOMException"), a2 = i3.message ? `${t3}: ${i3.message}` : t3;
      o2 = Un(e2, a2, n2, r2), vt(o2, a2);
    }
    return "code" in i3 && (o2.tags = { ...o2.tags, "DOMException.code": `${i3.code}` }), o2;
  }
  if (te(t2)) return In(e2, t2);
  if (se(t2) || ce(t2)) {
    return o2 = function(e3, t3, n3, r3) {
      const i3 = on().getClient(), o3 = i3 && i3.getOptions().normalizeDepth, a2 = { exception: { values: [{ type: ce(t3) ? t3.constructor.name : r3 ? "UnhandledRejection" : "Error", value: Vn(t3, { isUnhandledRejection: r3 }) }] }, extra: { __serialized__: bt(t3, o3) } };
      if (n3) {
        const t4 = Nn(e3, n3);
        t4.length && (a2.exception.values[0].stacktrace = { frames: t4 });
      }
      return a2;
    }(e2, t2, n2, i2), mt(o2, { synthetic: true }), o2;
  }
  return o2 = Un(e2, t2, n2, r2), vt(o2, `${t2}`, void 0), mt(o2, { synthetic: true }), o2;
}
function Un(e2, t2, n2, r2) {
  const i2 = { message: t2 };
  if (r2 && n2) {
    const r3 = Nn(e2, n2);
    r3.length && (i2.exception = { values: [{ value: t2, stacktrace: { frames: r3 } }] });
  }
  return i2;
}
function Vn(e2, { isUnhandledRejection: t2 }) {
  const n2 = function(e3, t3 = 40) {
    const n3 = Object.keys(Ue(e3));
    if (n3.sort(), !n3.length) return "[object has no keys]";
    if (n3[0].length >= t3) return de(n3[0], t3);
    for (let e4 = n3.length; e4 > 0; e4--) {
      const r3 = n3.slice(0, e4).join(", ");
      if (!(r3.length > t3)) return e4 === n3.length ? r3 : de(r3, t3);
    }
    return "";
  }(e2), r2 = t2 ? "promise rejection" : "exception";
  if (re(e2)) return `Event \`ErrorEvent\` captured as ${r2} with message \`${e2.message}\``;
  if (ce(e2)) {
    return `Event \`${function(e3) {
      try {
        const t3 = Object.getPrototypeOf(e3);
        return t3 ? t3.constructor.name : void 0;
      } catch (e4) {
      }
    }(e2)}\` (type=${e2.type}) captured as ${r2}`;
  }
  return `Object captured as ${r2} with keys: ${n2}`;
}
var Jn = 1024;
var $n = "Breadcrumbs";
var Gn = class _Gn {
  static __initStatic() {
    this.id = $n;
  }
  __init() {
    this.name = _Gn.id;
  }
  constructor(e2) {
    _Gn.prototype.__init.call(this), this.options = { console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true, ...e2 };
  }
  setupOnce() {
    this.options.console && nt("console", qn), this.options.dom && nt("dom", /* @__PURE__ */ function(e2) {
      function t2(t3) {
        let n2, r2 = "object" == typeof e2 ? e2.serializeAttribute : void 0, i2 = "object" == typeof e2 && "number" == typeof e2.maxStringLength ? e2.maxStringLength : void 0;
        i2 && i2 > Jn && (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn(`\`dom.maxStringLength\` cannot exceed 1024, but a value of ${i2} was configured. Sentry will use 1024 instead.`), i2 = Jn), "string" == typeof r2 && (r2 = [r2]);
        try {
          const e3 = t3.event;
          n2 = function(e4) {
            return !!e4 && !!e4.target;
          }(e3) ? Ce(e3.target, { keyAttrs: r2, maxStringLength: i2 }) : Ce(e3, { keyAttrs: r2, maxStringLength: i2 });
        } catch (e3) {
          n2 = "<unknown>";
        }
        0 !== n2.length && on().addBreadcrumb({ category: `ui.${t3.name}`, message: n2 }, { event: t3.event, name: t3.name, global: t3.global });
      }
      return t2;
    }(this.options.dom)), this.options.xhr && nt("xhr", Yn), this.options.fetch && nt("fetch", zn), this.options.history && nt("history", Wn);
  }
  addSentryBreadcrumb(e2) {
    this.options.sentry && on().addBreadcrumb({ category: "sentry." + ("transaction" === e2.type ? "transaction" : "event"), event_id: e2.event_id, level: e2.level, message: gt(e2) }, { event: e2 });
  }
};
function qn(e2) {
  for (let t3 = 0; t3 < e2.args.length; t3++) if ("ref=Ref<" === e2.args[t3]) {
    e2.args[t3 + 1] = "viewRef";
    break;
  }
  const t2 = { category: "console", data: { arguments: e2.args, logger: "console" }, level: (n2 = e2.level, "warn" === n2 ? "warning" : Ot.includes(n2) ? n2 : "log"), message: he(e2.args, " ") };
  var n2;
  if ("assert" === e2.level) {
    if (false !== e2.args[0]) return;
    t2.message = `Assertion failed: ${he(e2.args.slice(1), " ") || "console.assert"}`, t2.data.arguments = e2.args.slice(1);
  }
  on().addBreadcrumb(t2, { input: e2.args, level: e2.level });
}
function Yn(e2) {
  const { startTimestamp: t2, endTimestamp: n2 } = e2, r2 = e2.xhr[Xe];
  if (!t2 || !n2 || !r2) return;
  const { method: i2, url: o2, status_code: a2, body: s2 } = r2, c2 = { method: i2, url: o2, status_code: a2 }, l2 = { xhr: e2.xhr, input: s2, startTimestamp: t2, endTimestamp: n2 };
  on().addBreadcrumb({ category: "xhr", data: c2, type: "http" }, l2);
}
function zn(e2) {
  const { startTimestamp: t2, endTimestamp: n2 } = e2;
  if (n2 && (!e2.fetchData.url.match(/sentry_key/) || "POST" !== e2.fetchData.method)) if (e2.error) {
    const r2 = e2.fetchData, i2 = { data: e2.error, input: e2.args, startTimestamp: t2, endTimestamp: n2 };
    on().addBreadcrumb({ category: "fetch", data: r2, level: "error", type: "http" }, i2);
  } else {
    const r2 = { ...e2.fetchData, status_code: e2.response && e2.response.status }, i2 = { input: e2.args, response: e2.response, startTimestamp: t2, endTimestamp: n2 };
    on().addBreadcrumb({ category: "fetch", data: r2, type: "http" }, i2);
  }
}
function Wn(e2) {
  let t2 = e2.from, n2 = e2.to;
  const r2 = Tt(An.location.href);
  let i2 = Tt(t2);
  const o2 = Tt(n2);
  i2.path || (i2 = r2), r2.protocol === o2.protocol && r2.host === o2.host && (n2 = o2.relative), r2.protocol === i2.protocol && r2.host === i2.host && (t2 = i2.relative), on().addBreadcrumb({ category: "navigation", data: { from: t2, to: n2 } });
}
Gn.__initStatic();
var Hn = class extends vn {
  constructor(e2) {
    const t2 = An.SENTRY_SDK_SOURCE || "npm";
    e2._metadata = e2._metadata || {}, e2._metadata.sdk = e2._metadata.sdk || { name: "sentry.javascript.browser", packages: [{ name: `${t2}:@sentry/browser`, version: Sn }], version: Sn }, super(e2), e2.sendClientReports && An.document && An.document.addEventListener("visibilitychange", () => {
      "hidden" === An.document.visibilityState && this._flushOutcomes();
    });
  }
  eventFromException(e2, t2) {
    return function(e3, t3, n2, r2) {
      const i2 = Fn(e3, t3, n2 && n2.syntheticException || void 0, r2);
      return mt(i2), i2.level = "error", n2 && n2.event_id && (i2.event_id = n2.event_id), kt(i2);
    }(this._options.stackParser, e2, t2, this._options.attachStacktrace);
  }
  eventFromMessage(e2, t2 = "info", n2) {
    return function(e3, t3, n3 = "info", r2, i2) {
      const o2 = Un(e3, t3, r2 && r2.syntheticException || void 0, i2);
      return o2.level = n3, r2 && r2.event_id && (o2.event_id = r2.event_id), kt(o2);
    }(this._options.stackParser, e2, t2, n2, this._options.attachStacktrace);
  }
  sendEvent(e2, t2) {
    const n2 = this.getIntegrationById($n);
    n2 && n2.addSentryBreadcrumb && n2.addSentryBreadcrumb(e2), super.sendEvent(e2, t2);
  }
  captureUserFeedback(e2) {
    if (!this._isEnabled()) return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("SDK not enabled, will not capture user feedback."));
    const t2 = function(e3, { metadata: t3, tunnel: n2, dsn: r2 }) {
      const i2 = { event_id: e3.event_id, sent_at: (/* @__PURE__ */ new Date()).toISOString(), ...t3 && t3.sdk && { sdk: { name: t3.sdk.name, version: t3.sdk.version } }, ...!!n2 && !!r2 && { dsn: je(r2) } }, o2 = /* @__PURE__ */ function(e4) {
        return [{ type: "user_report" }, e4];
      }(e3);
      return It(i2, [o2]);
    }(e2, { metadata: this.getSdkMetadata(), dsn: this.getDsn(), tunnel: this.getOptions().tunnel });
    this._sendEnvelope(t2);
  }
  _prepareEvent(e2, t2, n2) {
    return e2.platform = e2.platform || "javascript", super._prepareEvent(e2, t2, n2);
  }
  _flushOutcomes() {
    const e2 = this._clearOutcomes();
    if (0 === e2.length) return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log("No outcomes to send"));
    if (!this._dsn) return void (("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log("No dsn provided, will not send outcomes"));
    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log("Sending outcomes:", e2);
    const t2 = (n2 = e2, It((r2 = this._options.tunnel && je(this._dsn)) ? { dsn: r2 } : {}, [[{ type: "client_report" }, { timestamp: i2 || xt(), discarded_events: n2 }]]));
    var n2, r2, i2;
    this._sendEnvelope(t2);
  }
};
var Qn;
function Kn(e2, t2 = function() {
  if (Qn) return Qn;
  if (We(An.fetch)) return Qn = An.fetch.bind(An);
  const e3 = An.document;
  let t3 = An.fetch;
  if (e3 && "function" == typeof e3.createElement) try {
    const n2 = e3.createElement("iframe");
    n2.hidden = true, e3.head.appendChild(n2);
    const r2 = n2.contentWindow;
    r2 && r2.fetch && (t3 = r2.fetch), e3.head.removeChild(n2);
  } catch (e4) {
    ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", e4);
  }
  return Qn = t3.bind(An);
}()) {
  let n2 = 0, r2 = 0;
  return bn(e2, function(i2) {
    const o2 = i2.body.length;
    n2 += o2, r2++;
    const a2 = { body: i2.body, method: "POST", referrerPolicy: "origin", headers: e2.headers, keepalive: n2 <= 6e4 && r2 < 15, ...e2.fetchOptions };
    try {
      return t2(e2.url, a2).then((e3) => (n2 -= o2, r2--, { statusCode: e3.status, headers: { "x-sentry-rate-limits": e3.headers.get("X-Sentry-Rate-Limits"), "retry-after": e3.headers.get("Retry-After") } }));
    } catch (e3) {
      return Qn = void 0, n2 -= o2, r2--, Et(e3);
    }
  });
}
var Xn = class _Xn {
  static __initStatic() {
    this.id = "GlobalHandlers";
  }
  __init() {
    this.name = _Xn.id;
  }
  __init2() {
    this._installFunc = { onerror: Zn, onunhandledrejection: er };
  }
  constructor(e2) {
    _Xn.prototype.__init.call(this), _Xn.prototype.__init2.call(this), this._options = { onerror: true, onunhandledrejection: true, ...e2 };
  }
  setupOnce() {
    Error.stackTraceLimit = 50;
    const e2 = this._options;
    for (const n2 in e2) {
      const r2 = this._installFunc[n2];
      r2 && e2[n2] && (t2 = n2, ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.log(`Global Handler attached: ${t2}`), r2(), this._installFunc[n2] = void 0);
    }
    var t2;
  }
};
function Zn() {
  nt("error", (e2) => {
    const [t2, n2, r2] = rr();
    if (!t2.getIntegration(Xn)) return;
    const { msg: i2, url: o2, line: a2, column: s2, error: c2 } = e2;
    if (jn() || c2 && c2.__sentry_own_request__) return;
    const l2 = void 0 === c2 && oe(i2) ? function(e3, t3, n3, r3) {
      const i3 = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
      let o3 = re(e3) ? e3.message : e3, a3 = "Error";
      const s3 = o3.match(i3);
      s3 && (a3 = s3[1], o3 = s3[2]);
      const c3 = { exception: { values: [{ type: a3, value: o3 }] } };
      return tr(c3, t3, n3, r3);
    }(i2, o2, a2, s2) : tr(Fn(n2, c2 || i2, void 0, r2, false), o2, a2, s2);
    l2.level = "error", nr(t2, c2, l2, "onerror");
  });
}
function er() {
  nt("unhandledrejection", (e2) => {
    const [t2, n2, r2] = rr();
    if (!t2.getIntegration(Xn)) return;
    let i2 = e2;
    try {
      "reason" in e2 ? i2 = e2.reason : "detail" in e2 && "reason" in e2.detail && (i2 = e2.detail.reason);
    } catch (e3) {
    }
    if (jn() || i2 && i2.__sentry_own_request__) return true;
    const o2 = ae(i2) ? { exception: { values: [{ type: "UnhandledRejection", value: `Non-Error promise rejection captured with value: ${String(i2)}` }] } } : Fn(n2, i2, void 0, r2, true);
    o2.level = "error", nr(t2, i2, o2, "onunhandledrejection");
  });
}
function tr(e2, t2, n2, r2) {
  const i2 = e2.exception = e2.exception || {}, o2 = i2.values = i2.values || [], a2 = o2[0] = o2[0] || {}, s2 = a2.stacktrace = a2.stacktrace || {}, c2 = s2.frames = s2.frames || [], l2 = isNaN(parseInt(r2, 10)) ? void 0 : r2, u2 = isNaN(parseInt(n2, 10)) ? void 0 : n2, d2 = oe(t2) && t2.length > 0 ? t2 : function() {
    try {
      return ke.document.location.href;
    } catch (e3) {
      return "";
    }
  }();
  return 0 === c2.length && c2.push({ colno: l2, filename: d2, function: "?", in_app: true, lineno: u2 }), e2;
}
function nr(e2, t2, n2, r2) {
  mt(n2, { handled: false, type: r2 }), e2.captureEvent(n2, { originalException: t2 });
}
function rr() {
  const e2 = on(), t2 = e2.getClient(), n2 = t2 && t2.getOptions() || { stackParser: () => [], attachStacktrace: false };
  return [e2, n2.stackParser, n2.attachStacktrace];
}
Xn.__initStatic();
var ir = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"];
var or = class _or {
  static __initStatic() {
    this.id = "TryCatch";
  }
  __init() {
    this.name = _or.id;
  }
  constructor(e2) {
    _or.prototype.__init.call(this), this._options = { XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true, ...e2 };
  }
  setupOnce() {
    this._options.setTimeout && Ne(An, "setTimeout", ar), this._options.setInterval && Ne(An, "setInterval", ar), this._options.requestAnimationFrame && Ne(An, "requestAnimationFrame", sr), this._options.XMLHttpRequest && "XMLHttpRequest" in An && Ne(XMLHttpRequest.prototype, "send", cr);
    const e2 = this._options.eventTarget;
    if (e2) {
      (Array.isArray(e2) ? e2 : ir).forEach(lr);
    }
  }
};
function ar(e2) {
  return function(...t2) {
    const n2 = t2[0];
    return t2[0] = xn(n2, { mechanism: { data: { function: Ye(e2) }, handled: true, type: "instrument" } }), e2.apply(this, t2);
  };
}
function sr(e2) {
  return function(t2) {
    return e2.apply(this, [xn(t2, { mechanism: { data: { function: "requestAnimationFrame", handler: Ye(e2) }, handled: true, type: "instrument" } })]);
  };
}
function cr(e2) {
  return function(...t2) {
    const n2 = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((e3) => {
      e3 in n2 && "function" == typeof n2[e3] && Ne(n2, e3, function(t3) {
        const n3 = { mechanism: { data: { function: e3, handler: Ye(t3) }, handled: true, type: "instrument" } }, r2 = Fe(t3);
        return r2 && (n3.mechanism.data.handler = Ye(r2)), xn(t3, n3);
      });
    }), e2.apply(this, t2);
  };
}
function lr(e2) {
  const t2 = An, n2 = t2[e2] && t2[e2].prototype;
  n2 && n2.hasOwnProperty && n2.hasOwnProperty("addEventListener") && (Ne(n2, "addEventListener", function(t3) {
    return function(n3, r2, i2) {
      try {
        "function" == typeof r2.handleEvent && (r2.handleEvent = xn(r2.handleEvent, { mechanism: { data: { function: "handleEvent", handler: Ye(r2), target: e2 }, handled: true, type: "instrument" } }));
      } catch (e3) {
      }
      return t3.apply(this, [n3, xn(r2, { mechanism: { data: { function: "addEventListener", handler: Ye(r2), target: e2 }, handled: true, type: "instrument" } }), i2]);
    };
  }), Ne(n2, "removeEventListener", function(e3) {
    return function(t3, n3, r2) {
      const i2 = n3;
      try {
        const n4 = i2 && i2.__sentry_wrapped__;
        n4 && e3.call(this, t3, n4, r2);
      } catch (e4) {
      }
      return e3.call(this, t3, i2, r2);
    };
  }));
}
or.__initStatic();
var ur = class _ur {
  static __initStatic() {
    this.id = "LinkedErrors";
  }
  __init() {
    this.name = _ur.id;
  }
  constructor(e2 = {}) {
    _ur.prototype.__init.call(this), this._key = e2.key || "cause", this._limit = e2.limit || 5;
  }
  setupOnce(e2, t2) {
    e2((e3, n2) => {
      const r2 = t2(), i2 = r2.getClient(), o2 = r2.getIntegration(_ur);
      if (!i2 || !o2) return e3;
      const a2 = i2.getOptions();
      return ge(Ln, a2.stackParser, a2.maxValueLength, o2._key, o2._limit, e3, n2), e3;
    });
  }
};
ur.__initStatic();
var dr = class _dr {
  constructor() {
    _dr.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "HttpContext";
  }
  __init() {
    this.name = _dr.id;
  }
  setupOnce() {
    Kt((e2) => {
      if (on().getIntegration(_dr)) {
        if (!An.navigator && !An.location && !An.document) return e2;
        const t2 = e2.request && e2.request.url || An.location && An.location.href, { referrer: n2 } = An.document || {}, { userAgent: r2 } = An.navigator || {}, i2 = { ...e2.request && e2.request.headers, ...n2 && { Referer: n2 }, ...r2 && { "User-Agent": r2 } }, o2 = { ...e2.request, ...t2 && { url: t2 }, headers: i2 };
        return { ...e2, request: o2 };
      }
      return e2;
    });
  }
};
dr.__initStatic();
var hr = class _hr {
  constructor() {
    _hr.prototype.__init.call(this);
  }
  static __initStatic() {
    this.id = "Dedupe";
  }
  __init() {
    this.name = _hr.id;
  }
  setupOnce(e2, t2) {
    const n2 = (e3) => {
      if (e3.type) return e3;
      const n3 = t2().getIntegration(_hr);
      if (n3) {
        try {
          if (function(e4, t3) {
            if (!t3) return false;
            if (function(e5, t4) {
              const n4 = e5.message, r2 = t4.message;
              if (!n4 && !r2) return false;
              if (n4 && !r2 || !n4 && r2) return false;
              if (n4 !== r2) return false;
              if (!fr(e5, t4)) return false;
              if (!pr(e5, t4)) return false;
              return true;
            }(e4, t3)) return true;
            if (function(e5, t4) {
              const n4 = gr(t4), r2 = gr(e5);
              if (!n4 || !r2) return false;
              if (n4.type !== r2.type || n4.value !== r2.value) return false;
              if (!fr(e5, t4)) return false;
              if (!pr(e5, t4)) return false;
              return true;
            }(e4, t3)) return true;
            return false;
          }(e3, n3._previousEvent)) return ("undefined" == typeof __SENTRY_DEBUG__ || __SENTRY_DEBUG__) && Ae.warn("Event dropped due to being a duplicate of previously captured event."), null;
        } catch (t3) {
          return n3._previousEvent = e3;
        }
        return n3._previousEvent = e3;
      }
      return e3;
    };
    n2.id = this.name, e2(n2);
  }
};
function pr(e2, t2) {
  let n2 = vr(e2), r2 = vr(t2);
  if (!n2 && !r2) return true;
  if (n2 && !r2 || !n2 && r2) return false;
  if (r2.length !== n2.length) return false;
  for (let e3 = 0; e3 < r2.length; e3++) {
    const t3 = r2[e3], i2 = n2[e3];
    if (t3.filename !== i2.filename || t3.lineno !== i2.lineno || t3.colno !== i2.colno || t3.function !== i2.function) return false;
  }
  return true;
}
function fr(e2, t2) {
  let n2 = e2.fingerprint, r2 = t2.fingerprint;
  if (!n2 && !r2) return true;
  if (n2 && !r2 || !n2 && r2) return false;
  try {
    return !(n2.join("") !== r2.join(""));
  } catch (e3) {
    return false;
  }
}
function gr(e2) {
  return e2.exception && e2.exception.values && e2.exception.values[0];
}
function vr(e2) {
  const t2 = e2.exception;
  if (t2) try {
    return t2.values[0].stacktrace.frames;
  } catch (e3) {
    return;
  }
}
hr.__initStatic();
var mr = Object.freeze({ __proto__: null, Breadcrumbs: Gn, Dedupe: hr, GlobalHandlers: Xn, HttpContext: dr, LinkedErrors: ur, TryCatch: or });
var yr = {};
An.Sentry && An.Sentry.Integrations && (yr = An.Sentry.Integrations);
var _r = { ...yr, ...Pn, ...mr };
var br = "new";
var wr = "loading";
var Sr = "loaded";
var kr = "joining-meeting";
var Er = "joined-meeting";
var Cr = "left-meeting";
var Mr = "error";
var xr = "unknown";
var Lr = "full";
var Rr = "base";
var Br = "*";
var ri = "iframe-ready-for-launch-config";
var ii = "iframe-launch-config";
var oi = "theme-updated";
var ai = "loading";
var si = "load-attempt-failed";
var ci = "loaded";
var li = "started-camera";
var ui = "camera-error";
var di = "joining-meeting";
var hi = "joined-meeting";
var pi = "left-meeting";
var fi = "participant-joined";
var gi = "participant-updated";
var vi = "participant-left";
var mi = "participant-counts-updated";
var yi = "access-state-updated";
var _i = "meeting-session-summary-updated";
var bi = "meeting-session-state-updated";
var Si = "waiting-participant-added";
var ki = "waiting-participant-updated";
var Ei = "waiting-participant-removed";
var Ci = "track-started";
var Mi = "track-stopped";
var Ti = "transcription-started";
var Oi = "transcription-stopped";
var Pi = "transcription-error";
var Ai = "recording-started";
var Di = "recording-stopped";
var ji = "recording-stats";
var xi = "recording-error";
var Li = "recording-upload-completed";
var Ii = "recording-data";
var Ni = "app-message";
var Ri = "transcription-message";
var Bi = "remote-media-player-started";
var Fi = "remote-media-player-updated";
var Ui = "remote-media-player-stopped";
var Vi = "local-screen-share-started";
var Ji = "local-screen-share-stopped";
var $i = "local-screen-share-canceled";
var Gi = "active-speaker-change";
var qi = "active-speaker-mode-change";
var Yi = "network-quality-change";
var zi = "network-connection";
var Wi = "cpu-load-change";
var Hi = "face-counts-updated";
var Qi = "fullscreen";
var Ki = "exited-fullscreen";
var Xi = "live-streaming-started";
var Zi = "live-streaming-updated";
var eo = "live-streaming-stopped";
var to = "live-streaming-error";
var no = "lang-updated";
var ro = "receive-settings-updated";
var io = "input-settings-updated";
var oo = "nonfatal-error";
var ao = "error";
var so = 4096;
var co = 102400;
var lo = "iframe-call-message";
var uo = "local-screen-start";
var ho = "daily-method-update-live-streaming-endpoints";
var po = "transmit-log";
var fo = "daily-custom-track";
var go = { NONE: "none", BGBLUR: "background-blur", BGIMAGE: "background-image", FACE_DETECTION: "face-detection" };
var vo = { NONE: "none", NOISE_CANCELLATION: "noise-cancellation" };
var mo = { PLAY: "play", PAUSE: "pause" };
var yo = 10;
var _o = ["jpg", "png", "jpeg"];
var bo = "add-endpoints";
var wo = "remove-endpoints";
var So = "sip-call-transfer";
function ko() {
  return !Eo() && "undefined" != typeof window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : "";
}
function Eo() {
  return "undefined" != typeof navigator && navigator.product && "ReactNative" === navigator.product;
}
function Co() {
  return navigator && navigator.mediaDevices && navigator.mediaDevices.getUserMedia;
}
function Mo() {
  return !!(navigator && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) && (function(e2, t2) {
    if (!e2 || !t2) return true;
    switch (e2) {
      case "Chrome":
        return t2.major >= 75;
      case "Safari":
        return RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection") && !(13 === t2.major && 0 === t2.minor && 0 === t2.point);
      case "Firefox":
        return t2.major >= 67;
    }
    return true;
  }(Io(), No()) || Eo());
}
function To() {
  if (Eo()) return false;
  if (!document) return false;
  var e2 = document.createElement("iframe");
  return !!e2.requestFullscreen || !!e2.webkitRequestFullscreen;
}
var Oo = function() {
  try {
    var e2 = document.createElement("canvas"), t2 = null != e2.getContext("webgl2");
    return e2.remove(), t2;
  } catch (e3) {
    return false;
  }
}();
function Po() {
  var e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
  return !Eo() && (!!Oo && (e2 ? function() {
    if (Lo()) return false;
    return ["Chrome", "Firefox"].includes(Io());
  }() : function() {
    if (Lo()) return false;
    var e3 = Io();
    if ("Safari" === e3) {
      var t2 = Fo();
      if (t2.major < 15 || 15 === t2.major && t2.minor < 4) return false;
    }
    if ("Chrome" === e3) {
      return Ro().major >= 77;
    }
    if ("Firefox" === e3) {
      return Uo().major >= 97;
    }
    return ["Chrome", "Firefox", "Safari"].includes(e3);
  }()));
}
var Ao = ["Chrome", "Firefox", "Safari"];
function Do() {
  return !Eo() && (!xo() && ("undefined" != typeof AudioWorkletNode && Ao.includes(Io())));
}
function jo() {
  return Co() && !function() {
    var e2, t2 = Io();
    if (!ko()) return true;
    switch (t2) {
      case "Chrome":
        return (e2 = Ro()).major && e2.major > 0 && e2.major < 75;
      case "Firefox":
        return (e2 = Uo()).major < 91;
      case "Safari":
        return (e2 = Fo()).major < 13 || 13 === e2.major && e2.minor < 1;
      default:
        return true;
    }
  }();
}
function xo() {
  return ko().match(/Linux; Android/);
}
function Lo() {
  var e2, t2, n2 = ko(), r2 = n2.match(/Mac/) && (!Eo() && "undefined" != typeof window && null !== (e2 = window) && void 0 !== e2 && null !== (t2 = e2.navigator) && void 0 !== t2 && t2.maxTouchPoints ? window.navigator.maxTouchPoints : 0) >= 5;
  return !!(n2.match(/Mobi/) || n2.match(/Android/) || r2) || (!!ko().match(/DailyAnd\//) || void 0);
}
function Io() {
  if ("undefined" != typeof window) {
    var e2 = ko();
    return Bo() ? "Safari" : e2.indexOf("Edge") > -1 ? "Edge" : e2.match(/Chrome\//) ? "Chrome" : e2.indexOf("Safari") > -1 ? "Safari" : e2.indexOf("Firefox") > -1 ? "Firefox" : e2.indexOf("MSIE") > -1 || e2.indexOf(".NET") > -1 ? "IE" : "Unknown Browser";
  }
}
function No() {
  switch (Io()) {
    case "Chrome":
      return Ro();
    case "Safari":
      return Fo();
    case "Firefox":
      return Uo();
    case "Edge":
      return function() {
        var e2 = 0, t2 = 0;
        if ("undefined" != typeof window) {
          var n2 = ko().match(/Edge\/(\d+).(\d+)/);
          if (n2) try {
            e2 = parseInt(n2[1]), t2 = parseInt(n2[2]);
          } catch (e3) {
          }
        }
        return { major: e2, minor: t2 };
      }();
  }
}
function Ro() {
  var e2 = 0, t2 = 0, n2 = 0, r2 = 0, i2 = false;
  if ("undefined" != typeof window) {
    var o2 = ko(), a2 = o2.match(/Chrome\/(\d+).(\d+).(\d+).(\d+)/);
    if (a2) try {
      e2 = parseInt(a2[1]), t2 = parseInt(a2[2]), n2 = parseInt(a2[3]), r2 = parseInt(a2[4]), i2 = o2.indexOf("OPR/") > -1;
    } catch (e3) {
    }
  }
  return { major: e2, minor: t2, build: n2, patch: r2, opera: i2 };
}
function Bo() {
  return !!ko().match(/iPad|iPhone|iPod/i) && Co();
}
function Fo() {
  var e2 = 0, t2 = 0, n2 = 0;
  if ("undefined" != typeof window) {
    var r2 = ko().match(/Version\/(\d+).(\d+)(.(\d+))?/);
    if (r2) try {
      e2 = parseInt(r2[1]), t2 = parseInt(r2[2]), n2 = parseInt(r2[4]);
    } catch (e3) {
    }
    else Bo() && (e2 = 14, t2 = 0, n2 = 3);
  }
  return { major: e2, minor: t2, point: n2 };
}
function Uo() {
  var e2 = 0, t2 = 0;
  if ("undefined" != typeof window) {
    var n2 = ko().match(/Firefox\/(\d+).(\d+)/);
    if (n2) try {
      e2 = parseInt(n2[1]), t2 = parseInt(n2[2]);
    } catch (e3) {
    }
  }
  return { major: e2, minor: t2 };
}
var Vo = function() {
  function e2() {
    t(this, e2);
  }
  return o(e2, [{ key: "addListenerForMessagesFromCallMachine", value: function(e3, t2, n2) {
    Q();
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e3, t2, n2) {
    Q();
  } }, { key: "sendMessageToCallMachine", value: function(e3, t2, n2, r2) {
    Q();
  } }, { key: "sendMessageToDailyJs", value: function(e3, t2) {
    Q();
  } }, { key: "removeListener", value: function(e3) {
    Q();
  } }]), e2;
}();
function Jo(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r2 = Object.getOwnPropertySymbols(e2);
    t2 && (r2 = r2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), n2.push.apply(n2, r2);
  }
  return n2;
}
function $o(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? Jo(Object(n2), true).forEach(function(t3) {
      d(e2, t3, n2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : Jo(Object(n2)).forEach(function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
    });
  }
  return e2;
}
function Go(e2) {
  var t2 = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }();
  return function() {
    var n2, r2 = u(e2);
    if (t2) {
      var i2 = u(this).constructor;
      n2 = Reflect.construct(r2, arguments, i2);
    } else n2 = r2.apply(this, arguments);
    return l(this, n2);
  };
}
var qo = function(e2) {
  c(r2, Vo);
  var n2 = Go(r2);
  function r2() {
    var e3;
    return t(this, r2), (e3 = n2.call(this))._wrappedListeners = {}, e3._messageCallbacks = {}, e3;
  }
  return o(r2, [{ key: "addListenerForMessagesFromCallMachine", value: function(e3, t2, n3) {
    var r3 = this, i2 = function(i3) {
      if (i3.data && "iframe-call-message" === i3.data.what && (!i3.data.callClientId || i3.data.callClientId === t2) && (!i3.data.from || "module" !== i3.data.from)) {
        var o2 = $o({}, i3.data);
        if (delete o2.from, o2.callbackStamp && r3._messageCallbacks[o2.callbackStamp]) {
          var a2 = o2.callbackStamp;
          r3._messageCallbacks[a2].call(n3, o2), delete r3._messageCallbacks[a2];
        }
        delete o2.what, delete o2.callbackStamp, e3.call(n3, o2);
      }
    };
    this._wrappedListeners[e3] = i2, window.addEventListener("message", i2);
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e3, t2, n3) {
    var r3 = function(r4) {
      var i2;
      if (!(!r4.data || r4.data.what !== lo || !r4.data.action || r4.data.from && "module" !== r4.data.from || r4.data.callClientId && t2 && r4.data.callClientId !== t2 || null != r4 && null !== (i2 = r4.data) && void 0 !== i2 && i2.callFrameId)) {
        var o2 = r4.data;
        e3.call(n3, o2);
      }
    };
    this._wrappedListeners[e3] = r3, window.addEventListener("message", r3);
  } }, { key: "sendMessageToCallMachine", value: function(e3, t2, n3, r3) {
    if (!n3) throw new Error("undefined callClientId. Are you trying to use a DailyCall instance previously destroyed?");
    var i2 = $o({}, e3);
    if (i2.what = lo, i2.from = "module", i2.callClientId = n3, t2) {
      var o2 = H();
      this._messageCallbacks[o2] = t2, i2.callbackStamp = o2;
    }
    var a2 = r3 ? r3.contentWindow : window, s2 = this._callMachineTargetOrigin(r3);
    s2 && a2.postMessage(i2, s2);
  } }, { key: "sendMessageToDailyJs", value: function(e3, t2) {
    e3.what = lo, e3.callClientId = t2, e3.from = "embedded", window.postMessage(e3, this._targetOriginFromWindowLocation());
  } }, { key: "removeListener", value: function(e3) {
    var t2 = this._wrappedListeners[e3];
    t2 && (window.removeEventListener("message", t2), delete this._wrappedListeners[e3]);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e3, t2, n3) {
    var r3 = $o({}, e3);
    r3.callClientId = n3;
    var i2 = t2 ? t2.contentWindow : window, o2 = this._callMachineTargetOrigin(t2);
    o2 && i2.postMessage(r3, o2);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e3, t2) {
    var n3 = function(n4) {
      if (n4.data && "iframe-call-message" === n4.data.what && (!n4.data.callClientId || n4.data.callClientId === t2) && (!n4.data.from || "module" !== n4.data.from)) {
        var r3 = n4.data;
        e3(r3);
      }
    };
    return this._wrappedListeners[e3] = n3, window.addEventListener("message", n3), e3;
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e3) {
    var t2 = this._wrappedListeners[e3];
    t2 && (window.removeEventListener("message", t2), delete this._wrappedListeners[e3]);
  } }, { key: "_callMachineTargetOrigin", value: function(e3) {
    return e3 ? e3.src ? new URL(e3.src).origin : void 0 : this._targetOriginFromWindowLocation();
  } }, { key: "_targetOriginFromWindowLocation", value: function() {
    return "file:" === window.location.protocol ? "*" : window.location.origin;
  } }]), r2;
}();
function Yo(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r2 = Object.getOwnPropertySymbols(e2);
    t2 && (r2 = r2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), n2.push.apply(n2, r2);
  }
  return n2;
}
function zo(e2) {
  var t2 = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }();
  return function() {
    var n2, r2 = u(e2);
    if (t2) {
      var i2 = u(this).constructor;
      n2 = Reflect.construct(r2, arguments, i2);
    } else n2 = r2.apply(this, arguments);
    return l(this, n2);
  };
}
var Wo = function(e2) {
  c(r2, Vo);
  var n2 = zo(r2);
  function r2() {
    var e3;
    return t(this, r2), e3 = n2.call(this), global.callMachineToDailyJsEmitter = global.callMachineToDailyJsEmitter || new m.EventEmitter(), global.dailyJsToCallMachineEmitter = global.dailyJsToCallMachineEmitter || new m.EventEmitter(), e3._wrappedListeners = {}, e3._messageCallbacks = {}, e3;
  }
  return o(r2, [{ key: "addListenerForMessagesFromCallMachine", value: function(e3, t2, n3) {
    this._addListener(e3, global.callMachineToDailyJsEmitter, t2, n3, "received call machine message");
  } }, { key: "addListenerForMessagesFromDailyJs", value: function(e3, t2, n3) {
    this._addListener(e3, global.dailyJsToCallMachineEmitter, t2, n3, "received daily-js message");
  } }, { key: "sendMessageToCallMachine", value: function(e3, t2, n3) {
    this._sendMessage(e3, global.dailyJsToCallMachineEmitter, n3, t2, "sending message to call machine");
  } }, { key: "sendMessageToDailyJs", value: function(e3, t2) {
    this._sendMessage(e3, global.callMachineToDailyJsEmitter, t2, null, "sending message to daily-js");
  } }, { key: "removeListener", value: function(e3) {
    var t2 = this._wrappedListeners[e3];
    t2 && (global.callMachineToDailyJsEmitter.removeListener("message", t2), global.dailyJsToCallMachineEmitter.removeListener("message", t2), delete this._wrappedListeners[e3]);
  } }, { key: "_addListener", value: function(e3, t2, n3, r3, i2) {
    var o2 = this, a2 = function(t3) {
      if (t3.callClientId === n3) {
        if (t3.callbackStamp && o2._messageCallbacks[t3.callbackStamp]) {
          var i3 = t3.callbackStamp;
          o2._messageCallbacks[i3].call(r3, t3), delete o2._messageCallbacks[i3];
        }
        e3.call(r3, t3);
      }
    };
    this._wrappedListeners[e3] = a2, t2.addListener("message", a2);
  } }, { key: "_sendMessage", value: function(e3, t2, n3, r3, i2) {
    var o2 = function(e4) {
      for (var t3 = 1; t3 < arguments.length; t3++) {
        var n4 = null != arguments[t3] ? arguments[t3] : {};
        t3 % 2 ? Yo(Object(n4), true).forEach(function(t4) {
          d(e4, t4, n4[t4]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n4)) : Yo(Object(n4)).forEach(function(t4) {
          Object.defineProperty(e4, t4, Object.getOwnPropertyDescriptor(n4, t4));
        });
      }
      return e4;
    }({}, e3);
    if (o2.callClientId = n3, r3) {
      var a2 = H();
      this._messageCallbacks[a2] = r3, o2.callbackStamp = a2;
    }
    t2.emit("message", o2);
  } }]), r2;
}();
var Ho = "replace";
var Qo = "shallow-merge";
var Ko = [Ho, Qo];
var Xo = function() {
  function e2() {
    var n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = n2.data, i2 = n2.mergeStrategy, o2 = void 0 === i2 ? Ho : i2;
    t(this, e2), e2._validateMergeStrategy(o2), e2._validateData(r2, o2), this.mergeStrategy = o2, this.data = r2;
  }
  return o(e2, [{ key: "isNoOp", value: function() {
    return e2.isNoOpUpdate(this.data, this.mergeStrategy);
  } }], [{ key: "isNoOpUpdate", value: function(e3, t2) {
    return 0 === Object.keys(e3).length && t2 === Qo;
  } }, { key: "_validateMergeStrategy", value: function(e3) {
    if (!Ko.includes(e3)) throw Error("Unrecognized mergeStrategy provided. Options are: [".concat(Ko, "]"));
  } }, { key: "_validateData", value: function(e3, t2) {
    if (!function(e4) {
      if (null == e4 || "object" !== n(e4)) return false;
      var t3 = Object.getPrototypeOf(e4);
      return null == t3 || t3 === Object.prototype;
    }(e3)) throw Error("Meeting session data must be a plain (map-like) object");
    var r2;
    try {
      if (r2 = JSON.stringify(e3), t2 === Ho) {
        var i2 = JSON.parse(r2);
        I(i2, e3) || console.warn("The meeting session data provided will be modified when serialized.", i2, e3);
      } else if (t2 === Qo) {
        for (var o2 in e3) if (Object.hasOwnProperty.call(e3, o2) && void 0 !== e3[o2]) {
          var a2 = JSON.parse(JSON.stringify(e3[o2]));
          I(e3[o2], a2) || console.warn("At least one key in the meeting session data provided will be modified when serialized.", a2, e3[o2]);
        }
      }
    } catch (e4) {
      throw Error("Meeting session data must be serializable to JSON: ".concat(e4));
    }
    if (r2.length > co) throw Error("Meeting session data is too large (".concat(r2.length, " characters). Maximum size suppported is ").concat(co, "."));
  } }]), e2;
}();
function Zo(e2, t2, n2) {
  return Zo = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }() ? Reflect.construct.bind() : function(e3, t3, n3) {
    var r2 = [null];
    r2.push.apply(r2, t3);
    var i2 = new (Function.bind.apply(e3, r2))();
    return n3 && s(i2, n3.prototype), i2;
  }, Zo.apply(null, arguments);
}
function ea(e2) {
  var t2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
  return ea = function(e3) {
    if (null === e3 || (n2 = e3, -1 === Function.toString.call(n2).indexOf("[native code]"))) return e3;
    var n2;
    if ("function" != typeof e3) throw new TypeError("Super expression must either be null or a function");
    if (void 0 !== t2) {
      if (t2.has(e3)) return t2.get(e3);
      t2.set(e3, r2);
    }
    function r2() {
      return Zo(e3, arguments, u(this).constructor);
    }
    return r2.prototype = Object.create(e3.prototype, { constructor: { value: r2, enumerable: false, writable: true, configurable: true } }), s(r2, e3);
  }, ea(e2);
}
function ta(e2) {
  var t2 = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }();
  return function() {
    var n2, r2 = u(e2);
    if (t2) {
      var i2 = u(this).constructor;
      n2 = Reflect.construct(r2, arguments, i2);
    } else n2 = r2.apply(this, arguments);
    return l(this, n2);
  };
}
function na(e2) {
  var t2, n2 = null === (t2 = window._daily) || void 0 === t2 ? void 0 : t2.pendings;
  if (n2) {
    var r2 = n2.indexOf(e2);
    -1 !== r2 && n2.splice(r2, 1);
  }
}
var ra = function() {
  function e2(n2) {
    t(this, e2), this._currentLoad = null, this._callClientId = n2;
  }
  return o(e2, [{ key: "load", value: function() {
    var e3, t2 = this, n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = arguments.length > 1 ? arguments[1] : void 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
    if (this.loaded) return window._daily.instances[this._callClientId].callMachine.reset(), void r2(true);
    e3 = this._callClientId, window._daily.pendings.push(e3), this._currentLoad && this._currentLoad.cancel(), this._currentLoad = new ia(n2, function() {
      r2(false);
    }, function(e4, n3) {
      n3 || na(t2._callClientId), i2(e4, n3);
    }), this._currentLoad.start();
  } }, { key: "cancel", value: function() {
    this._currentLoad && this._currentLoad.cancel(), na(this._callClientId);
  } }, { key: "loaded", get: function() {
    return this._currentLoad && this._currentLoad.succeeded;
  } }]), e2;
}();
var ia = function() {
  function e2() {
    var n2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r2 = arguments.length > 1 ? arguments[1] : void 0, i2 = arguments.length > 2 ? arguments[2] : void 0;
    t(this, e2), this._attemptsRemaining = 3, this._currentAttempt = null, this._dailyConfig = n2, this._successCallback = r2, this._failureCallback = i2;
  }
  return o(e2, [{ key: "start", value: function() {
    var e3 = this;
    if (!this._currentAttempt) {
      this._currentAttempt = new sa(this._dailyConfig, this._successCallback, function t2(n2) {
        e3._currentAttempt.cancelled || (e3._attemptsRemaining--, e3._failureCallback(n2, e3._attemptsRemaining > 0), e3._attemptsRemaining <= 0 || setTimeout(function() {
          e3._currentAttempt.cancelled || (e3._currentAttempt = new sa(e3._dailyConfig, e3._successCallback, t2), e3._currentAttempt.start());
        }, 3e3));
      }), this._currentAttempt.start();
    }
  } }, { key: "cancel", value: function() {
    this._currentAttempt && this._currentAttempt.cancel();
  } }, { key: "cancelled", get: function() {
    return this._currentAttempt && this._currentAttempt.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._currentAttempt && this._currentAttempt.succeeded;
  } }]), e2;
}();
var oa = function(e2) {
  c(r2, ea(Error));
  var n2 = ta(r2);
  function r2() {
    return t(this, r2), n2.apply(this, arguments);
  }
  return o(r2);
}();
var aa = 2e4;
var sa = function() {
  function e2(n3, r2, i2) {
    t(this, e2), this._loadAttemptImpl = Eo() || !n3.avoidEval ? new ca(n3, r2, i2) : new la(n3, r2, i2);
  }
  var n2;
  return o(e2, [{ key: "start", value: (n2 = p(function* () {
    return this._loadAttemptImpl.start();
  }), function() {
    return n2.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    this._loadAttemptImpl.cancel();
  } }, { key: "cancelled", get: function() {
    return this._loadAttemptImpl.cancelled;
  } }, { key: "succeeded", get: function() {
    return this._loadAttemptImpl.succeeded;
  } }]), e2;
}();
var ca = function() {
  function e2(n3, r3, i3) {
    t(this, e2), this.cancelled = false, this.succeeded = false, this._networkTimedOut = false, this._networkTimeout = null, this._iosCache = "undefined" != typeof iOSCallObjectBundleCache && iOSCallObjectBundleCache, this._refetchHeaders = null, this._dailyConfig = n3, this._successCallback = r3, this._failureCallback = i3;
  }
  var n2, r2, i2, a2;
  return o(e2, [{ key: "start", value: (a2 = p(function* () {
    var e3 = X(this._dailyConfig);
    !(yield this._tryLoadFromIOSCache(e3)) && this._loadFromNetwork(e3);
  }), function() {
    return a2.apply(this, arguments);
  }) }, { key: "cancel", value: function() {
    clearTimeout(this._networkTimeout), this.cancelled = true;
  } }, { key: "_tryLoadFromIOSCache", value: (i2 = p(function* (e3) {
    if (!this._iosCache) return false;
    try {
      var t2 = yield this._iosCache.get(e3);
      return !!this.cancelled || !!t2 && (t2.code ? (Function('"use strict";' + t2.code)(), this.succeeded = true, this._successCallback(), true) : (this._refetchHeaders = t2.refetchHeaders, false));
    } catch (e4) {
      return false;
    }
  }), function(e3) {
    return i2.apply(this, arguments);
  }) }, { key: "_loadFromNetwork", value: (r2 = p(function* (e3) {
    var t2 = this;
    this._networkTimeout = setTimeout(function() {
      t2._networkTimedOut = true, t2._failureCallback({ msg: "Timed out (>".concat(aa, " ms) when loading call object bundle ").concat(e3), type: "timeout" });
    }, aa);
    try {
      var n3 = this._refetchHeaders ? { headers: this._refetchHeaders } : {}, r3 = yield fetch(e3, n3);
      if (clearTimeout(this._networkTimeout), this.cancelled || this._networkTimedOut) throw new oa();
      var i3 = yield this._getBundleCodeFromResponse(e3, r3);
      if (this.cancelled) throw new oa();
      Function('"use strict";' + i3)(), this._iosCache && this._iosCache.set(e3, i3, r3.headers), this.succeeded = true, this._successCallback();
    } catch (t3) {
      if (clearTimeout(this._networkTimeout), t3 instanceof oa || this.cancelled || this._networkTimedOut) return;
      this._failureCallback({ msg: "Failed to load call object bundle ".concat(e3, ": ").concat(t3), type: t3.message });
    }
  }), function(e3) {
    return r2.apply(this, arguments);
  }) }, { key: "_getBundleCodeFromResponse", value: (n2 = p(function* (e3, t2) {
    if (t2.ok) return yield t2.text();
    if (this._iosCache && 304 === t2.status) return (yield this._iosCache.renew(e3, t2.headers)).code;
    throw new Error("Received ".concat(t2.status, " response"));
  }), function(e3, t2) {
    return n2.apply(this, arguments);
  }) }]), e2;
}();
var la = function() {
  function e2(n2, r2, i2) {
    t(this, e2), this.cancelled = false, this.succeeded = false, this._dailyConfig = n2, this._successCallback = r2, this._failureCallback = i2, this._attemptId = H(), this._networkTimeout = null, this._scriptElement = null;
  }
  return o(e2, [{ key: "start", value: function() {
    window._dailyCallMachineLoadWaitlist || (window._dailyCallMachineLoadWaitlist = /* @__PURE__ */ new Set());
    var e3 = X(this._dailyConfig);
    "object" === ("undefined" == typeof document ? "undefined" : n(document)) ? this._startLoading(e3) : this._failureCallback({ msg: "Call object bundle must be loaded in a DOM/web context", type: "missing context" });
  } }, { key: "cancel", value: function() {
    this._stopLoading(), this.cancelled = true;
  } }, { key: "_startLoading", value: function(e3) {
    var t2 = this;
    this._signUpForCallMachineLoadWaitlist(), this._networkTimeout = setTimeout(function() {
      t2._stopLoading(), t2._failureCallback({ msg: "Timed out (>".concat(aa, " ms) when loading call object bundle ").concat(e3), type: "timeout" });
    }, aa);
    var n2 = document.getElementsByTagName("head")[0], r2 = document.createElement("script");
    this._scriptElement = r2, r2.onload = function() {
      t2._stopLoading(), t2.succeeded = true, t2._successCallback();
    }, r2.onerror = function(e4) {
      t2._stopLoading(), t2._failureCallback({ msg: "Failed to load call object bundle ".concat(e4.target.src), type: e4.message });
    }, r2.src = e3, n2.appendChild(r2);
  } }, { key: "_stopLoading", value: function() {
    this._withdrawFromCallMachineLoadWaitlist(), clearTimeout(this._networkTimeout), this._scriptElement && (this._scriptElement.onload = null, this._scriptElement.onerror = null);
  } }, { key: "_signUpForCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.add(this._attemptId);
  } }, { key: "_withdrawFromCallMachineLoadWaitlist", value: function() {
    window._dailyCallMachineLoadWaitlist.delete(this._attemptId);
  } }]), e2;
}();
var ua = function(e2, t2, n2) {
  return true === pa(e2.local, t2, n2);
};
var da = function(e2, t2, n2) {
  return e2.local.streams && e2.local.streams[t2] && e2.local.streams[t2].stream && e2.local.streams[t2].stream["get".concat("video" === n2 ? "Video" : "Audio", "Tracks")]()[0];
};
var ha = function(e2, t2, n2, r2) {
  var i2 = fa(e2, t2, n2, r2);
  return i2 && i2.pendingTrack;
};
var pa = function(e2, t2, n2) {
  if (!e2) return false;
  var r2 = function(e3) {
    switch (e3) {
      case "avatar":
        return true;
      case "staged":
        return e3;
      default:
        return !!e3;
    }
  }, i2 = e2.public.subscribedTracks;
  return i2 && i2[t2] ? -1 === ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo"].indexOf(n2) && i2[t2].custom ? [true, "staged"].includes(i2[t2].custom) ? r2(i2[t2].custom) : r2(i2[t2].custom[n2]) : r2(i2[t2][n2]) : !i2 || r2(i2.ALL);
};
var fa = function(e2, t2, n2, r2) {
  var i2 = Object.values(e2.streams || {}).filter(function(e3) {
    return e3.participantId === t2 && e3.type === n2 && e3.pendingTrack && e3.pendingTrack.kind === r2;
  }).sort(function(e3, t3) {
    return new Date(t3.starttime) - new Date(e3.starttime);
  });
  return i2 && i2[0];
};
var ga = function(e2, t2) {
  var n2 = e2.local.public.customTracks;
  if (n2 && n2[t2]) return n2[t2].track;
};
function va(e2, t2) {
  for (var n2 = t2.getState(), r2 = 0, i2 = ["cam", "screen"]; r2 < i2.length; r2++) for (var o2 = i2[r2], a2 = 0, s2 = ["video", "audio"]; a2 < s2.length; a2++) {
    var c2 = s2[a2], l2 = "cam" === o2 ? c2 : "screen".concat(c2.charAt(0).toUpperCase() + c2.slice(1)), u2 = e2.tracks[l2];
    if (u2) {
      var d2 = e2.local ? da(n2, o2, c2) : ha(n2, e2.session_id, o2, c2);
      "playable" === u2.state && (u2.track = d2), u2.persistentTrack = d2;
    }
  }
}
function ma(e2, t2) {
  try {
    var n2 = t2.getState();
    for (var r2 in e2.tracks) if (!ya(r2)) {
      var i2 = e2.tracks[r2].kind;
      if (i2) {
        var o2 = e2.tracks[r2];
        if (o2) {
          var a2 = e2.local ? ga(n2, r2) : ha(n2, e2.session_id, r2, i2);
          "playable" === o2.state && (e2.tracks[r2].track = a2), o2.persistentTrack = a2;
        }
      } else console.error("unknown type for custom track");
    }
  } catch (e3) {
    console.error(e3);
  }
}
function ya(e2) {
  return ["video", "audio", "screenVideo", "screenAudio"].includes(e2);
}
function _a(e2, t2, n2) {
  var r2 = n2.getState();
  if (e2.local) {
    if (e2.audio) try {
      e2.audioTrack = r2.local.streams.cam.stream.getAudioTracks()[0], e2.audioTrack || (e2.audio = false);
    } catch (e3) {
    }
    if (e2.video) try {
      e2.videoTrack = r2.local.streams.cam.stream.getVideoTracks()[0], e2.videoTrack || (e2.video = false);
    } catch (e3) {
    }
    if (e2.screen) try {
      e2.screenVideoTrack = r2.local.streams.screen.stream.getVideoTracks()[0], e2.screenAudioTrack = r2.local.streams.screen.stream.getAudioTracks()[0], e2.screenVideoTrack || e2.screenAudioTrack || (e2.screen = false);
    } catch (e3) {
    }
  } else {
    var i2 = true;
    try {
      var o2 = r2.participants[e2.session_id];
      o2 && o2.public && o2.public.rtcType && "peer-to-peer" === o2.public.rtcType.impl && o2.private && !["connected", "completed"].includes(o2.private.peeringState) && (i2 = false);
    } catch (e3) {
      console.error(e3);
    }
    if (!i2) return e2.audio = false, e2.audioTrack = false, e2.video = false, e2.videoTrack = false, e2.screen = false, void (e2.screenTrack = false);
    try {
      r2.streams;
      if (e2.audio && ua(r2, e2.session_id, "cam-audio")) {
        var a2 = ha(r2, e2.session_id, "cam", "audio");
        a2 && (t2 && t2.audioTrack && t2.audioTrack.id === a2.id ? e2.audioTrack = a2 : a2.muted || (e2.audioTrack = a2)), e2.audioTrack || (e2.audio = false);
      }
      if (e2.video && ua(r2, e2.session_id, "cam-video")) {
        var s2 = ha(r2, e2.session_id, "cam", "video");
        s2 && (t2 && t2.videoTrack && t2.videoTrack.id === s2.id ? e2.videoTrack = s2 : s2.muted || (e2.videoTrack = s2)), e2.videoTrack || (e2.video = false);
      }
      if (e2.screen && ua(r2, e2.session_id, "screen-audio")) {
        var c2 = ha(r2, e2.session_id, "screen", "audio");
        c2 && (t2 && t2.screenAudioTrack && t2.screenAudioTrack.id === c2.id ? e2.screenAudioTrack = c2 : c2.muted || (e2.screenAudioTrack = c2));
      }
      if (e2.screen && ua(r2, e2.session_id, "screen-video")) {
        var l2 = ha(r2, e2.session_id, "screen", "video");
        l2 && (t2 && t2.screenVideoTrack && t2.screenVideoTrack.id === l2.id ? e2.screenVideoTrack = l2 : l2.muted || (e2.screenVideoTrack = l2));
      }
      e2.screenVideoTrack || e2.screenAudioTrack || (e2.screen = false);
    } catch (e3) {
      console.error("unexpected error matching up tracks", e3);
    }
  }
}
function ba(e2, t2) {
  var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
  if (!n2) {
    if (Array.isArray(e2) || (n2 = function(e3, t3) {
      if (!e3) return;
      if ("string" == typeof e3) return wa(e3, t3);
      var n3 = Object.prototype.toString.call(e3).slice(8, -1);
      "Object" === n3 && e3.constructor && (n3 = e3.constructor.name);
      if ("Map" === n3 || "Set" === n3) return Array.from(e3);
      if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return wa(e3, t3);
    }(e2)) || t2 && e2 && "number" == typeof e2.length) {
      n2 && (e2 = n2);
      var r2 = 0, i2 = function() {
      };
      return { s: i2, n: function() {
        return r2 >= e2.length ? { done: true } : { done: false, value: e2[r2++] };
      }, e: function(e3) {
        throw e3;
      }, f: i2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, a2 = true, s2 = false;
  return { s: function() {
    n2 = n2.call(e2);
  }, n: function() {
    var e3 = n2.next();
    return a2 = e3.done, e3;
  }, e: function(e3) {
    s2 = true, o2 = e3;
  }, f: function() {
    try {
      a2 || null == n2.return || n2.return();
    } finally {
      if (s2) throw o2;
    }
  } };
}
function wa(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++) r2[n2] = e2[n2];
  return r2;
}
var Sa = /* @__PURE__ */ new Map();
var ka = null;
function Ea(e2, t2) {
  var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
  if (!n2) {
    if (Array.isArray(e2) || (n2 = function(e3, t3) {
      if (!e3) return;
      if ("string" == typeof e3) return Ca(e3, t3);
      var n3 = Object.prototype.toString.call(e3).slice(8, -1);
      "Object" === n3 && e3.constructor && (n3 = e3.constructor.name);
      if ("Map" === n3 || "Set" === n3) return Array.from(e3);
      if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return Ca(e3, t3);
    }(e2)) || t2 && e2 && "number" == typeof e2.length) {
      n2 && (e2 = n2);
      var r2 = 0, i2 = function() {
      };
      return { s: i2, n: function() {
        return r2 >= e2.length ? { done: true } : { done: false, value: e2[r2++] };
      }, e: function(e3) {
        throw e3;
      }, f: i2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, a2 = true, s2 = false;
  return { s: function() {
    n2 = n2.call(e2);
  }, n: function() {
    var e3 = n2.next();
    return a2 = e3.done, e3;
  }, e: function(e3) {
    s2 = true, o2 = e3;
  }, f: function() {
    try {
      a2 || null == n2.return || n2.return();
    } finally {
      if (s2) throw o2;
    }
  } };
}
function Ca(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++) r2[n2] = e2[n2];
  return r2;
}
var Ma = /* @__PURE__ */ new Map();
var Ta = null;
var Oa = 3e3;
function Pa(e2) {
  Da() ? function(e3) {
    Sa.has(e3) || (Sa.set(e3, {}), navigator.mediaDevices.enumerateDevices().then(function(t2) {
      Sa.has(e3) && (Sa.get(e3).lastDevicesString = JSON.stringify(t2), ka || (ka = function() {
        var e4 = p(function* () {
          var e5, t3 = yield navigator.mediaDevices.enumerateDevices(), n2 = ba(Sa.keys());
          try {
            for (n2.s(); !(e5 = n2.n()).done; ) {
              var r2 = e5.value, i2 = JSON.stringify(t3);
              i2 !== Sa.get(r2).lastDevicesString && (Sa.get(r2).lastDevicesString = i2, r2(t3));
            }
          } catch (e6) {
            n2.e(e6);
          } finally {
            n2.f();
          }
        });
        return function() {
          return e4.apply(this, arguments);
        };
      }(), navigator.mediaDevices.addEventListener("devicechange", ka)));
    }).catch(function() {
    }));
  }(e2) : function(e3) {
    Ma.has(e3) || (Ma.set(e3, {}), navigator.mediaDevices.enumerateDevices().then(function(t2) {
      Ma.has(e3) && (Ma.get(e3).lastDevicesString = JSON.stringify(t2), Ta || (Ta = setInterval(p(function* () {
        var e4, t3 = yield navigator.mediaDevices.enumerateDevices(), n2 = Ea(Ma.keys());
        try {
          for (n2.s(); !(e4 = n2.n()).done; ) {
            var r2 = e4.value, i2 = JSON.stringify(t3);
            i2 !== Ma.get(r2).lastDevicesString && (Ma.get(r2).lastDevicesString = i2, r2(t3));
          }
        } catch (e5) {
          n2.e(e5);
        } finally {
          n2.f();
        }
      }), Oa)));
    }));
  }(e2);
}
function Aa(e2) {
  Da() ? function(e3) {
    Sa.has(e3) && (Sa.delete(e3), 0 === Sa.size && ka && (navigator.mediaDevices.removeEventListener("devicechange", ka), ka = null));
  }(e2) : function(e3) {
    Ma.has(e3) && (Ma.delete(e3), 0 === Ma.size && Ta && (clearInterval(Ta), Ta = null));
  }(e2);
}
function Da() {
  return Eo() || void 0 !== navigator.mediaDevices.ondevicechange;
}
var ja = /* @__PURE__ */ new Set();
function xa(e2, t2) {
  var n2 = t2.isLocalScreenVideo;
  return e2 && "live" === e2.readyState && !function(e3, t3) {
    return (!t3.isLocalScreenVideo || "Chrome" !== Io()) && e3.muted && !ja.has(e3.id);
  }(e2, { isLocalScreenVideo: n2 });
}
var La = ["result"];
var Ia = ["preserveIframe"];
function Na(e2, t2) {
  var n2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var r2 = Object.getOwnPropertySymbols(e2);
    t2 && (r2 = r2.filter(function(t3) {
      return Object.getOwnPropertyDescriptor(e2, t3).enumerable;
    })), n2.push.apply(n2, r2);
  }
  return n2;
}
function Ra(e2) {
  for (var t2 = 1; t2 < arguments.length; t2++) {
    var n2 = null != arguments[t2] ? arguments[t2] : {};
    t2 % 2 ? Na(Object(n2), true).forEach(function(t3) {
      d(e2, t3, n2[t3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(n2)) : Na(Object(n2)).forEach(function(t3) {
      Object.defineProperty(e2, t3, Object.getOwnPropertyDescriptor(n2, t3));
    });
  }
  return e2;
}
function Ba(e2) {
  var t2 = function() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), true;
    } catch (e3) {
      return false;
    }
  }();
  return function() {
    var n2, r2 = u(e2);
    if (t2) {
      var i2 = u(this).constructor;
      n2 = Reflect.construct(r2, arguments, i2);
    } else n2 = r2.apply(this, arguments);
    return l(this, n2);
  };
}
function Fa(e2, t2) {
  var n2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
  if (!n2) {
    if (Array.isArray(e2) || (n2 = function(e3, t3) {
      if (!e3) return;
      if ("string" == typeof e3) return Ua(e3, t3);
      var n3 = Object.prototype.toString.call(e3).slice(8, -1);
      "Object" === n3 && e3.constructor && (n3 = e3.constructor.name);
      if ("Map" === n3 || "Set" === n3) return Array.from(e3);
      if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3)) return Ua(e3, t3);
    }(e2)) || t2 && e2 && "number" == typeof e2.length) {
      n2 && (e2 = n2);
      var r2 = 0, i2 = function() {
      };
      return { s: i2, n: function() {
        return r2 >= e2.length ? { done: true } : { done: false, value: e2[r2++] };
      }, e: function(e3) {
        throw e3;
      }, f: i2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var o2, a2 = true, s2 = false;
  return { s: function() {
    n2 = n2.call(e2);
  }, n: function() {
    var e3 = n2.next();
    return a2 = e3.done, e3;
  }, e: function(e3) {
    s2 = true, o2 = e3;
  }, f: function() {
    try {
      a2 || null == n2.return || n2.return();
    } finally {
      if (s2) throw o2;
    }
  } };
}
function Ua(e2, t2) {
  (null == t2 || t2 > e2.length) && (t2 = e2.length);
  for (var n2 = 0, r2 = new Array(t2); n2 < t2; n2++) r2[n2] = e2[n2];
  return r2;
}
var Va = {};
var Ja = "video";
var $a = "voice";
var Ga = Eo() ? { data: {} } : { data: {}, topology: "none" };
var qa = { present: 0, hidden: 0 };
var Ya = { maxBitrate: { min: 1e5, max: 25e5 }, maxFramerate: { min: 1, max: 30 }, scaleResolutionDownBy: { min: 1, max: 8 } };
var za = Object.keys(Ya);
var Wa = ["state", "volume", "simulcastEncodings"];
var Ha = { androidInCallNotification: { title: "string", subtitle: "string", iconName: "string", disableForCustomOverride: "boolean" }, disableAutoDeviceManagement: { audio: "boolean", video: "boolean" } };
var Qa = { id: { iconPath: "string", iconPathDarkMode: "string", label: "string", tooltip: "string" } };
var Ka = { id: { allow: "string", controlledBy: "'*' | 'owners' | string[]", csp: "string", iconURL: "string", label: "string", loading: "'eager' | 'lazy'", location: "'main' | 'sidebar'", name: "string", referrerPolicy: "string", sandbox: "string", src: "string", srcdoc: "string", shared: "string[] | 'owners' | boolean" } };
var Xa = { customIntegrations: { validate: _s, help: ms() }, customTrayButtons: { validate: ys, help: "customTrayButtons should be a dictionary of the type ".concat(JSON.stringify(Qa)) }, url: { validate: function(e2) {
  return "string" == typeof e2;
}, help: "url should be a string" }, baseUrl: { validate: function(e2) {
  return "string" == typeof e2;
}, help: "baseUrl should be a string" }, token: { validate: function(e2) {
  return "string" == typeof e2;
}, help: "token should be a string", queryString: "t" }, dailyConfig: { validate: function(e2, t2) {
  try {
    return t2.validateDailyConfig(e2), true;
  } catch (e3) {
    console.error("Failed to validate dailyConfig", e3);
  }
  return false;
}, help: "Unsupported dailyConfig. Check error logs for detailed info." }, reactNativeConfig: { validate: function(e2) {
  return bs(e2, Ha);
}, help: "reactNativeConfig should look like ".concat(JSON.stringify(Ha), ", all fields optional") }, lang: { validate: function(e2) {
  return ["da", "de", "en-us", "en", "es", "fi", "fr", "it", "jp", "ka", "nl", "no", "pl", "pt", "pt-BR", "ru", "sv", "tr", "user"].includes(e2);
}, help: "language not supported. Options are: da, de, en-us, en, es, fi, fr, it, jp, ka, nl, no, pl, pt, pt-BR, ru, sv, tr, user" }, userName: true, userData: { validate: function(e2) {
  try {
    return ds(e2), true;
  } catch (e3) {
    return console.error(e3), false;
  }
}, help: "invalid userData type provided" }, startVideoOff: true, startAudioOff: true, activeSpeakerMode: true, showLeaveButton: true, showLocalVideo: true, showParticipantsBar: true, showFullscreenButton: true, showUserNameChangeUI: true, iframeStyle: true, customLayout: true, cssFile: true, cssText: true, bodyClass: true, videoSource: { validate: function(e2, t2) {
  return e2 instanceof MediaStreamTrack && (t2._sharedTracks.videoDeviceId = e2), t2._preloadCache.videoDeviceId = e2, true;
} }, audioSource: { validate: function(e2, t2) {
  return e2 instanceof MediaStreamTrack && (t2._sharedTracks.audioDeviceId = e2), t2._preloadCache.audioDeviceId = e2, true;
} }, subscribeToTracksAutomatically: { validate: function(e2, t2) {
  return t2._preloadCache.subscribeToTracksAutomatically = e2, true;
} }, theme: { validate: function(e2) {
  var t2 = ["accent", "accentText", "background", "backgroundAccent", "baseText", "border", "mainAreaBg", "mainAreaBgAccent", "mainAreaText", "supportiveText"], r2 = function(e3) {
    for (var n2 = 0, r3 = Object.keys(e3); n2 < r3.length; n2++) {
      var i2 = r3[n2];
      if (!t2.includes(i2)) return console.error('unsupported color "'.concat(i2, '". Valid colors: ').concat(t2.join(", "))), false;
      if (!e3[i2].match(/^#[0-9a-f]{6}|#[0-9a-f]{3}$/i)) return console.error("".concat(i2, ' theme color should be provided in valid hex color format. Received: "').concat(e3[i2], '"')), false;
    }
    return true;
  };
  return "object" === n(e2) && ("light" in e2 && "dark" in e2 || "colors" in e2) ? "light" in e2 && "dark" in e2 ? "colors" in e2.light ? "colors" in e2.dark ? r2(e2.light.colors) && r2(e2.dark.colors) : (console.error('Dark theme is missing "colors" property.', e2), false) : (console.error('Light theme is missing "colors" property.', e2), false) : r2(e2.colors) : (console.error('Theme must contain either both "light" and "dark" properties, or "colors".', e2), false);
}, help: "unsupported theme configuration. Check error logs for detailed info." }, layoutConfig: { validate: function(e2) {
  if ("grid" in e2) {
    var t2 = e2.grid;
    if ("maxTilesPerPage" in t2) {
      if (!Number.isInteger(t2.maxTilesPerPage)) return console.error("grid.maxTilesPerPage should be an integer. You passed ".concat(t2.maxTilesPerPage, ".")), false;
      if (t2.maxTilesPerPage > 49) return console.error("grid.maxTilesPerPage can't be larger than 49 without sacrificing browser performance. Please contact us at https://www.daily.co/contact to talk about your use case."), false;
    }
    if ("minTilesPerPage" in t2) {
      if (!Number.isInteger(t2.minTilesPerPage)) return console.error("grid.minTilesPerPage should be an integer. You passed ".concat(t2.minTilesPerPage, ".")), false;
      if (t2.minTilesPerPage < 1) return console.error("grid.minTilesPerPage can't be lower than 1."), false;
      if ("maxTilesPerPage" in t2 && t2.minTilesPerPage > t2.maxTilesPerPage) return console.error("grid.minTilesPerPage can't be higher than grid.maxTilesPerPage."), false;
    }
  }
  return true;
}, help: "unsupported layoutConfig. Check error logs for detailed info." }, receiveSettings: { validate: function(e2) {
  return hs(e2, { allowAllParticipantsKey: false });
}, help: vs({ allowAllParticipantsKey: false }) }, sendSettings: { validate: function(e2, t2) {
  return !!function(e3, t3) {
    try {
      return t3.validateUpdateSendSettings(e3), true;
    } catch (e4) {
      return console.error("Failed to validate send settings", e4), false;
    }
  }(e2, t2) && (t2._preloadCache.sendSettings = e2, true);
}, help: "Invalid sendSettings provided. Check error logs for detailed info." }, inputSettings: { validate: function(e2, t2) {
  var n2;
  return !!ps(e2) && (t2._preloadCache.inputSettings || (t2._preloadCache.inputSettings = {}), fs(e2, null === (n2 = t2.properties) || void 0 === n2 ? void 0 : n2.dailyConfig), e2.audio && (t2._preloadCache.inputSettings.audio = e2.audio), e2.video && (t2._preloadCache.inputSettings.video = e2.video), true);
}, help: gs() }, layout: { validate: function(e2) {
  return "custom-v1" === e2 || "browser" === e2 || "none" === e2;
}, help: 'layout may only be set to "custom-v1"', queryString: "layout" }, emb: { queryString: "emb" }, embHref: { queryString: "embHref" }, dailyJsVersion: { queryString: "dailyJsVersion" }, proxy: { queryString: "proxy" }, strictMode: true, allowMultipleCallInstances: true };
var Za = { styles: { validate: function(e2) {
  for (var t2 in e2) if ("cam" !== t2 && "screen" !== t2) return false;
  if (e2.cam) {
    for (var n2 in e2.cam) if ("div" !== n2 && "video" !== n2) return false;
  }
  if (e2.screen) {
    for (var r2 in e2.screen) if ("div" !== r2 && "video" !== r2) return false;
  }
  return true;
}, help: "styles format should be a subset of: { cam: {div: {}, video: {}}, screen: {div: {}, video: {}} }" }, setSubscribedTracks: { validate: function(e2, t2) {
  if (t2._preloadCache.subscribeToTracksAutomatically) return false;
  var n2 = [true, false, "staged"];
  if (n2.includes(e2) || !Eo() && "avatar" === e2) return true;
  var r2 = ["audio", "video", "screenAudio", "screenVideo", "rmpAudio", "rmpVideo"];
  return function e3(t3) {
    var i2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
    for (var o2 in t3) if ("custom" === o2) {
      if (!n2.includes(t3[o2]) && !e3(t3[o2], true)) return false;
    } else {
      var a2 = !i2 && !r2.includes(o2), s2 = !n2.includes(t3[o2]);
      if (a2 || s2) return false;
    }
    return true;
  }(e2);
}, help: "setSubscribedTracks cannot be used when setSubscribeToTracksAutomatically is enabled, and should be of the form: " + "true".concat(Eo() ? "" : " | 'avatar'", " | false | 'staged' | { [audio: true|false|'staged'], [video: true|false|'staged'], [screenAudio: true|false|'staged'], [screenVideo: true|false|'staged'] }") }, setAudio: true, setVideo: true, setScreenShare: { validate: function(e2) {
  return false === e2;
}, help: "setScreenShare must be false, as it's only meant for stopping remote participants' screen shares" }, eject: true, updatePermissions: { validate: function(e2) {
  for (var t2 = 0, n2 = Object.entries(e2); t2 < n2.length; t2++) {
    var r2 = g(n2[t2], 2), i2 = r2[0], o2 = r2[1];
    switch (i2) {
      case "hasPresence":
        if ("boolean" != typeof o2) return false;
        break;
      case "canSend":
        if (o2 instanceof Set || o2 instanceof Array || Array.isArray(o2)) {
          var a2, s2 = ["video", "audio", "screenVideo", "screenAudio", "customVideo", "customAudio"], c2 = Fa(o2);
          try {
            for (c2.s(); !(a2 = c2.n()).done; ) {
              var l2 = a2.value;
              if (!s2.includes(l2)) return false;
            }
          } catch (e3) {
            c2.e(e3);
          } finally {
            c2.f();
          }
        } else if ("boolean" != typeof o2) return false;
        (o2 instanceof Array || Array.isArray(o2)) && (e2.canSend = new Set(o2));
        break;
      case "canAdmin":
        if (o2 instanceof Set || o2 instanceof Array || Array.isArray(o2)) {
          var u2, d2 = ["participants", "streaming", "transcription"], h2 = Fa(o2);
          try {
            for (h2.s(); !(u2 = h2.n()).done; ) {
              var p2 = u2.value;
              if (!d2.includes(p2)) return false;
            }
          } catch (e3) {
            h2.e(e3);
          } finally {
            h2.f();
          }
        } else if ("boolean" != typeof o2) return false;
        (o2 instanceof Array || Array.isArray(o2)) && (e2.canAdmin = new Set(o2));
        break;
      default:
        return false;
    }
  }
  return true;
}, help: "updatePermissions can take hasPresence, canSend, and canAdmin permissions. hasPresence must be a boolean. canSend can be a boolean or an Array or Set of media types (video, audio, screenVideo, screenAudio, customVideo, customAudio). canAdmin can be a boolean or an Array or Set of admin types (participants, streaming, transcription)." } };
Promise.any || (Promise.any = function() {
  var e2 = p(function* (e3) {
    return new Promise(function(t2, n2) {
      var r2 = [];
      e3.forEach(function(i2) {
        return Promise.resolve(i2).then(function(e4) {
          t2(e4);
        }).catch(function(t3) {
          r2.push(t3), r2.length === e3.length && n2(r2);
        });
      });
    });
  });
  return function(t2) {
    return e2.apply(this, arguments);
  };
}());
var es = function(r2) {
  c(te2, m);
  var i2, s2, l2, u2, h2, f2, v2, y2, _2, b2, w2, S2, k2, E2, C2, M2, T2, O2, P2, A2, D2, j2, x2, L2, N2, R2, B2, F2, U2, V2, J2, $2, G2, q2, Y2, z2, Q2, Z2, ee2 = Ba(te2);
  function te2(e2) {
    var n2, r3, i3, o2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (t(this, te2), d(a(r3 = ee2.call(this)), "startListeningForDeviceChanges", function() {
      Pa(r3.handleDeviceChange);
    }), d(a(r3), "stopListeningForDeviceChanges", function() {
      Aa(r3.handleDeviceChange);
    }), d(a(r3), "handleDeviceChange", function(e3) {
      e3 = e3.map(function(e4) {
        return JSON.parse(JSON.stringify(e4));
      }), r3.emitDailyJSEvent({ action: "available-devices-updated", availableDevices: e3 });
    }), d(a(r3), "handleNativeAppStateChange", function() {
      var e3 = p(function* (e4) {
        if ("destroyed" === e4) return console.warn("App has been destroyed before leaving the meeting. Cleaning up all the resources!"), void (yield r3.destroy());
        var t2 = "active" === e4;
        r3.disableReactNativeAutoDeviceManagement("video") || (t2 ? r3.camUnmutedBeforeLosingNativeActiveState && r3.setLocalVideo(true) : (r3.camUnmutedBeforeLosingNativeActiveState = r3.localVideo(), r3.camUnmutedBeforeLosingNativeActiveState && r3.setLocalVideo(false)));
      });
      return function(t2) {
        return e3.apply(this, arguments);
      };
    }()), d(a(r3), "handleNativeAudioFocusChange", function(e3) {
      r3.disableReactNativeAutoDeviceManagement("audio") || (r3._hasNativeAudioFocus = e3, r3.toggleParticipantAudioBasedOnNativeAudioFocus(), r3._hasNativeAudioFocus ? r3.micUnmutedBeforeLosingNativeAudioFocus && r3.setLocalAudio(true) : (r3.micUnmutedBeforeLosingNativeAudioFocus = r3.localAudio(), r3.setLocalAudio(false)));
    }), d(a(r3), "handleNativeSystemScreenCaptureStop", function() {
      r3.stopScreenShare();
    }), r3.strictMode = void 0 === o2.strictMode || o2.strictMode, r3.allowMultipleCallInstances = null !== (n2 = o2.allowMultipleCallInstances) && void 0 !== n2 && n2, Object.keys(Va).length && (r3._logDuplicateInstanceAttempt(), !r3.allowMultipleCallInstances)) {
      if (r3.strictMode) throw new Error("Duplicate DailyIframe instances are not allowed");
      console.warn("Using strictMode: false to allow multiple call instances is now deprecated. Set `allowMultipleCallInstances: true`");
    }
    if (window._daily || (window._daily = { pendings: [], instances: {} }), r3.callClientId = H(), i3 = a(r3), Va[i3.callClientId] = i3, window._daily.instances[r3.callClientId] = {}, r3._sharedTracks = {}, window._daily.instances[r3.callClientId].tracks = r3._sharedTracks, o2.dailyJsVersion = te2.version(), r3._iframe = e2, r3._callObjectMode = "none" === o2.layout && !r3._iframe, r3._preloadCache = { subscribeToTracksAutomatically: true, audioDeviceId: null, videoDeviceId: null, outputDeviceId: null, inputSettings: null, sendSettings: null, videoTrackForNetworkConnectivityTest: null, videoTrackForConnectionQualityTest: null }, void 0 !== o2.showLocalVideo ? r3._callObjectMode ? console.error("showLocalVideo is not available in call object mode") : r3._showLocalVideo = !!o2.showLocalVideo : r3._showLocalVideo = true, void 0 !== o2.showParticipantsBar ? r3._callObjectMode ? console.error("showParticipantsBar is not available in call object mode") : r3._showParticipantsBar = !!o2.showParticipantsBar : r3._showParticipantsBar = true, void 0 !== o2.customIntegrations ? r3._callObjectMode ? console.error("customIntegrations is not available in call object mode") : r3._customIntegrations = o2.customIntegrations : r3._customIntegrations = {}, void 0 !== o2.customTrayButtons ? r3._callObjectMode ? console.error("customTrayButtons is not available in call object mode") : r3._customTrayButtons = o2.customTrayButtons : r3._customTrayButtons = {}, void 0 !== o2.activeSpeakerMode ? r3._callObjectMode ? console.error("activeSpeakerMode is not available in call object mode") : r3._activeSpeakerMode = !!o2.activeSpeakerMode : r3._activeSpeakerMode = false, o2.receiveSettings ? r3._callObjectMode ? r3._receiveSettings = o2.receiveSettings : console.error("receiveSettings is only available in call object mode") : r3._receiveSettings = {}, r3.validateProperties(o2), r3.properties = Ra({}, o2), r3._preloadCache.inputSettings || (r3._preloadCache.inputSettings = {}), o2.inputSettings && o2.inputSettings.audio && (r3._preloadCache.inputSettings.audio = o2.inputSettings.audio), o2.inputSettings && o2.inputSettings.video && (r3._preloadCache.inputSettings.video = o2.inputSettings.video), r3._callObjectLoader = r3._callObjectMode ? new ra(r3.callClientId) : null, r3._callState = br, r3._isPreparingToJoin = false, r3._accessState = { access: xr }, r3._meetingSessionSummary = {}, r3._finalSummaryOfPrevSession = {}, r3._meetingSessionState = Es(Ga, r3._callObjectMode), r3._nativeInCallAudioMode = Ja, r3._participants = {}, r3._isScreenSharing = false, r3._participantCounts = qa, r3._rmpPlayerState = {}, r3._waitingParticipants = {}, r3._network = { threshold: "good", quality: 100 }, r3._activeSpeaker = {}, r3._localAudioLevel = 0, r3._isLocalAudioLevelObserverRunning = false, r3._remoteParticipantsAudioLevel = {}, r3._isRemoteParticipantsAudioLevelObserverRunning = false, r3._maxAppMessageSize = so, r3._messageChannel = Eo() ? new Wo() : new qo(), r3._iframe && (r3._iframe.requestFullscreen ? r3._iframe.addEventListener("fullscreenchange", function() {
      document.fullscreenElement === r3._iframe ? (r3.emitDailyJSEvent({ action: Qi }), r3.sendMessageToCallMachine({ action: Qi })) : (r3.emitDailyJSEvent({ action: Ki }), r3.sendMessageToCallMachine({ action: Ki }));
    }) : r3._iframe.webkitRequestFullscreen && r3._iframe.addEventListener("webkitfullscreenchange", function() {
      document.webkitFullscreenElement === r3._iframe ? (r3.emitDailyJSEvent({ action: Qi }), r3.sendMessageToCallMachine({ action: Qi })) : (r3.emitDailyJSEvent({ action: Ki }), r3.sendMessageToCallMachine({ action: Ki }));
    })), Eo()) {
      var s3 = r3.nativeUtils();
      s3.addAudioFocusChangeListener && s3.removeAudioFocusChangeListener && s3.addAppStateChangeListener && s3.removeAppStateChangeListener && s3.addSystemScreenCaptureStopListener && s3.removeSystemScreenCaptureStopListener || console.warn("expected (add|remove)(AudioFocusChange|AppActiveStateChange|SystemScreenCaptureStop)Listener to be available in React Native"), r3._hasNativeAudioFocus = true, s3.addAudioFocusChangeListener(r3.handleNativeAudioFocusChange), s3.addAppStateChangeListener(r3.handleNativeAppStateChange), s3.addSystemScreenCaptureStopListener(r3.handleNativeSystemScreenCaptureStop);
    }
    return r3._callObjectMode && r3.startListeningForDeviceChanges(), r3._messageChannel.addListenerForMessagesFromCallMachine(r3.handleMessageFromCallMachine, r3.callClientId, a(r3)), r3;
  }
  return o(te2, [{ key: "destroy", value: (Z2 = p(function* () {
    var e2, t2;
    try {
      yield this.leave();
    } catch (e3) {
    }
    var n2 = this._iframe;
    if (n2) {
      var r3 = n2.parentElement;
      r3 && r3.removeChild(n2);
    }
    if (this._messageChannel.removeListener(this.handleMessageFromCallMachine), Eo()) {
      var i3 = this.nativeUtils();
      i3.removeAudioFocusChangeListener(this.handleNativeAudioFocusChange), i3.removeAppStateChangeListener(this.handleNativeAppStateChange), i3.removeSystemScreenCaptureStopListener(this.handleNativeSystemScreenCaptureStop);
    }
    this._callObjectMode && this.stopListeningForDeviceChanges(), this.resetMeetingDependentVars(), this._destroyed = true, this.emitDailyJSEvent({ action: "call-instance-destroyed" }), delete Va[this.callClientId], (null === (e2 = window) || void 0 === e2 || null === (t2 = e2._daily) || void 0 === t2 ? void 0 : t2.instances) && delete window._daily.instances[this.callClientId], this.strictMode && (this.callClientId = void 0);
  }), function() {
    return Z2.apply(this, arguments);
  }) }, { key: "isDestroyed", value: function() {
    return !!this._destroyed;
  } }, { key: "loadCss", value: function(e2) {
    var t2 = e2.bodyClass, n2 = e2.cssFile, r3 = e2.cssText;
    return ls(), this.sendMessageToCallMachine({ action: "load-css", cssFile: this.absoluteUrl(n2), bodyClass: t2, cssText: r3 }), this;
  } }, { key: "iframe", value: function() {
    return ls(), this._iframe;
  } }, { key: "meetingState", value: function() {
    return this._callState;
  } }, { key: "accessState", value: function() {
    return ss(this._callObjectMode, "accessState()"), this._accessState;
  } }, { key: "participants", value: function() {
    return this._participants;
  } }, { key: "participantCounts", value: function() {
    return this._participantCounts;
  } }, { key: "waitingParticipants", value: function() {
    return ss(this._callObjectMode, "waitingParticipants()"), this._waitingParticipants;
  } }, { key: "validateParticipantProperties", value: function(e2, t2) {
    for (var n2 in t2) {
      if (!Za[n2]) throw new Error("unrecognized updateParticipant property ".concat(n2));
      if (Za[n2].validate && !Za[n2].validate(t2[n2], this, this._participants[e2])) throw new Error(Za[n2].help);
    }
  } }, { key: "updateParticipant", value: function(e2, t2) {
    return this._participants.local && this._participants.local.session_id === e2 && (e2 = "local"), e2 && t2 && (this.validateParticipantProperties(e2, t2), this.sendMessageToCallMachine({ action: "update-participant", id: e2, properties: t2 })), this;
  } }, { key: "updateParticipants", value: function(e2) {
    var t2 = this._participants.local && this._participants.local.session_id;
    for (var n2 in e2) n2 === t2 && (n2 = "local"), n2 && e2[n2] && this.validateParticipantProperties(n2, e2[n2]);
    return this.sendMessageToCallMachine({ action: "update-participants", participants: e2 }), this;
  } }, { key: "updateWaitingParticipant", value: (Q2 = p(function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "", r3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (ss(this._callObjectMode, "updateWaitingParticipant()"), ns(this._callState, "updateWaitingParticipant()"), "string" != typeof t2 || "object" !== n(r3)) throw new Error("updateWaitingParticipant() must take an id string and a updates object");
    return new Promise(function(n2, i3) {
      e2.sendMessageToCallMachine({ action: "daily-method-update-waiting-participant", id: t2, updates: r3 }, function(e3) {
        e3.error && i3(e3.error), e3.id || i3(new Error("unknown error in updateWaitingParticipant()")), n2({ id: e3.id });
      });
    });
  }), function() {
    return Q2.apply(this, arguments);
  }) }, { key: "updateWaitingParticipants", value: (z2 = p(function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (ss(this._callObjectMode, "updateWaitingParticipants()"), ns(this._callState, "updateWaitingParticipants()"), "object" !== n(t2)) throw new Error("updateWaitingParticipants() must take a mapping between ids and update objects");
    return new Promise(function(n2, r3) {
      e2.sendMessageToCallMachine({ action: "daily-method-update-waiting-participants", updatesById: t2 }, function(e3) {
        e3.error && r3(e3.error), e3.ids || r3(new Error("unknown error in updateWaitingParticipants()")), n2({ ids: e3.ids });
      });
    });
  }), function() {
    return z2.apply(this, arguments);
  }) }, { key: "requestAccess", value: (Y2 = p(function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, n2 = t2.access, r3 = void 0 === n2 ? { level: Lr } : n2, i3 = t2.name, o2 = void 0 === i3 ? "" : i3;
    return ss(this._callObjectMode, "requestAccess()"), ns(this._callState, "requestAccess()"), new Promise(function(t3, n3) {
      e2.sendMessageToCallMachine({ action: "daily-method-request-access", access: r3, name: o2 }, function(e3) {
        e3.error && n3(e3.error), e3.access || n3(new Error("unknown error in requestAccess()")), t3({ access: e3.access, granted: e3.granted });
      });
    });
  }), function() {
    return Y2.apply(this, arguments);
  }) }, { key: "localAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.audio.state) : null;
  } }, { key: "localVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.video.state) : null;
  } }, { key: "setLocalAudio", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    return "forceDiscardTrack" in t2 && (Eo() ? (console.warn("forceDiscardTrack option not supported in React Native; ignoring"), t2 = {}) : e2 && (console.warn("forceDiscardTrack option only supported when calling setLocalAudio(false); ignoring"), t2 = {})), this.sendMessageToCallMachine({ action: "local-audio", state: e2, options: t2 }), this;
  } }, { key: "localScreenAudio", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenAudio.state) : null;
  } }, { key: "localScreenVideo", value: function() {
    return this._participants.local ? !["blocked", "off"].includes(this._participants.local.tracks.screenVideo.state) : null;
  } }, { key: "updateScreenShare", value: function(e2) {
    if (this._isScreenSharing) return this.sendMessageToCallMachine({ action: "local-screen-update", options: e2 }), this;
    console.warn("There is no screen share in progress. Try calling startScreenShare first.");
  } }, { key: "setLocalVideo", value: function(e2) {
    return this.sendMessageToCallMachine({ action: "local-video", state: e2 }), this;
  } }, { key: "getReceiveSettings", value: (q2 = p(function* (e2) {
    var t2 = this, r3 = (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}).showInheritedValues, i3 = void 0 !== r3 && r3;
    if (ss(this._callObjectMode, "getReceiveSettings()"), !this._callMachineInitialized) return this._receiveSettings;
    switch (n(e2)) {
      case "string":
        return new Promise(function(n2) {
          t2.sendMessageToCallMachine({ action: "get-single-participant-receive-settings", id: e2, showInheritedValues: i3 }, function(e3) {
            n2(e3.receiveSettings);
          });
        });
      case "undefined":
        return this._receiveSettings;
      default:
        throw new Error('first argument to getReceiveSettings() must be a participant id (or "base"), or there should be no arguments');
    }
  }), function(e2) {
    return q2.apply(this, arguments);
  }) }, { key: "updateReceiveSettings", value: (G2 = p(function* (e2) {
    var t2 = this;
    if (ss(this._callObjectMode, "updateReceiveSettings()"), !hs(e2, { allowAllParticipantsKey: true })) throw new Error(vs({ allowAllParticipantsKey: true }));
    return ns(this._callState, "updateReceiveSettings()", "To specify receive settings earlier, use the receiveSettings config property."), new Promise(function(n2) {
      t2.sendMessageToCallMachine({ action: "update-receive-settings", receiveSettings: e2 }, function(e3) {
        n2({ receiveSettings: e3.receiveSettings });
      });
    });
  }), function(e2) {
    return G2.apply(this, arguments);
  }) }, { key: "_prepInputSettingsToPresentToUser", value: function(e2) {
    var t2, n2, r3, i3, o2, a2, s3, c2;
    if (e2) {
      var l3 = {}, u3 = "none" === (null === (t2 = e2.audio) || void 0 === t2 || null === (n2 = t2.processor) || void 0 === n2 ? void 0 : n2.type) && (null === (r3 = e2.audio) || void 0 === r3 || null === (i3 = r3.processor) || void 0 === i3 ? void 0 : i3._isDefaultWhenNone);
      if (e2.audio && !u3) {
        var d2 = Ra({}, e2.audio.processor);
        delete d2._isDefaultWhenNone, l3.audio = Ra(Ra({}, e2.audio), {}, { processor: d2 });
      }
      var h3 = "none" === (null === (o2 = e2.video) || void 0 === o2 || null === (a2 = o2.processor) || void 0 === a2 ? void 0 : a2.type) && (null === (s3 = e2.video) || void 0 === s3 || null === (c2 = s3.processor) || void 0 === c2 ? void 0 : c2._isDefaultWhenNone);
      if (e2.video && !h3) {
        var p2 = Ra({}, e2.video.processor);
        delete p2._isDefaultWhenNone, l3.video = Ra(Ra({}, e2.video), {}, { processor: p2 });
      }
      return l3;
    }
  } }, { key: "getInputSettings", value: function() {
    var e2 = this;
    return ls(), new Promise(function(t2) {
      t2(e2._getInputSettings());
    });
  } }, { key: "_getInputSettings", value: function() {
    var e2, t2, n2, r3, i3, o2, a2, s3, c2 = { processor: { type: "none", _isDefaultWhenNone: true } };
    this._inputSettings ? (e2 = (null === (n2 = this._inputSettings) || void 0 === n2 ? void 0 : n2.video) || c2, t2 = (null === (r3 = this._inputSettings) || void 0 === r3 ? void 0 : r3.audio) || c2) : (e2 = (null === (i3 = this._preloadCache) || void 0 === i3 || null === (o2 = i3.inputSettings) || void 0 === o2 ? void 0 : o2.video) || c2, t2 = (null === (a2 = this._preloadCache) || void 0 === a2 || null === (s3 = a2.inputSettings) || void 0 === s3 ? void 0 : s3.audio) || c2);
    var l3 = { audio: t2, video: e2 };
    return this._prepInputSettingsToPresentToUser(l3);
  } }, { key: "updateInputSettings", value: ($2 = p(function* (e2) {
    var t2 = this;
    return ls(), ps(e2) ? (e2 && (this._preloadCache.inputSettings || (this._preloadCache.inputSettings = {}), fs(e2, this.properties.dailyConfig), e2.audio && (this._preloadCache.inputSettings.audio = e2.audio), e2.video && (this._preloadCache.inputSettings.video = e2.video)), e2.video || e2.audio ? this._callObjectMode && !this._callMachineInitialized ? this._getInputSettings() : new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine({ action: "update-input-settings", inputSettings: e2 }, function(e3) {
        e3.error ? r3(e3.error) : n2({ inputSettings: t2._prepInputSettingsToPresentToUser(e3.inputSettings) });
      });
    }) : this._getInputSettings()) : (console.error(gs()), Promise.reject(gs()));
  }), function(e2) {
    return $2.apply(this, arguments);
  }) }, { key: "setBandwidth", value: function(e2) {
    var t2 = e2.kbs, n2 = e2.trackConstraints;
    if (ls(), this._callMachineInitialized) return this.sendMessageToCallMachine({ action: "set-bandwidth", kbs: t2, trackConstraints: n2 }), this;
  } }, { key: "getDailyLang", value: function() {
    var e2 = this;
    if (ls(), this._callMachineInitialized) return new Promise(function(t2) {
      e2.sendMessageToCallMachine({ action: "get-daily-lang" }, function(e3) {
        delete e3.action, delete e3.callbackStamp, t2(e3);
      });
    });
  } }, { key: "setDailyLang", value: function(e2) {
    return ls(), this.sendMessageToCallMachine({ action: "set-daily-lang", lang: e2 }), this;
  } }, { key: "setProxyUrl", value: function(e2) {
    return this.sendMessageToCallMachine({ action: "set-proxy-url", proxyUrl: e2 }), this;
  } }, { key: "setIceConfig", value: function(e2) {
    return this.sendMessageToCallMachine({ action: "set-ice-config", iceConfig: e2 }), this;
  } }, { key: "meetingSessionSummary", value: function() {
    return [Cr, Mr].includes(this._callState) ? this._finalSummaryOfPrevSession : this._meetingSessionSummary;
  } }, { key: "getMeetingSession", value: (J2 = p(function* () {
    var e2 = this;
    return console.warn("getMeetingSession() is deprecated: use meetingSessionSummary(), which will return immediately"), ns(this._callState, "getMeetingSession()"), new Promise(function(t2) {
      e2.sendMessageToCallMachine({ action: "get-meeting-session" }, function(e3) {
        delete e3.action, delete e3.callbackStamp, t2(e3);
      });
    });
  }), function() {
    return J2.apply(this, arguments);
  }) }, { key: "meetingSessionState", value: function() {
    return ns(this._callState, "meetingSessionState"), this._meetingSessionState;
  } }, { key: "setMeetingSessionData", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "replace";
    ss(this._callObjectMode, "setMeetingSessionData()"), ns(this._callState, "setMeetingSessionData");
    try {
      !function(e3, t3) {
        new Xo({ data: e3, mergeStrategy: t3 });
      }(e2, t2);
    } catch (e3) {
      throw console.error(e3), e3;
    }
    try {
      this.sendMessageToCallMachine({ action: "set-session-data", data: e2, mergeStrategy: t2 });
    } catch (e3) {
      throw new Error("Error setting meeting session data: ".concat(e3));
    }
  } }, { key: "setUserName", value: function(e2, t2) {
    var n2 = this;
    return this.properties.userName = e2, new Promise(function(r3) {
      n2.sendMessageToCallMachine({ action: "set-user-name", name: null != e2 ? e2 : "", thisMeetingOnly: Eo() || !!t2 && !!t2.thisMeetingOnly }, function(e3) {
        delete e3.action, delete e3.callbackStamp, r3(e3);
      });
    });
  } }, { key: "setUserData", value: (V2 = p(function* (e2) {
    var t2 = this;
    try {
      ds(e2);
    } catch (e3) {
      throw console.error(e3), e3;
    }
    if (this.properties.userData = e2, this._callMachineInitialized) return new Promise(function(n2) {
      try {
        t2.sendMessageToCallMachine({ action: "set-user-data", userData: e2 }, function(e3) {
          delete e3.action, delete e3.callbackStamp, n2(e3);
        });
      } catch (e3) {
        throw new Error("Error setting user data: ".concat(e3));
      }
    });
  }), function(e2) {
    return V2.apply(this, arguments);
  }) }, { key: "validateAudioLevelInterval", value: function(e2) {
    if (e2 && (e2 < 100 || "number" != typeof e2)) throw new Error("The interval must be a number greater than or equal to 100 milliseconds.");
  } }, { key: "startLocalAudioLevelObserver", value: function(e2) {
    var t2 = this;
    if ("undefined" == typeof AudioWorkletNode && !Eo()) throw new Error("startLocalAudioLevelObserver() is not supported on this browser");
    if (this.validateAudioLevelInterval(e2), this._callMachineInitialized) return this._isLocalAudioLevelObserverRunning = true, new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine({ action: "start-local-audio-level-observer", interval: e2 }, function(e3) {
        t2._isLocalAudioLevelObserverRunning = !e3.error, e3.error ? r3({ error: e3.error }) : n2();
      });
    });
    this._preloadCache.localAudioLevelObserver = { enabled: true, interval: e2 };
  } }, { key: "isLocalAudioLevelObserverRunning", value: function() {
    return this._isLocalAudioLevelObserverRunning;
  } }, { key: "stopLocalAudioLevelObserver", value: function() {
    this._preloadCache.localAudioLevelObserver = null, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-local-audio-level-observer" });
  } }, { key: "startRemoteParticipantsAudioLevelObserver", value: function(e2) {
    var t2 = this;
    if (this.validateAudioLevelInterval(e2), this._callMachineInitialized) return this._isRemoteParticipantsAudioLevelObserverRunning = true, new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine({ action: "start-remote-participants-audio-level-observer", interval: e2 }, function(e3) {
        t2._isRemoteParticipantsAudioLevelObserverRunning = !e3.error, e3.error ? r3({ error: e3.error }) : n2();
      });
    });
    this._preloadCache.remoteParticipantsAudioLevelObserver = { enabled: true, interval: e2 };
  } }, { key: "isRemoteParticipantsAudioLevelObserverRunning", value: function() {
    return this._isRemoteParticipantsAudioLevelObserverRunning;
  } }, { key: "stopRemoteParticipantsAudioLevelObserver", value: function() {
    this._preloadCache.remoteParticipantsAudioLevelObserver = null, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this.sendMessageToCallMachine({ action: "stop-remote-participants-audio-level-observer" });
  } }, { key: "startCamera", value: (U2 = p(function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (ss(this._callObjectMode, "startCamera()"), is(this._callState, this._isPreparingToJoin, "startCamera()", "Did you mean to use setLocalAudio() and/or setLocalVideo() instead?"), this.needsLoad()) try {
      yield this.load(t2);
    } catch (e3) {
      return Promise.reject(e3);
    }
    else {
      if (this._didPreAuth) {
        if (t2.url && t2.url !== this.properties.url) return console.error("url in startCamera() is different than the one used in preAuth()"), Promise.reject();
        if (t2.token && t2.token !== this.properties.token) return console.error("token in startCamera() is different than the one used in preAuth()"), Promise.reject();
      }
      this.validateProperties(t2), this.properties = Ra(Ra({}, this.properties), t2);
    }
    return new Promise(function(t3) {
      e2.sendMessageToCallMachine({ action: "start-camera", properties: ts(e2.properties, e2.callClientId), preloadCache: ts(e2._preloadCache, e2.callClientId) }, function(e3) {
        delete e3.action, delete e3.callbackStamp, t3(e3);
      });
    });
  }), function() {
    return U2.apply(this, arguments);
  }) }, { key: "validateCustomTrack", value: function(e2, t2, n2) {
    if (n2 && n2.length > 50) throw new Error("Custom track `trackName` must not be more than 50 characters");
    if (t2 && "music" !== t2 && "speech" !== t2 && !(t2 instanceof Object)) throw new Error("Custom track `mode` must be either `music` | `speech` | `DailyMicAudioModeSettings` or `undefined`");
    if (!!n2 && ["cam-audio", "cam-video", "screen-video", "screen-audio", "rmpAudio", "rmpVideo", "customVideoDefaults"].includes(n2)) throw new Error("Custom track `trackName` must not match a track name already used by daily: cam-audio, cam-video, customVideoDefaults, screen-video, screen-audio, rmpAudio, rmpVideo");
    if (!(e2 instanceof MediaStreamTrack)) throw new Error("Custom tracks provided must be instances of MediaStreamTrack");
  } }, { key: "startCustomTrack", value: function() {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : { track, mode, trackName };
    return ls(), ns(this._callState, "startCustomTrack()"), this.validateCustomTrack(t2.track, t2.mode, t2.trackName), new Promise(function(n2, r3) {
      e2._sharedTracks.customTrack = t2.track, t2.track = fo, e2.sendMessageToCallMachine({ action: "start-custom-track", properties: t2 }, function(e3) {
        e3.error ? r3({ error: e3.error }) : n2(e3.mediaTag);
      });
    });
  } }, { key: "stopCustomTrack", value: function(e2) {
    var t2 = this;
    return ls(), ns(this._callState, "stopCustomTrack()"), new Promise(function(n2) {
      t2.sendMessageToCallMachine({ action: "stop-custom-track", mediaTag: e2 }, function(e3) {
        n2(e3.mediaTag);
      });
    });
  } }, { key: "setCamera", value: function(e2) {
    var t2 = this;
    return us(), os(this._callMachineInitialized, "setCamera()"), new Promise(function(n2) {
      t2.sendMessageToCallMachine({ action: "set-camera", cameraDeviceId: e2 }, function(e3) {
        n2({ device: e3.device });
      });
    });
  } }, { key: "setAudioDevice", value: (F2 = p(function* (e2) {
    return us(), this.nativeUtils().setAudioDevice(e2), { deviceId: yield this.nativeUtils().getAudioDevice() };
  }), function(e2) {
    return F2.apply(this, arguments);
  }) }, { key: "cycleCamera", value: function() {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new Promise(function(n2) {
      e2.sendMessageToCallMachine({ action: "cycle-camera", properties: t2 }, function(e3) {
        n2({ device: e3.device });
      });
    });
  } }, { key: "cycleMic", value: function() {
    var e2 = this;
    return ls(), new Promise(function(t2) {
      e2.sendMessageToCallMachine({ action: "cycle-mic" }, function(e3) {
        t2({ device: e3.device });
      });
    });
  } }, { key: "getCameraFacingMode", value: function() {
    var e2 = this;
    return us(), new Promise(function(t2) {
      e2.sendMessageToCallMachine({ action: "get-camera-facing-mode" }, function(e3) {
        t2(e3.facingMode);
      });
    });
  } }, { key: "setInputDevicesAsync", value: (B2 = p(function* (e2) {
    var t2 = this, n2 = e2.audioDeviceId, r3 = e2.videoDeviceId, i3 = e2.audioSource, o2 = e2.videoSource;
    return ls(), void 0 !== i3 && (n2 = i3), void 0 !== o2 && (r3 = o2), n2 && (this._preloadCache.audioDeviceId = n2, this._sharedTracks.audioDeviceId = n2), r3 && (this._preloadCache.videoDeviceId = r3, this._sharedTracks.videoDeviceId = r3), this._callObjectMode && this.needsLoad() ? { camera: { deviceId: this._preloadCache.videoDeviceId }, mic: { deviceId: this._preloadCache.audioDeviceId }, speaker: { deviceId: this._preloadCache.outputDeviceId } } : (n2 instanceof MediaStreamTrack && (n2 = fo), r3 instanceof MediaStreamTrack && (r3 = fo), new Promise(function(e3) {
      t2.sendMessageToCallMachine({ action: "set-input-devices", audioDeviceId: n2, videoDeviceId: r3 }, function(n3) {
        delete n3.action, delete n3.callbackStamp, n3.returnPreloadCache ? e3({ camera: { deviceId: t2._preloadCache.videoDeviceId }, mic: { deviceId: t2._preloadCache.audioDeviceId }, speaker: { deviceId: t2._preloadCache.outputDeviceId } }) : e3(n3);
      });
    }));
  }), function(e2) {
    return B2.apply(this, arguments);
  }) }, { key: "setOutputDeviceAsync", value: (R2 = p(function* (e2) {
    var t2 = this, n2 = e2.outputDeviceId;
    return ls(), n2 && (this._preloadCache.outputDeviceId = n2), this._callObjectMode && this.needsLoad() ? { camera: { deviceId: this._preloadCache.videoDeviceId }, mic: { deviceId: this._preloadCache.audioDeviceId }, speaker: { deviceId: this._preloadCache.outputDeviceId } } : new Promise(function(e3) {
      t2.sendMessageToCallMachine({ action: "set-output-device", outputDeviceId: n2 }, function(n3) {
        delete n3.action, delete n3.callbackStamp, n3.returnPreloadCache ? e3({ camera: { deviceId: t2._preloadCache.videoDeviceId }, mic: { deviceId: t2._preloadCache.audioDeviceId }, speaker: { deviceId: t2._preloadCache.outputDeviceId } }) : e3(n3);
      });
    });
  }), function(e2) {
    return R2.apply(this, arguments);
  }) }, { key: "getInputDevices", value: (N2 = p(function* () {
    var e2 = this;
    return this._callObjectMode && this.needsLoad() ? { camera: { deviceId: this._preloadCache.videoDeviceId }, mic: { deviceId: this._preloadCache.audioDeviceId }, speaker: { deviceId: this._preloadCache.outputDeviceId } } : new Promise(function(t2) {
      e2.sendMessageToCallMachine({ action: "get-input-devices" }, function(n2) {
        delete n2.action, delete n2.callbackStamp, n2.returnPreloadCache ? t2({ camera: { deviceId: e2._preloadCache.videoDeviceId }, mic: { deviceId: e2._preloadCache.audioDeviceId }, speaker: { deviceId: e2._preloadCache.outputDeviceId } }) : t2(n2);
      });
    });
  }), function() {
    return N2.apply(this, arguments);
  }) }, { key: "nativeInCallAudioMode", value: function() {
    return us(), this._nativeInCallAudioMode;
  } }, { key: "setNativeInCallAudioMode", value: function(e2) {
    if (us(), [Ja, $a].includes(e2)) {
      if (e2 !== this._nativeInCallAudioMode) return this._nativeInCallAudioMode = e2, !this.disableReactNativeAutoDeviceManagement("audio") && rs(this._callState, this._isPreparingToJoin) && this.nativeUtils().setAudioMode(this._nativeInCallAudioMode), this;
    } else console.error("invalid in-call audio mode specified: ", e2);
  } }, { key: "preAuth", value: (L2 = p(function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (ss(this._callObjectMode, "preAuth()"), is(this._callState, this._isPreparingToJoin, "preAuth()"), this.needsLoad() && (yield this.load(t2)), !t2.url) throw new Error("preAuth() requires at least a url to be provided");
    return this.validateProperties(t2), this.properties = Ra(Ra({}, this.properties), t2), new Promise(function(t3, n2) {
      e2.sendMessageToCallMachine({ action: "daily-method-preauth", properties: ts(e2.properties, e2.callClientId), preloadCache: ts(e2._preloadCache, e2.callClientId) }, function(r3) {
        return r3.error ? n2(r3.error) : r3.access ? (e2._didPreAuth = true, void t3({ access: r3.access })) : n2(new Error("unknown error in preAuth()"));
      });
    });
  }), function() {
    return L2.apply(this, arguments);
  }) }, { key: "load", value: (x2 = p(function* (e2) {
    var t2 = this;
    if (this.needsLoad()) {
      if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode)) throw new Error("Use after destroy");
      if (e2 && (this.validateProperties(e2), this.properties = Ra(Ra({}, this.properties), e2)), !this._callObjectMode && !this.properties.url) throw new Error("can't load iframe meeting because url property isn't set");
      return this._updateCallState(wr), this.emitDailyJSEvent({ action: ai }), this._callObjectMode ? new Promise(function(e3, n2) {
        t2._callObjectLoader.cancel();
        var r3 = Date.now();
        t2._callObjectLoader.load(t2.properties.dailyConfig, function(n3) {
          t2._bundleLoadTime = n3 ? "no-op" : Date.now() - r3, t2._updateCallState(Sr), n3 && t2.emitDailyJSEvent({ action: ci }), e3();
        }, function(e4, r4) {
          if (t2.emitDailyJSEvent({ action: si }), !r4) {
            t2._updateCallState(Mr), t2.resetMeetingDependentVars();
            var i3 = { action: ao, errorMsg: e4.msg, error: { type: "connection-error", msg: "Failed to load call object bundle.", details: { on: "load", sourceError: e4, bundleUrl: X(t2.properties.dailyConfig) } } };
            t2._maybeSendToSentry(i3), t2.emitDailyJSEvent(i3), n2(e4.msg);
          }
        });
      }) : (this._iframe.src = K(this.assembleMeetingUrl(), this.properties.dailyConfig), new Promise(function(e3, n2) {
        t2._loadedCallback = function(r3) {
          t2._callState !== Mr ? (t2._updateCallState(Sr), (t2.properties.cssFile || t2.properties.cssText) && t2.loadCss(t2.properties), e3()) : n2(r3);
        };
      }));
    }
  }), function(e2) {
    return x2.apply(this, arguments);
  }) }, { key: "join", value: (j2 = p(function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this._testCallInProgress && this.stopTestCallQuality();
    var n2 = false;
    if (this.needsLoad()) {
      this.updateIsPreparingToJoin(true);
      try {
        yield this.load(t2);
      } catch (e3) {
        return this.updateIsPreparingToJoin(false), Promise.reject(e3);
      }
    } else {
      if (n2 = !(!this.properties.cssFile && !this.properties.cssText), this._didPreAuth) {
        if (t2.url && t2.url !== this.properties.url) return console.error("url in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
        if (t2.token && t2.token !== this.properties.token) return console.error("token in join() is different than the one used in preAuth()"), this.updateIsPreparingToJoin(false), Promise.reject();
      }
      if (t2.url && !this._callObjectMode && t2.url && t2.url !== this.properties.url) return console.error("url in join() is different than the one used in load() (".concat(this.properties.url, " -> ").concat(t2.url, ")")), this.updateIsPreparingToJoin(false), Promise.reject();
      this.validateProperties(t2), this.properties = Ra(Ra({}, this.properties), t2);
    }
    return void 0 !== t2.showLocalVideo && (this._callObjectMode ? console.error("showLocalVideo is not available in callObject mode") : this._showLocalVideo = !!t2.showLocalVideo), void 0 !== t2.showParticipantsBar && (this._callObjectMode ? console.error("showParticipantsBar is not available in callObject mode") : this._showParticipantsBar = !!t2.showParticipantsBar), this._callState === Er || this._callState === kr ? (console.warn("already joined meeting, call leave() before joining again"), void this.updateIsPreparingToJoin(false)) : (this._updateCallState(kr, false), this.emitDailyJSEvent({ action: di }), this._preloadCache.inputSettings || (this._preloadCache.inputSettings = {}), t2.inputSettings && t2.inputSettings.audio && (this._preloadCache.inputSettings.audio = t2.inputSettings.audio), t2.inputSettings && t2.inputSettings.video && (this._preloadCache.inputSettings.video = t2.inputSettings.video), this.sendMessageToCallMachine({ action: "join-meeting", properties: ts(this.properties, this.callClientId), preloadCache: ts(this._preloadCache, this.callClientId) }), new Promise(function(t3, r3) {
      e2._joinedCallback = function(i3, o2) {
        if (e2._callState !== Mr) {
          if (e2._updateCallState(Er), i3) for (var a2 in i3) {
            if (e2._callObjectMode) {
              var s3 = e2._callMachine().store;
              va(i3[a2], s3), ma(i3[a2], s3), _a(i3[a2], e2._participants[a2], s3);
            }
            e2._participants[a2] = Ra({}, i3[a2]), e2.toggleParticipantAudioBasedOnNativeAudioFocus();
          }
          n2 && e2.loadCss(e2.properties), t3(i3);
        } else r3(o2);
      };
    }));
  }), function() {
    return j2.apply(this, arguments);
  }) }, { key: "leave", value: (D2 = p(function* () {
    var e2 = this;
    return this._testCallInProgress && this.stopTestCallQuality(), new Promise(function(t2) {
      e2._callState === Cr || e2._callState === Mr ? t2() : e2._callObjectLoader && !e2._callObjectLoader.loaded ? (e2._callObjectLoader.cancel(), e2._updateCallState(Cr), e2.resetMeetingDependentVars(), e2.emitDailyJSEvent({ action: Cr }), t2()) : (e2._resolveLeave = t2, e2.sendMessageToCallMachine({ action: "leave-meeting" }));
    });
  }), function() {
    return D2.apply(this, arguments);
  }) }, { key: "startScreenShare", value: (A2 = p(function* () {
    var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    if (os(this._callMachineInitialized, "startScreenShare()"), t2.screenVideoSendSettings && this._validateVideoSendSettings("screenVideo", t2.screenVideoSendSettings), t2.mediaStream && (this._sharedTracks.screenMediaStream = t2.mediaStream, t2.mediaStream = fo), "undefined" != typeof DailyNativeUtils && void 0 !== DailyNativeUtils.isIOS && DailyNativeUtils.isIOS) {
      var n2 = this.nativeUtils();
      if (yield n2.isScreenBeingCaptured()) return void this.emitDailyJSEvent({ action: oo, type: "screen-share-error", errorMsg: "Could not start the screen sharing. The screen is already been captured!" });
      n2.setSystemScreenCaptureStartCallback(function() {
        n2.setSystemScreenCaptureStartCallback(null), e2.sendMessageToCallMachine({ action: uo, captureOptions: t2 });
      }), n2.presentSystemScreenCapturePrompt();
    } else this.sendMessageToCallMachine({ action: uo, captureOptions: t2 });
  }), function() {
    return A2.apply(this, arguments);
  }) }, { key: "stopScreenShare", value: function() {
    os(this._callMachineInitialized, "stopScreenShare()"), this.sendMessageToCallMachine({ action: "local-screen-stop" });
  } }, { key: "startRecording", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Ra({ action: "local-recording-start" }, e2));
  } }, { key: "updateRecording", value: function(e2) {
    var t2 = e2.layout, n2 = void 0 === t2 ? { preset: "default" } : t2, r3 = e2.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-recording", layout: n2, instanceId: r3 });
  } }, { key: "stopRecording", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Ra({ action: "local-recording-stop" }, e2));
  } }, { key: "startLiveStreaming", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Ra({ action: "daily-method-start-live-streaming" }, e2));
  } }, { key: "updateLiveStreaming", value: function(e2) {
    var t2 = e2.layout, n2 = void 0 === t2 ? { preset: "default" } : t2, r3 = e2.instanceId;
    this.sendMessageToCallMachine({ action: "daily-method-update-live-streaming", layout: n2, instanceId: r3 });
  } }, { key: "addLiveStreamingEndpoints", value: function(e2) {
    var t2 = e2.endpoints, n2 = e2.instanceId;
    this.sendMessageToCallMachine({ action: ho, endpointsOp: bo, endpoints: t2, instanceId: n2 });
  } }, { key: "removeLiveStreamingEndpoints", value: function(e2) {
    var t2 = e2.endpoints, n2 = e2.instanceId;
    this.sendMessageToCallMachine({ action: ho, endpointsOp: wo, endpoints: t2, instanceId: n2 });
  } }, { key: "stopLiveStreaming", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    this.sendMessageToCallMachine(Ra({ action: "daily-method-stop-live-streaming" }, e2));
  } }, { key: "validateDailyConfig", value: function(e2) {
    e2.camSimulcastEncodings && (console.warn("camSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide camera simulcast settings."), this.validateSimulcastEncodings(e2.camSimulcastEncodings)), e2.screenSimulcastEncodings && console.warn("screenSimulcastEncodings is deprecated. Use sendSettings, found in DailyCallOptions, to provide screen simulcast settings."), xo() && e2.noAutoDefaultDeviceChange && console.warn("noAutoDefaultDeviceChange is not supported on Android, and will be ignored.");
  } }, { key: "validateSimulcastEncodings", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (e2) {
      if (!(e2 instanceof Array || Array.isArray(e2))) throw new Error("encodings must be an Array");
      if (!ks(e2.length, 1, 3)) throw new Error("encodings must be an Array with between 1 to ".concat(3, " layers"));
      for (var r3 = 0; r3 < e2.length; r3++) {
        var i3 = e2[r3];
        for (var o2 in this._validateEncodingLayerHasValidProperties(i3), i3) if (za.includes(o2)) {
          if ("number" != typeof i3[o2]) throw new Error("".concat(o2, " must be a number"));
          if (t2) {
            var a2 = t2[o2], s3 = a2.min, c2 = a2.max;
            if (!ks(i3[o2], s3, c2)) throw new Error("".concat(o2, " value not in range. valid range: ").concat(s3, " to ").concat(c2));
          }
        } else if (!["active", "scalabilityMode"].includes(o2)) throw new Error("Invalid key ".concat(o2, ", valid keys are:") + Object.values(za));
        if (n2 && !i3.hasOwnProperty("maxBitrate")) throw new Error("maxBitrate is not specified");
      }
    }
  } }, { key: "startRemoteMediaPlayer", value: (P2 = p(function* (e2) {
    var t2 = this, n2 = e2.url, r3 = e2.settings, i3 = void 0 === r3 ? { state: mo.PLAY } : r3;
    try {
      !function(e3) {
        if ("string" != typeof e3) throw new Error('url parameter must be "string" type');
      }(n2), Ss(i3), function(e3) {
        for (var t3 in e3) if (!Wa.includes(t3)) throw new Error("Invalid key ".concat(t3, ", valid keys are: ").concat(Wa));
        e3.simulcastEncodings && this.validateSimulcastEncodings(e3.simulcastEncodings, Ya, true);
      }(i3);
    } catch (e3) {
      throw console.error("invalid argument Error: ".concat(e3)), console.error('startRemoteMediaPlayer arguments must be of the form:\n  { url: "playback url",\n  settings?:\n  {state: "play"|"pause", simulcastEncodings?: [{}] } }'), e3;
    }
    return new Promise(function(e3, r4) {
      t2.sendMessageToCallMachine({ action: "daily-method-start-remote-media-player", url: n2, settings: i3 }, function(t3) {
        t3.error ? r4({ error: t3.error, errorMsg: t3.errorMsg }) : e3({ session_id: t3.session_id, remoteMediaPlayerState: { state: t3.state, settings: t3.settings } });
      });
    });
  }), function(e2) {
    return P2.apply(this, arguments);
  }) }, { key: "stopRemoteMediaPlayer", value: (O2 = p(function* (e2) {
    var t2 = this;
    if ("string" != typeof e2) throw new Error(" remotePlayerID must be of type string");
    return new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine({ action: "daily-method-stop-remote-media-player", session_id: e2 }, function(e3) {
        e3.error ? r3({ error: e3.error, errorMsg: e3.errorMsg }) : n2();
      });
    });
  }), function(e2) {
    return O2.apply(this, arguments);
  }) }, { key: "updateRemoteMediaPlayer", value: (T2 = p(function* (e2) {
    var t2 = this, n2 = e2.session_id, r3 = e2.settings;
    try {
      Ss(r3);
    } catch (e3) {
      throw console.error("invalid argument Error: ".concat(e3)), console.error('updateRemoteMediaPlayer arguments must be of the form:\n  session_id: "participant session",\n  { settings?: {state: "play"|"pause"} }'), e3;
    }
    return new Promise(function(e3, i3) {
      t2.sendMessageToCallMachine({ action: "daily-method-update-remote-media-player", session_id: n2, settings: r3 }, function(t3) {
        t3.error ? i3({ error: t3.error, errorMsg: t3.errorMsg }) : e3({ session_id: t3.session_id, remoteMediaPlayerState: { state: t3.state, settings: t3.settings } });
      });
    });
  }), function(e2) {
    return T2.apply(this, arguments);
  }) }, { key: "startTranscription", value: function(e2) {
    this.sendMessageToCallMachine(Ra({ action: "daily-method-start-transcription" }, e2));
  } }, { key: "stopTranscription", value: function() {
    this.sendMessageToCallMachine({ action: "daily-method-stop-transcription" });
  } }, { key: "startDialOut", value: (M2 = p(function* (e2) {
    var t2 = this;
    ns(this._callState, "startDialOut()");
    var n2 = function(e3) {
      if (e3) {
        if (!Array.isArray(e3)) throw new Error("Error starting dial out: audio codec must be an array");
        if (e3.length <= 0) throw new Error("Error starting dial out: audio codec array specified but empty");
        e3.forEach(function(e4) {
          if ("string" != typeof e4) throw new Error("Error starting dial out: audio codec must be a string");
          if ("OPUS" !== e4 && "PCMU" !== e4 && "PCMA" !== e4 && "G722" !== e4) throw new Error("Error starting dial out: audio codec must be one of OPUS, PCMU, PCMA, G722");
        });
      }
    };
    if (!e2.sipUri && !e2.phoneNumber) throw new Error("Error starting dial out: either a sip uri or phone number must be provided");
    if (e2.sipUri && e2.phoneNumber) throw new Error("Error starting dial out: only one of sip uri or phone number must be provided");
    if (e2.sipUri) {
      if ("string" != typeof e2.sipUri) throw new Error("Error starting dial out: sipUri must be a string");
      if (!e2.sipUri.startsWith("sip:")) throw new Error("Error starting dial out: Invalid SIP URI, must start with 'sip:'");
      if (e2.video && "boolean" != typeof e2.video) throw new Error("Error starting dial out: video must be a boolean value");
      !function(e3) {
        if (e3 && (n2(e3.audio), e3.video)) {
          if (!Array.isArray(e3.video)) throw new Error("Error starting dial out: video codec must be an array");
          if (e3.video.length <= 0) throw new Error("Error starting dial out: video codec array specified but empty");
          e3.video.forEach(function(e4) {
            if ("string" != typeof e4) throw new Error("Error starting dial out: video codec must be a string");
            if ("H264" !== e4 && "VP8" !== e4) throw new Error("Error starting dial out: video codec must be H264 or VP8");
          });
        }
      }(e2.codecs);
    }
    if (e2.phoneNumber) {
      if ("string" != typeof e2.phoneNumber) throw new Error("Error starting dial out: phoneNumber must be a string");
      if (!/^\+\d{1,}$/.test(e2.phoneNumber)) throw new Error("Error starting dial out: Invalid phone number, must be valid phone number as per E.164");
      e2.codecs && n2(e2.codecs.audio);
    }
    if (e2.callerId) {
      if ("string" != typeof e2.callerId) throw new Error("Error starting dial out: callerId must be a string");
      if (e2.sipUri) throw new Error("Error starting dial out: callerId not allowed with sipUri");
    }
    if (e2.displayName) {
      if ("string" != typeof e2.displayName) throw new Error("Error starting dial out: displayName must be a string");
      if (e2.displayName.length >= 200) throw new Error("Error starting dial out: displayName length must be less than 200");
    }
    return new Promise(function(n3, r3) {
      t2.sendMessageToCallMachine(Ra({ action: "dialout-start" }, e2), function(e3) {
        e3.error ? r3(e3.error) : n3(e3);
      });
    });
  }), function(e2) {
    return M2.apply(this, arguments);
  }) }, { key: "stopDialOut", value: function(e2) {
    var t2 = this;
    return ns(this._callState, "stopDialOut()"), new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine(Ra({ action: "dialout-stop" }, e2), function(e3) {
        e3.error ? r3(e3.error) : n2(e3);
      });
    });
  } }, { key: "sipCallTransfer", value: (C2 = p(function* (e2) {
    var t2 = this;
    if (ns(this._callState, "sipCallTransfer()"), !e2) throw new Error("sipCallTransfer() requires a sessionId and toEndPoint");
    return e2.useSipRefer = false, ws(e2, "sipCallTransfer"), new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine(Ra({ action: So }, e2), function(e3) {
        e3.error ? r3(e3.error) : n2(e3);
      });
    });
  }), function(e2) {
    return C2.apply(this, arguments);
  }) }, { key: "sipRefer", value: (E2 = p(function* (e2) {
    var t2 = this;
    if (ns(this._callState, "sipRefer()"), !e2) throw new Error("sessionId and toEndPoint are mandatory parameter");
    return e2.useSipRefer = true, ws(e2, "sipRefer"), new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine(Ra({ action: So }, e2), function(e3) {
        e3.error ? r3(e3.error) : n2(e3);
      });
    });
  }), function(e2) {
    return E2.apply(this, arguments);
  }) }, { key: "sendDTMF", value: (k2 = p(function* (e2) {
    var t2 = this;
    return ns(this._callState, "sendDTMF()"), function(e3) {
      var t3 = e3.sessionId, n2 = e3.tones;
      if (!t3 || !n2) throw new Error("sessionId and tones are mandatory parameter");
      if ("string" != typeof t3 || "string" != typeof n2) throw new Error("sessionId and tones should be of string type");
      if (n2.length > 20) throw new Error("tones string must be upto 20 characters");
      var r3 = /[^0-9A-D*#]/g, i3 = n2.match(r3);
      if (i3 && i3[0]) throw new Error("".concat(i3[0], " is not valid DTMF tone"));
    }(e2), new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine(Ra({ action: "send-dtmf" }, e2), function(e3) {
        e3.error ? r3(e3.error) : n2(e3);
      });
    });
  }), function(e2) {
    return k2.apply(this, arguments);
  }) }, { key: "getNetworkStats", value: function() {
    var e2 = this;
    if (this._callState !== Er) {
      return { stats: { latest: {} } };
    }
    return new Promise(function(t2) {
      e2.sendMessageToCallMachine({ action: "get-calc-stats" }, function(n2) {
        t2(Ra({ stats: n2.stats }, e2._network));
      });
    });
  } }, { key: "testWebsocketConnectivity", value: (S2 = p(function* () {
    var e2 = this;
    if (as(this._testCallInProgress, "testWebsocketConnectivity()"), this.needsLoad()) try {
      yield this.load();
    } catch (e3) {
      return Promise.reject(e3);
    }
    return new Promise(function(t2, n2) {
      e2.sendMessageToCallMachine({ action: "test-websocket-connectivity" }, function(e3) {
        e3.error ? n2(e3.error) : t2(e3.results);
      });
    });
  }), function() {
    return S2.apply(this, arguments);
  }) }, { key: "abortTestWebsocketConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-websocket-connectivity" });
  } }, { key: "_validateVideoTrackForNetworkTests", value: function(e2) {
    return e2 ? e2 instanceof MediaStreamTrack ? !!xa(e2, { isLocalScreenVideo: false }) || (console.error("Video track is not playable. This test needs a live video track."), false) : (console.error("Video track needs to be of type `MediaStreamTrack`."), false) : (console.error("Missing video track. You must provide a video track in order to run this test."), false);
  } }, { key: "testCallQuality", value: (w2 = p(function* () {
    var t2 = this;
    ls(), ss(this._callObjectMode, "testCallQuality()"), os(this._callMachineInitialized, "testCallQuality()", null, true), is(this._callState, this._isPreparingToJoin, "testCallQuality()");
    var n2 = this._testCallAlreadyInProgress, r3 = function(e2) {
      n2 || (t2._testCallInProgress = e2);
    };
    if (r3(true), this.needsLoad()) try {
      var i3 = this._callState;
      yield this.load(), this._callState = i3;
    } catch (e2) {
      return r3(false), Promise.reject(e2);
    }
    return new Promise(function(n3) {
      t2.sendMessageToCallMachine({ action: "test-call-quality", dailyJsVersion: t2.properties.dailyJsVersion }, function(i4) {
        var o2 = i4.results, a2 = o2.result, s3 = e(o2, La);
        if ("failed" === a2) {
          var c2, l3 = Ra({}, s3);
          null !== (c2 = s3.error) && void 0 !== c2 && c2.details ? (s3.error.details = JSON.parse(s3.error.details), l3.error = Ra(Ra({}, l3.error), {}, { details: Ra({}, l3.error.details) }), l3.error.details.duringTest = "testCallQuality") : (l3.error = l3.error ? Ra({}, l3.error) : {}, l3.error.details = { duringTest: "testCallQuality" }), t2._maybeSendToSentry(l3);
        }
        r3(false), n3(Ra({ result: a2 }, s3));
      });
    });
  }), function() {
    return w2.apply(this, arguments);
  }) }, { key: "stopTestCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-call-quality" });
  } }, { key: "testConnectionQuality", value: (b2 = p(function* (e2) {
    var t2;
    Eo() ? (console.warn("testConnectionQuality() is deprecated: use testPeerToPeerCallQuality() instead"), t2 = yield this.testPeerToPeerCallQuality(e2)) : (console.warn("testConnectionQuality() is deprecated: use testCallQuality() instead"), t2 = yield this.testCallQuality());
    var n2 = { result: t2.result, secondsElapsed: t2.secondsElapsed };
    return t2.data && (n2.data = { maxRTT: t2.data.maxRoundTripTime, packetLoss: t2.data.avgRecvPacketLoss }), n2;
  }), function(e2) {
    return b2.apply(this, arguments);
  }) }, { key: "testPeerToPeerCallQuality", value: (_2 = p(function* (e2) {
    var t2 = this;
    if (as(this._testCallInProgress, "testPeerToPeerCallQuality()"), this.needsLoad()) try {
      yield this.load();
    } catch (e3) {
      return Promise.reject(e3);
    }
    var n2 = e2.videoTrack, r3 = e2.duration;
    if (!this._validateVideoTrackForNetworkTests(n2)) throw new Error("Video track error");
    return this._sharedTracks.videoTrackForConnectionQualityTest = n2, new Promise(function(e3, n3) {
      t2.sendMessageToCallMachine({ action: "test-p2p-call-quality", duration: r3 }, function(t3) {
        t3.error ? n3(t3.error) : e3(t3.results);
      });
    });
  }), function(e2) {
    return _2.apply(this, arguments);
  }) }, { key: "stopTestConnectionQuality", value: function() {
    Eo() ? (console.warn("stopTestConnectionQuality() is deprecated: use testPeerToPeerCallQuality() and stopTestPeerToPeerCallQuality() instead"), this.stopTestPeerToPeerCallQuality()) : (console.warn("stopTestConnectionQuality() is deprecated: use testCallQuality() and stopTestCallQuality() instead"), this.stopTestCallQuality());
  } }, { key: "stopTestPeerToPeerCallQuality", value: function() {
    this.sendMessageToCallMachine({ action: "stop-test-p2p-call-quality" });
  } }, { key: "testNetworkConnectivity", value: (y2 = p(function* (e2) {
    var t2 = this;
    if (as(this._testCallInProgress, "testNetworkConnectivity()"), this.needsLoad()) try {
      yield this.load();
    } catch (e3) {
      return Promise.reject(e3);
    }
    if (!this._validateVideoTrackForNetworkTests(e2)) throw new Error("Video track error");
    return this._sharedTracks.videoTrackForNetworkConnectivityTest = e2, new Promise(function(e3, n2) {
      t2.sendMessageToCallMachine({ action: "test-network-connectivity" }, function(t3) {
        t3.error ? n2(t3.error) : e3(t3.results);
      });
    });
  }), function(e2) {
    return y2.apply(this, arguments);
  }) }, { key: "abortTestNetworkConnectivity", value: function() {
    this.sendMessageToCallMachine({ action: "abort-test-network-connectivity" });
  } }, { key: "getCpuLoadStats", value: function() {
    var e2 = this;
    return new Promise(function(t2) {
      if (e2._callState === Er) {
        e2.sendMessageToCallMachine({ action: "get-cpu-load-stats" }, function(e3) {
          t2(e3.cpuStats);
        });
      } else t2({ cpuLoadState: void 0, cpuLoadStateReason: void 0, stats: {} });
    });
  } }, { key: "_validateEncodingLayerHasValidProperties", value: function(e2) {
    var t2;
    if (!((null === (t2 = Object.keys(e2)) || void 0 === t2 ? void 0 : t2.length) > 0)) throw new Error("Empty encoding is not allowed. At least one of these valid keys should be specified:" + Object.values(za));
  } }, { key: "_validateVideoSendSettings", value: function(e2, t2) {
    var r3 = "screenVideo" === e2 ? ["default-screen-video", "detail-optimized", "motion-optimized", "motion-and-detail-balanced"] : ["default-video", "bandwidth-optimized", "bandwidth-and-quality-balanced", "quality-optimized", "adaptive-2-layers", "adaptive-3-layers"], i3 = "Video send settings should be either an object or one of the supported presets: ".concat(r3.join());
    if ("string" == typeof t2) {
      if (!r3.includes(t2)) throw new Error(i3);
    } else {
      if ("object" !== n(t2)) throw new Error(i3);
      if (!t2.maxQuality && !t2.encodings && void 0 === t2.allowAdaptiveLayers) throw new Error("Video send settings must contain at least maxQuality, allowAdaptiveLayers or encodings attribute");
      if (t2.maxQuality && -1 === ["low", "medium", "high"].indexOf(t2.maxQuality)) throw new Error("maxQuality must be either low, medium or high");
      if (t2.encodings) {
        var o2 = false;
        switch (Object.keys(t2.encodings).length) {
          case 1:
            o2 = !t2.encodings.low;
            break;
          case 2:
            o2 = !t2.encodings.low || !t2.encodings.medium;
            break;
          case 3:
            o2 = !t2.encodings.low || !t2.encodings.medium || !t2.encodings.high;
            break;
          default:
            o2 = true;
        }
        if (o2) throw new Error("Encodings must be defined as: low, low and medium, or low, medium and high.");
        t2.encodings.low && this._validateEncodingLayerHasValidProperties(t2.encodings.low), t2.encodings.medium && this._validateEncodingLayerHasValidProperties(t2.encodings.medium), t2.encodings.high && this._validateEncodingLayerHasValidProperties(t2.encodings.high);
      }
    }
  } }, { key: "validateUpdateSendSettings", value: function(e2) {
    var t2 = this;
    if (!e2 || 0 === Object.keys(e2).length) throw new Error("Send settings must contain at least information for one track!");
    Object.entries(e2).forEach(function(e3) {
      var n2 = g(e3, 2), r3 = n2[0], i3 = n2[1];
      t2._validateVideoSendSettings(r3, i3);
    });
  } }, { key: "updateSendSettings", value: function(e2) {
    var t2 = this;
    return this.validateUpdateSendSettings(e2), this.needsLoad() ? (this._preloadCache.sendSettings = e2, { sendSettings: this._preloadCache.sendSettings }) : new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine({ action: "update-send-settings", sendSettings: e2 }, function(e3) {
        e3.error ? r3(e3.error) : n2(e3.sendSettings);
      });
    });
  } }, { key: "getSendSettings", value: function() {
    return this._sendSettings || this._preloadCache.sendSettings;
  } }, { key: "getLocalAudioLevel", value: function() {
    return this._localAudioLevel;
  } }, { key: "getRemoteParticipantsAudioLevel", value: function() {
    return this._remoteParticipantsAudioLevel;
  } }, { key: "getActiveSpeaker", value: function() {
    return ls(), this._activeSpeaker;
  } }, { key: "setActiveSpeakerMode", value: function(e2) {
    return ls(), this.sendMessageToCallMachine({ action: "set-active-speaker-mode", enabled: e2 }), this;
  } }, { key: "activeSpeakerMode", value: function() {
    return ls(), this._activeSpeakerMode;
  } }, { key: "subscribeToTracksAutomatically", value: function() {
    return this._preloadCache.subscribeToTracksAutomatically;
  } }, { key: "setSubscribeToTracksAutomatically", value: function(e2) {
    return ns(this._callState, "setSubscribeToTracksAutomatically()", "Use the subscribeToTracksAutomatically configuration property."), this._preloadCache.subscribeToTracksAutomatically = e2, this.sendMessageToCallMachine({ action: "daily-method-subscribe-to-tracks-automatically", enabled: e2 }), this;
  } }, { key: "enumerateDevices", value: (v2 = p(function* () {
    var e2 = this;
    if (this._callObjectMode) {
      var t2 = yield navigator.mediaDevices.enumerateDevices();
      return "Firefox" === Io() && No().major > 115 && No().major < 123 && (t2 = t2.filter(function(e3) {
        return "audiooutput" !== e3.kind;
      })), { devices: t2.map(function(e3) {
        var t3 = JSON.parse(JSON.stringify(e3));
        if (!Eo() && "videoinput" === e3.kind && e3.getCapabilities) {
          var n2, r3 = e3.getCapabilities();
          t3.facing = (null == r3 || null === (n2 = r3.facingMode) || void 0 === n2 ? void 0 : n2.length) >= 1 ? r3.facingMode[0] : void 0;
        }
        return t3;
      }) };
    }
    return new Promise(function(t3) {
      e2.sendMessageToCallMachine({ action: "enumerate-devices" }, function(e3) {
        t3({ devices: e3.devices });
      });
    });
  }), function() {
    return v2.apply(this, arguments);
  }) }, { key: "sendAppMessage", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "*";
    if (ns(this._callState, "sendAppMessage()"), JSON.stringify(e2).length > this._maxAppMessageSize) throw new Error("Message data too large. Max size is " + this._maxAppMessageSize);
    return this.sendMessageToCallMachine({ action: "app-msg", data: e2, to: t2 }), this;
  } }, { key: "addFakeParticipant", value: function(e2) {
    return ls(), ns(this._callState, "addFakeParticipant()"), this.sendMessageToCallMachine(Ra({ action: "add-fake-participant" }, e2)), this;
  } }, { key: "setShowNamesMode", value: function(e2) {
    return cs(this._callObjectMode, "setShowNamesMode()"), ls(), e2 && "always" !== e2 && "never" !== e2 ? (console.error('setShowNamesMode argument should be "always", "never", or false'), this) : (this.sendMessageToCallMachine({ action: "set-show-names", mode: e2 }), this);
  } }, { key: "setShowLocalVideo", value: function() {
    var e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return cs(this._callObjectMode, "setShowLocalVideo()"), ls(), ns(this._callState, "setShowLocalVideo()"), "boolean" != typeof e2 ? (console.error("setShowLocalVideo only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-local-video", show: e2 }), this._showLocalVideo = e2, this);
  } }, { key: "showLocalVideo", value: function() {
    return cs(this._callObjectMode, "showLocalVideo()"), ls(), this._showLocalVideo;
  } }, { key: "setShowParticipantsBar", value: function() {
    var e2 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
    return cs(this._callObjectMode, "setShowParticipantsBar()"), ls(), ns(this._callState, "setShowParticipantsBar()"), "boolean" != typeof e2 ? (console.error("setShowParticipantsBar only accepts a boolean value"), this) : (this.sendMessageToCallMachine({ action: "set-show-participants-bar", show: e2 }), this._showParticipantsBar = e2, this);
  } }, { key: "showParticipantsBar", value: function() {
    return cs(this._callObjectMode, "showParticipantsBar()"), ls(), this._showParticipantsBar;
  } }, { key: "customIntegrations", value: function() {
    return ls(), cs(this._callObjectMode, "customIntegrations()"), this._customIntegrations;
  } }, { key: "setCustomIntegrations", value: function(e2) {
    return ls(), cs(this._callObjectMode, "setCustomIntegrations()"), ns(this._callState, "setCustomIntegrations()"), _s(e2) ? (this.sendMessageToCallMachine({ action: "set-custom-integrations", integrations: e2 }), this._customIntegrations = e2, this) : this;
  } }, { key: "startCustomIntegrations", value: function(e2) {
    var t2 = this;
    if (ls(), cs(this._callObjectMode, "startCustomIntegrations()"), ns(this._callState, "startCustomIntegrations()"), Array.isArray(e2) && e2.some(function(e3) {
      return "string" != typeof e3;
    }) || !Array.isArray(e2) && "string" != typeof e2) return console.error("startCustomIntegrations() only accepts string | string[]"), this;
    var n2 = "string" == typeof e2 ? [e2] : e2, r3 = n2.filter(function(e3) {
      return !(e3 in t2._customIntegrations);
    });
    return r3.length ? (console.error(`Can't find custom integration(s): "`.concat(r3.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "start-custom-integrations", ids: n2 }), this);
  } }, { key: "stopCustomIntegrations", value: function(e2) {
    var t2 = this;
    if (ls(), cs(this._callObjectMode, "stopCustomIntegrations()"), ns(this._callState, "stopCustomIntegrations()"), Array.isArray(e2) && e2.some(function(e3) {
      return "string" != typeof e3;
    }) || !Array.isArray(e2) && "string" != typeof e2) return console.error("stopCustomIntegrations() only accepts string | string[]"), this;
    var n2 = "string" == typeof e2 ? [e2] : e2, r3 = n2.filter(function(e3) {
      return !(e3 in t2._customIntegrations);
    });
    return r3.length ? (console.error(`Can't find custom integration(s): "`.concat(r3.join(", "), '"')), this) : (this.sendMessageToCallMachine({ action: "stop-custom-integrations", ids: n2 }), this);
  } }, { key: "customTrayButtons", value: function() {
    return cs(this._callObjectMode, "customTrayButtons()"), ls(), this._customTrayButtons;
  } }, { key: "updateCustomTrayButtons", value: function(e2) {
    return cs(this._callObjectMode, "updateCustomTrayButtons()"), ls(), ns(this._callState, "updateCustomTrayButtons()"), ys(e2) ? (this.sendMessageToCallMachine({ action: "update-custom-tray-buttons", btns: e2 }), this._customTrayButtons = e2, this) : (console.error("updateCustomTrayButtons only accepts a dictionary of the type ".concat(JSON.stringify(Qa))), this);
  } }, { key: "theme", value: function() {
    return cs(this._callObjectMode, "theme()"), this.properties.theme;
  } }, { key: "setTheme", value: function(e2) {
    var t2 = this;
    return cs(this._callObjectMode, "setTheme()"), new Promise(function(n2, r3) {
      try {
        t2.validateProperties({ theme: e2 }), t2.properties.theme = Ra({}, e2), t2.sendMessageToCallMachine({ action: "set-theme", theme: t2.properties.theme });
        try {
          t2.emitDailyJSEvent({ action: oi, theme: t2.properties.theme });
        } catch (e3) {
          console.log("could not emit 'theme-updated'", e3);
        }
        n2(t2.properties.theme);
      } catch (e3) {
        r3(e3);
      }
    });
  } }, { key: "requestFullscreen", value: (f2 = p(function* () {
    if (ls(), this._iframe && !document.fullscreenElement && To()) try {
      (yield this._iframe.requestFullscreen) ? this._iframe.requestFullscreen() : this._iframe.webkitRequestFullscreen();
    } catch (e2) {
      console.log("could not make video call fullscreen", e2);
    }
  }), function() {
    return f2.apply(this, arguments);
  }) }, { key: "exitFullscreen", value: function() {
    ls(), document.fullscreenElement ? document.exitFullscreen() : document.webkitFullscreenElement && document.webkitExitFullscreen();
  } }, { key: "getSidebarView", value: (h2 = p(function* () {
    var e2 = this;
    return this._callObjectMode ? (console.error("getSidebarView is not available in callObject mode"), Promise.resolve(null)) : new Promise(function(t2) {
      e2.sendMessageToCallMachine({ action: "get-sidebar-view" }, function(e3) {
        t2(e3.view);
      });
    });
  }), function() {
    return h2.apply(this, arguments);
  }) }, { key: "setSidebarView", value: function(e2) {
    return this._callObjectMode ? (console.error("setSidebarView is not available in callObject mode"), this) : (this.sendMessageToCallMachine({ action: "set-sidebar-view", view: e2 }), this);
  } }, { key: "room", value: (u2 = p(function* () {
    var e2 = this, t2 = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).includeRoomConfigDefaults, n2 = void 0 === t2 || t2;
    return this._accessState.access === xr || this.needsLoad() ? this.properties.url ? { roomUrlPendingJoin: this.properties.url } : null : new Promise(function(t3) {
      e2.sendMessageToCallMachine({ action: "lib-room-info", includeRoomConfigDefaults: n2 }, function(e3) {
        delete e3.action, delete e3.callbackStamp, t3(e3);
      });
    });
  }), function() {
    return u2.apply(this, arguments);
  }) }, { key: "geo", value: (l2 = p(function* () {
    try {
      var e2 = yield fetch("https://gs.daily.co/_ks_/x-swsl/:");
      return { current: (yield e2.json()).geo };
    } catch (e3) {
      return console.error("geo lookup failed", e3), { current: "" };
    }
  }), function() {
    return l2.apply(this, arguments);
  }) }, { key: "setNetworkTopology", value: (s2 = p(function* (e2) {
    var t2 = this;
    return ls(), ns(this._callState, "setNetworkTopology()"), new Promise(function(n2, r3) {
      t2.sendMessageToCallMachine({ action: "set-network-topology", opts: e2 }, function(e3) {
        e3.error ? r3({ error: e3.error }) : n2({ workerId: e3.workerId });
      });
    });
  }), function(e2) {
    return s2.apply(this, arguments);
  }) }, { key: "getNetworkTopology", value: (i2 = p(function* () {
    var e2 = this;
    return new Promise(function(t2, n2) {
      e2.needsLoad() && t2({ topology: "none" }), e2.sendMessageToCallMachine({ action: "get-network-topology" }, function(e3) {
        e3.error ? n2({ error: e3.error }) : t2({ topology: e3.topology });
      });
    });
  }), function() {
    return i2.apply(this, arguments);
  }) }, { key: "setPlayNewParticipantSound", value: function(e2) {
    if (ls(), "number" != typeof e2 && true !== e2 && false !== e2) throw new Error("argument to setShouldPlayNewParticipantSound should be true, false, or a number, but is ".concat(e2));
    this.sendMessageToCallMachine({ action: "daily-method-set-play-ding", arg: e2 });
  } }, { key: "on", value: function(e2, t2) {
    return m.prototype.on.call(this, e2, t2);
  } }, { key: "once", value: function(e2, t2) {
    return m.prototype.once.call(this, e2, t2);
  } }, { key: "off", value: function(e2, t2) {
    return m.prototype.off.call(this, e2, t2);
  } }, { key: "validateProperties", value: function(e2) {
    for (var t2 in e2) {
      if (!Xa[t2]) throw new Error("unrecognized property '".concat(t2, "'"));
      if (Xa[t2].validate && !Xa[t2].validate(e2[t2], this)) throw new Error("property '".concat(t2, "': ").concat(Xa[t2].help));
    }
  } }, { key: "assembleMeetingUrl", value: function() {
    var e2, t2, n2 = Ra(Ra({}, this.properties), {}, { emb: this.callClientId, embHref: encodeURIComponent(window.location.href), proxy: null !== (e2 = this.properties.dailyConfig) && void 0 !== e2 && e2.proxyUrl ? encodeURIComponent(null === (t2 = this.properties.dailyConfig) || void 0 === t2 ? void 0 : t2.proxyUrl) : void 0 }), r3 = n2.url.match(/\?/) ? "&" : "?";
    return n2.url + r3 + Object.keys(Xa).filter(function(e3) {
      return Xa[e3].queryString && void 0 !== n2[e3];
    }).map(function(e3) {
      return "".concat(Xa[e3].queryString, "=").concat(n2[e3]);
    }).join("&");
  } }, { key: "needsLoad", value: function() {
    return [br, wr, Cr, Mr].includes(this._callState);
  } }, { key: "sendMessageToCallMachine", value: function(e2, t2) {
    if (this._destroyed && (this._logUseAfterDestroy(), this.strictMode)) throw new Error("Use after destroy");
    this._messageChannel.sendMessageToCallMachine(e2, t2, this.callClientId, this._iframe);
  } }, { key: "forwardPackagedMessageToCallMachine", value: function(e2) {
    this._messageChannel.forwardPackagedMessageToCallMachine(e2, this._iframe, this.callClientId);
  } }, { key: "addListenerForPackagedMessagesFromCallMachine", value: function(e2) {
    return this._messageChannel.addListenerForPackagedMessagesFromCallMachine(e2, this.callClientId);
  } }, { key: "removeListenerForPackagedMessagesFromCallMachine", value: function(e2) {
    this._messageChannel.removeListenerForPackagedMessagesFromCallMachine(e2);
  } }, { key: "handleMessageFromCallMachine", value: function(t2) {
    switch (t2.action) {
      case ri:
        this.sendMessageToCallMachine(Ra({ action: ii }, this.properties));
        break;
      case "call-machine-initialized":
        this._callMachineInitialized = true;
        var n2 = { action: po, level: "log", code: 1011, stats: { event: "bundle load", time: "no-op" === this._bundleLoadTime ? 0 : this._bundleLoadTime, preLoaded: "no-op" === this._bundleLoadTime, url: X(this.properties.dailyConfig) } };
        this.sendMessageToCallMachine(n2), this._delayDuplicateInstanceLog && this._logDuplicateInstanceAttempt();
        break;
      case ci:
        this._loadedCallback && (this._loadedCallback(), this._loadedCallback = null), this.emitDailyJSEvent(t2);
        break;
      case hi:
        var r3, i3 = Ra({}, t2);
        delete i3.internal, this._maxAppMessageSize = (null === (r3 = t2.internal) || void 0 === r3 ? void 0 : r3._maxAppMessageSize) || so, this._joinedCallback && (this._joinedCallback(t2.participants), this._joinedCallback = null), this.emitDailyJSEvent(i3);
        break;
      case fi:
      case gi:
        if (this._callState === Cr) return;
        if (t2.participant && t2.participant.session_id) {
          var o2 = t2.participant.local ? "local" : t2.participant.session_id;
          if (this._callObjectMode) {
            var a2 = this._callMachine().store;
            va(t2.participant, a2), ma(t2.participant, a2), _a(t2.participant, this._participants[o2], a2);
          }
          try {
            this.maybeParticipantTracksStopped(this._participants[o2], t2.participant), this.maybeParticipantTracksStarted(this._participants[o2], t2.participant), this.maybeEventRecordingStopped(this._participants[o2], t2.participant), this.maybeEventRecordingStarted(this._participants[o2], t2.participant);
          } catch (e2) {
            console.error("track events error", e2);
          }
          this.compareEqualForParticipantUpdateEvent(t2.participant, this._participants[o2]) || (this._participants[o2] = Ra({}, t2.participant), this.toggleParticipantAudioBasedOnNativeAudioFocus(), this.emitDailyJSEvent(t2));
        }
        break;
      case vi:
        if (t2.participant && t2.participant.session_id) {
          var s3 = this._participants[t2.participant.session_id];
          s3 && this.maybeParticipantTracksStopped(s3, null), delete this._participants[t2.participant.session_id], this.emitDailyJSEvent(t2);
        }
        break;
      case mi:
        I(this._participantCounts, t2.participantCounts) || (this._participantCounts = t2.participantCounts, this.emitDailyJSEvent(t2));
        break;
      case yi:
        var c2 = { access: t2.access };
        t2.awaitingAccess && (c2.awaitingAccess = t2.awaitingAccess), I(this._accessState, c2) || (this._accessState = c2, this.emitDailyJSEvent(t2));
        break;
      case _i:
        if (t2.meetingSession) {
          this._meetingSessionSummary = t2.meetingSession, this.emitDailyJSEvent(t2);
          var l3 = Ra(Ra({}, t2), {}, { action: "meeting-session-updated" });
          this.emitDailyJSEvent(l3);
        }
        break;
      case ao:
        var u3;
        this._iframe && !t2.preserveIframe && (this._iframe.src = ""), this._updateCallState(Mr), this.resetMeetingDependentVars(), this._loadedCallback && (this._loadedCallback(t2.errorMsg), this._loadedCallback = null), t2.preserveIframe;
        var d2 = e(t2, Ia);
        null != d2 && null !== (u3 = d2.error) && void 0 !== u3 && u3.details && (d2.error.details = JSON.parse(d2.error.details)), this._maybeSendToSentry(t2), this._joinedCallback && (this._joinedCallback(null, d2), this._joinedCallback = null), this.emitDailyJSEvent(d2);
        break;
      case pi:
        this._callState !== Mr && this._updateCallState(Cr), this.resetMeetingDependentVars(), this._resolveLeave && (this._resolveLeave(), this._resolveLeave = null), this.emitDailyJSEvent(t2);
        break;
      case "selected-devices-updated":
        t2.devices && this.emitDailyJSEvent(t2);
        break;
      case Yi:
        var h3 = t2.threshold, p2 = t2.quality;
        h3 === this._network.threshold && p2 === this._network.quality || (this._network.quality = p2, this._network.threshold = h3, this.emitDailyJSEvent(t2));
        break;
      case Wi:
        t2 && t2.cpuLoadState && this.emitDailyJSEvent(t2);
        break;
      case Hi:
        t2 && void 0 !== t2.faceCounts && this.emitDailyJSEvent(t2);
        break;
      case Gi:
        var f3 = t2.activeSpeaker;
        this._activeSpeaker.peerId !== f3.peerId && (this._activeSpeaker.peerId = f3.peerId, this.emitDailyJSEvent({ action: t2.action, activeSpeaker: this._activeSpeaker }));
        break;
      case "show-local-video-changed":
        if (this._callObjectMode) return;
        var g2 = t2.show;
        this._showLocalVideo = g2, this.emitDailyJSEvent({ action: t2.action, show: g2 });
        break;
      case qi:
        var v3 = t2.enabled;
        this._activeSpeakerMode !== v3 && (this._activeSpeakerMode = v3, this.emitDailyJSEvent({ action: t2.action, enabled: this._activeSpeakerMode }));
        break;
      case Si:
      case ki:
      case Ei:
        this._waitingParticipants = t2.allWaitingParticipants, this.emitDailyJSEvent({ action: t2.action, participant: t2.participant });
        break;
      case ro:
        I(this._receiveSettings, t2.receiveSettings) || (this._receiveSettings = t2.receiveSettings, this.emitDailyJSEvent({ action: t2.action, receiveSettings: t2.receiveSettings }));
        break;
      case io:
        if (!I(this._inputSettings, t2.inputSettings)) {
          var m2 = this._getInputSettings();
          this._inputSettings = t2.inputSettings, this._preloadCache.inputSettings = {}, I(m2, this._getInputSettings()) || this.emitDailyJSEvent({ action: t2.action, inputSettings: this._getInputSettings() });
        }
        break;
      case "send-settings-updated":
        I(this._sendSettings, t2.sendSettings) || (this._sendSettings = t2.sendSettings, this._preloadCache.sendSettings = null, this.emitDailyJSEvent({ action: t2.action, sendSettings: t2.sendSettings }));
        break;
      case "local-audio-level":
        this._localAudioLevel = t2.audioLevel, this._preloadCache.localAudioLevelObserver = null, this.emitDailyJSEvent(t2);
        break;
      case "remote-participants-audio-level":
        this._remoteParticipantsAudioLevel = t2.participantsAudioLevel, this._preloadCache.remoteParticipantsAudioLevelObserver = null, this.emitDailyJSEvent(t2);
        break;
      case Bi:
        var y3 = t2.session_id;
        this._rmpPlayerState[y3] = t2.playerState, this.emitDailyJSEvent(t2);
        break;
      case Ui:
        delete this._rmpPlayerState[t2.session_id], this.emitDailyJSEvent(t2);
        break;
      case Fi:
        var _3 = t2.session_id, b3 = this._rmpPlayerState[_3];
        b3 && this.compareEqualForRMPUpdateEvent(b3, t2.remoteMediaPlayerState) || (this._rmpPlayerState[_3] = t2.remoteMediaPlayerState, this.emitDailyJSEvent(t2));
        break;
      case "custom-button-click":
      case "sidebar-view-changed":
        this.emitDailyJSEvent(t2);
        break;
      case bi:
        var w3 = this._meetingSessionState.topology !== (t2.meetingSessionState && t2.meetingSessionState.topology);
        this._meetingSessionState = Es(t2.meetingSessionState, this._callObjectMode), (this._callObjectMode || w3) && this.emitDailyJSEvent(t2);
        break;
      case Vi:
        this._isScreenSharing = true, this.emitDailyJSEvent(t2);
        break;
      case Ji:
      case $i:
        this._isScreenSharing = false, this.emitDailyJSEvent(t2);
        break;
      case Ai:
      case Di:
      case ji:
      case xi:
      case Li:
      case Ti:
      case Oi:
      case Pi:
      case li:
      case ui:
      case Ni:
      case Ri:
      case zi:
      case Ii:
      case Xi:
      case Zi:
      case eo:
      case to:
      case oo:
      case no:
      case "dialin-ready":
      case "dialin-connected":
      case "dialin-error":
      case "dialin-stopped":
      case "dialin-warning":
      case "dialout-connected":
      case "dialout-answered":
      case "dialout-error":
      case "dialout-stopped":
      case "dialout-warning":
        this.emitDailyJSEvent(t2);
        break;
      case "request-fullscreen":
        this.requestFullscreen();
        break;
      case "request-exit-fullscreen":
        this.exitFullscreen();
    }
  } }, { key: "maybeEventRecordingStopped", value: function(e2, t2) {
    var n2 = "record";
    e2 && (t2.local || false !== t2[n2] || e2[n2] === t2[n2] || this.emitDailyJSEvent({ action: Di }));
  } }, { key: "maybeEventRecordingStarted", value: function(e2, t2) {
    var n2 = "record";
    e2 && (t2.local || true !== t2[n2] || e2[n2] === t2[n2] || this.emitDailyJSEvent({ action: Ai }));
  } }, { key: "maybeEventTrackStopped", value: function(e2, t2, n2, r3) {
    e2 && ("ended" !== e2.readyState && t2 && e2.id === t2.id || this.emitDailyJSEvent({ action: Mi, track: e2, participant: n2, type: r3 }));
  } }, { key: "maybeEventTrackStarted", value: function(e2, t2, n2, r3) {
    t2 && (e2 && "ended" !== e2.readyState && t2.id === e2.id || this.emitDailyJSEvent({ action: Ci, track: t2, participant: n2, type: r3 }));
  } }, { key: "maybeParticipantTracksStopped", value: function(e2, t2) {
    if (e2) for (var n2 in e2.tracks) this.maybeEventTrackStopped(e2.tracks[n2].track, t2 && t2.tracks[n2] ? t2.tracks[n2].track : null, t2, n2);
  } }, { key: "maybeParticipantTracksStarted", value: function(e2, t2) {
    if (t2) for (var n2 in t2.tracks) this.maybeEventTrackStarted(e2 && e2.tracks[n2] ? e2.tracks[n2].track : null, t2.tracks[n2].track, t2, n2);
  } }, { key: "compareEqualForRMPUpdateEvent", value: function(e2, t2) {
    var n2, r3;
    return e2.state === t2.state && (null === (n2 = e2.settings) || void 0 === n2 ? void 0 : n2.volume) === (null === (r3 = t2.settings) || void 0 === r3 ? void 0 : r3.volume);
  } }, { key: "emitDailyJSEvent", value: function(e2) {
    try {
      e2.callClientId = this.callClientId, this.emit(e2.action, e2);
    } catch (t2) {
      console.log("could not emit", e2, t2);
    }
  } }, { key: "compareEqualForParticipantUpdateEvent", value: function(e2, t2) {
    return !!I(e2, t2) && ((!e2.videoTrack || !t2.videoTrack || e2.videoTrack.id === t2.videoTrack.id && e2.videoTrack.muted === t2.videoTrack.muted && e2.videoTrack.enabled === t2.videoTrack.enabled) && (!e2.audioTrack || !t2.audioTrack || e2.audioTrack.id === t2.audioTrack.id && e2.audioTrack.muted === t2.audioTrack.muted && e2.audioTrack.enabled === t2.audioTrack.enabled));
  } }, { key: "nativeUtils", value: function() {
    return Eo() ? "undefined" == typeof DailyNativeUtils ? (console.warn("in React Native, DailyNativeUtils is expected to be available"), null) : DailyNativeUtils : null;
  } }, { key: "updateIsPreparingToJoin", value: function(e2) {
    this._updateCallState(this._callState, e2);
  } }, { key: "_updateCallState", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this._isPreparingToJoin;
    if (e2 !== this._callState || t2 !== this._isPreparingToJoin) {
      var n2 = this._callState, r3 = this._isPreparingToJoin;
      this._callState = e2, this._isPreparingToJoin = t2;
      var i3 = rs(n2, r3), o2 = rs(this._callState, this._isPreparingToJoin);
      i3 !== o2 && (this.updateKeepDeviceAwake(o2), this.updateDeviceAudioMode(o2), this.updateShowAndroidOngoingMeetingNotification(o2), this.updateNoOpRecordingEnsuringBackgroundContinuity(o2));
    }
  } }, { key: "resetMeetingDependentVars", value: function() {
    this._participants = {}, this._participantCounts = qa, this._waitingParticipants = {}, this._activeSpeaker = {}, this._activeSpeakerMode = false, this._didPreAuth = false, this._accessState = { access: xr }, this._finalSummaryOfPrevSession = this._meetingSessionSummary, this._meetingSessionSummary = {}, this._meetingSessionState = Es(Ga, this._callObjectMode), this._isScreenSharing = false, this._receiveSettings = {}, this._inputSettings = void 0, this._sendSettings = {}, this._localAudioLevel = 0, this._isLocalAudioLevelObserverRunning = false, this._remoteParticipantsAudioLevel = {}, this._isRemoteParticipantsAudioLevelObserverRunning = false, this._maxAppMessageSize = so, this._callMachineInitialized = false, this._bundleLoadTime = void 0, this._preloadCache;
  } }, { key: "updateKeepDeviceAwake", value: function(e2) {
    Eo() && this.nativeUtils().setKeepDeviceAwake(e2, this.callClientId);
  } }, { key: "updateDeviceAudioMode", value: function(e2) {
    if (Eo() && !this.disableReactNativeAutoDeviceManagement("audio")) {
      var t2 = e2 ? this._nativeInCallAudioMode : "idle";
      this.nativeUtils().setAudioMode(t2);
    }
  } }, { key: "updateShowAndroidOngoingMeetingNotification", value: function(e2) {
    if (Eo() && this.nativeUtils().setShowOngoingMeetingNotification) {
      var t2, n2, r3, i3;
      if (this.properties.reactNativeConfig && this.properties.reactNativeConfig.androidInCallNotification) {
        var o2 = this.properties.reactNativeConfig.androidInCallNotification;
        t2 = o2.title, n2 = o2.subtitle, r3 = o2.iconName, i3 = o2.disableForCustomOverride;
      }
      i3 && (e2 = false), this.nativeUtils().setShowOngoingMeetingNotification(e2, t2, n2, r3, this.callClientId);
    }
  } }, { key: "updateNoOpRecordingEnsuringBackgroundContinuity", value: function(e2) {
    Eo() && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity && this.nativeUtils().enableNoOpRecordingEnsuringBackgroundContinuity(e2);
  } }, { key: "toggleParticipantAudioBasedOnNativeAudioFocus", value: function() {
    var e2, t2;
    if (Eo()) {
      var n2 = null === (e2 = this._callMachine()) || void 0 === e2 || null === (t2 = e2.store) || void 0 === t2 ? void 0 : t2.getState();
      for (var r3 in null == n2 ? void 0 : n2.streams) {
        var i3 = n2.streams[r3];
        i3 && i3.pendingTrack && "audio" === i3.pendingTrack.kind && (i3.pendingTrack.enabled = this._hasNativeAudioFocus);
      }
    }
  } }, { key: "disableReactNativeAutoDeviceManagement", value: function(e2) {
    return this.properties.reactNativeConfig && this.properties.reactNativeConfig.disableAutoDeviceManagement && this.properties.reactNativeConfig.disableAutoDeviceManagement[e2];
  } }, { key: "absoluteUrl", value: function(e2) {
    if (void 0 !== e2) {
      var t2 = document.createElement("a");
      return t2.href = e2, t2.href;
    }
  } }, { key: "sayHello", value: function() {
    var e2 = "hello, world.";
    return console.log(e2), e2;
  } }, { key: "_logUseAfterDestroy", value: function() {
    var e2 = Object.values(Va)[0];
    if (this.needsLoad()) {
      if (e2 && !e2.needsLoad()) {
        var t2 = { action: po, level: "error", code: this.strictMode ? 9995 : 9997 };
        e2.sendMessageToCallMachine(t2);
      } else if (!this.strictMode) {
        console.error("You are are attempting to use a call instance that was previously destroyed, which is unsupported. Please remove `strictMode: false` from your constructor properties to enable strict mode to track down and fix this unsupported usage.");
      }
    } else {
      var n2 = { action: po, level: "error", code: this.strictMode ? 9995 : 9997 };
      this._messageChannel.sendMessageToCallMachine(n2, null, this.callClientId, this._iframe);
    }
  } }, { key: "_logDuplicateInstanceAttempt", value: function() {
    for (var e2 = 0, t2 = Object.values(Va); e2 < t2.length; e2++) {
      var n2 = t2[e2];
      n2._callMachineInitialized ? (n2.sendMessageToCallMachine({ action: po, level: "warn", code: this.allowMultipleCallInstances ? 9993 : 9992 }), n2._delayDuplicateInstanceLog = false) : n2._delayDuplicateInstanceLog = true;
    }
  } }, { key: "_maybeSendToSentry", value: function(e2) {
    var t2, n2, r3, i3, o2, a2;
    if (null !== (t2 = e2.error) && void 0 !== t2 && t2.type) {
      if (!["connection-error", "end-of-life", "no-room"].includes(e2.error.type)) return;
    }
    var s3 = null !== (n2 = this.properties) && void 0 !== n2 && n2.url ? new URL(this.properties.url) : void 0, c2 = "production";
    s3 && s3.host.includes(".staging.daily") && (c2 = "staging");
    var l3, u3, d2, h3, p2, f3 = new Hn({ dsn: "https://f10f1c81e5d44a4098416c0867a8b740@o77906.ingest.sentry.io/168844", transport: Kn, integrations: [new _r.GlobalHandlers({ onunhandledrejection: false }), new _r.HttpContext()], environment: c2 }), g2 = new tn(f3, void 0, te2.version());
    if (this.session_id && g2.setExtra("sessionId", this.session_id), this.properties) {
      var v3 = Ra({}, this.properties);
      v3.userName = v3.userName ? "[Filtered]" : void 0, v3.userData = v3.userData ? "[Filtered]" : void 0, v3.token = v3.token ? "[Filtered]" : void 0, g2.setExtra("properties", v3);
    }
    if (s3) {
      var m2 = s3.searchParams.get("domain");
      if (!m2) {
        var y3 = s3.host.match(/(.*?)\./);
        m2 = y3 && y3[1] || "";
      }
      m2 && g2.setTag("domain", m2);
    }
    e2.error && (g2.setTag("fatalErrorType", e2.error.type), g2.setExtra("errorDetails", e2.error.details), (null === (l3 = e2.error.details) || void 0 === l3 ? void 0 : l3.uri) && g2.setTag("serverAddress", e2.error.details.uri), (null === (u3 = e2.error.details) || void 0 === u3 ? void 0 : u3.workerGroup) && g2.setTag("workerGroup", e2.error.details.workerGroup), (null === (d2 = e2.error.details) || void 0 === d2 ? void 0 : d2.geoGroup) && g2.setTag("geoGroup", e2.error.details.geoGroup), (null === (h3 = e2.error.details) || void 0 === h3 ? void 0 : h3.on) && g2.setTag("connectionAttempt", e2.error.details.on), null !== (p2 = e2.error.details) && void 0 !== p2 && p2.bundleUrl && (g2.setTag("bundleUrl", e2.error.details.bundleUrl), g2.setTag("bundleError", e2.error.details.sourceError.type)));
    g2.setTags({ callMode: this._callObjectMode ? Eo() ? "reactNative" : null !== (r3 = this.properties) && void 0 !== r3 && null !== (i3 = r3.dailyConfig) && void 0 !== i3 && null !== (o2 = i3.callMode) && void 0 !== o2 && o2.includes("prebuilt") ? this.properties.dailyConfig.callMode : "custom" : "prebuilt-frame", version: te2.version() });
    var _3 = (null === (a2 = e2.error) || void 0 === a2 ? void 0 : a2.msg) || e2.errorMsg;
    g2.run(function(e3) {
      e3.captureException(new Error(_3));
    });
  } }, { key: "_callMachine", value: function() {
    var e2, t2, n2;
    return null === (e2 = window._daily) || void 0 === e2 || null === (t2 = e2.instances) || void 0 === t2 || null === (n2 = t2[this.callClientId]) || void 0 === n2 ? void 0 : n2.callMachine;
  } }], [{ key: "supportedBrowser", value: function() {
    if (Eo()) return { supported: true, mobile: true, name: "React Native", version: null, supportsScreenShare: true, supportsSfu: true, supportsVideoProcessing: false, supportsAudioProcessing: false };
    var e2 = W.getParser(ko());
    return { supported: !!jo(), mobile: "mobile" === e2.getPlatformType(), name: e2.getBrowserName(), version: e2.getBrowserVersion(), supportsFullscreen: !!To(), supportsScreenShare: !!Mo(), supportsSfu: !!jo(), supportsVideoProcessing: Po(), supportsAudioProcessing: Do() };
  } }, { key: "version", value: function() {
    return "0.70.0";
  } }, { key: "createCallObject", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return e2.layout = "none", new te2(null, e2);
  } }, { key: "wrap", value: function(e2) {
    var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if (ls(), !e2 || !e2.contentWindow || "string" != typeof e2.src) throw new Error("DailyIframe::Wrap needs an iframe-like first argument");
    return t2.layout || (t2.customLayout ? t2.layout = "custom-v1" : t2.layout = "browser"), new te2(e2, t2);
  } }, { key: "createFrame", value: function(e2, t2) {
    var n2, r3;
    ls(), e2 && t2 ? (n2 = e2, r3 = t2) : e2 && e2.append ? (n2 = e2, r3 = {}) : (n2 = document.body, r3 = e2 || {});
    var i3 = r3.iframeStyle;
    i3 || (i3 = n2 === document.body ? { position: "fixed", border: "1px solid black", backgroundColor: "white", width: "375px", height: "450px", right: "1em", bottom: "1em" } : { border: 0, width: "100%", height: "100%" });
    var o2 = document.createElement("iframe");
    window.navigator && window.navigator.userAgent.match(/Chrome\/61\./) ? o2.allow = "microphone, camera" : o2.allow = "microphone; camera; autoplay; display-capture; screen-wake-lock", o2.style.visibility = "hidden", n2.appendChild(o2), o2.style.visibility = null, Object.keys(i3).forEach(function(e3) {
      return o2.style[e3] = i3[e3];
    }), r3.layout || (r3.customLayout ? r3.layout = "custom-v1" : r3.layout = "browser");
    try {
      return new te2(o2, r3);
    } catch (e3) {
      throw n2.removeChild(o2), e3;
    }
  } }, { key: "createTransparentFrame", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    ls();
    var t2 = document.createElement("iframe");
    return t2.allow = "microphone; camera; autoplay", t2.style.cssText = "\n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      border: 0;\n      pointer-events: none;\n    ", document.body.appendChild(t2), e2.layout || (e2.layout = "custom-v1"), te2.wrap(t2, e2);
  } }, { key: "getCallInstance", value: function() {
    var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0;
    return e2 ? Va[e2] : Object.values(Va)[0];
  } }]), te2;
}();
function ts(e2, t2) {
  var n2 = {};
  for (var r2 in e2) if (e2[r2] instanceof MediaStreamTrack) n2[r2] = fo;
  else if ("dailyConfig" === r2) {
    if (e2[r2].modifyLocalSdpHook) {
      var i2 = window._daily.instances[t2].customCallbacks || {};
      i2.modifyLocalSdpHook = e2[r2].modifyLocalSdpHook, window._daily.instances[t2].customCallbacks = i2, delete e2[r2].modifyLocalSdpHook;
    }
    if (e2[r2].modifyRemoteSdpHook) {
      var o2 = window._daily.instances[t2].customCallbacks || {};
      o2.modifyRemoteSdpHook = e2[r2].modifyRemoteSdpHook, window._daily.instances[t2].customCallbacks = o2, delete e2[r2].modifyRemoteSdpHook;
    }
    n2[r2] = e2[r2];
  } else n2[r2] = e2[r2];
  return n2;
}
function ns(e2) {
  var t2 = arguments.length > 2 ? arguments[2] : void 0;
  if (e2 !== Er) {
    var n2 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " only supported after join.");
    throw t2 && (n2 += " ".concat(t2)), console.error(n2), new Error(n2);
  }
}
function rs(e2, t2) {
  return [kr, Er].includes(e2) || t2;
}
function is(e2, t2) {
  var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "This daily-js method", r2 = arguments.length > 3 ? arguments[3] : void 0;
  if (rs(e2, t2)) {
    var i2 = "".concat(n2, " not supported after joining a meeting.");
    throw r2 && (i2 += " ".concat(r2)), console.error(i2), new Error(i2);
  }
}
function os(e2) {
  var t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", n2 = arguments.length > 2 ? arguments[2] : void 0;
  if (!e2) {
    var r2 = "".concat(t2, arguments.length > 3 && void 0 !== arguments[3] && arguments[3] ? " requires preAuth() or startCamera() to initialize call state." : " requires preAuth(), startCamera(), or join() to initialize call state.");
    throw n2 && (r2 += " ".concat(n2)), console.error(r2), new Error(r2);
  }
}
function as(e2) {
  if (e2) {
    var t2 = "A pre-call quality test is in progress. Please try ".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " again once testing has completed. Use stopTestCallQuality() to end it early.");
    throw console.error(t2), new Error(t2);
  }
}
function ss(e2) {
  if (!e2) {
    var t2 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported on custom callObject instances");
    throw console.error(t2), new Error(t2);
  }
}
function cs(e2) {
  if (e2) {
    var t2 = "".concat(arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "This daily-js method", " is only supported as part of Daily's Prebuilt");
    throw console.error(t2), new Error(t2);
  }
}
function ls() {
  if (Eo()) throw new Error("This daily-js method is not currently supported in React Native");
}
function us() {
  if (!Eo()) throw new Error("This daily-js method is only supported in React Native");
}
function ds(e2) {
  if (void 0 === e2) return true;
  var t2;
  if ("string" == typeof e2) t2 = e2;
  else try {
    t2 = JSON.stringify(e2), I(JSON.parse(t2), e2) || console.warn("The userData provided will be modified when serialized.");
  } catch (e3) {
    throw Error("userData must be serializable to JSON: ".concat(e3));
  }
  if (t2.length > 4096) throw Error("userData is too large (".concat(t2.length, " characters). Maximum size suppported is ").concat(4096, "."));
  return true;
}
function hs(e2, t2) {
  for (var n2 = t2.allowAllParticipantsKey, r2 = function(e3) {
    var t3 = ["local"];
    return n2 || t3.push("*"), e3 && !t3.includes(e3);
  }, i2 = function(e3) {
    return !!(void 0 === e3.layer || Number.isInteger(e3.layer) && e3.layer >= 0 || "inherit" === e3.layer);
  }, o2 = function(e3) {
    return !!e3 && (!(e3.video && !i2(e3.video)) && !(e3.screenVideo && !i2(e3.screenVideo)));
  }, a2 = 0, s2 = Object.entries(e2); a2 < s2.length; a2++) {
    var c2 = g(s2[a2], 2), l2 = c2[0], u2 = c2[1];
    if (!r2(l2) || !o2(u2)) return false;
  }
  return true;
}
function ps(e2) {
  return "object" === n(e2) && (!(e2.video && ("object" !== n(e2.video) || !function(e3) {
    var t3 = ["type", "config"];
    if (!e3) return false;
    if ("object" !== n(e3)) return false;
    if (!function(e4) {
      if ("string" != typeof e4) return false;
      if (!Object.values(go).includes(e4)) return console.error("inputSettings video processor type invalid"), false;
      return true;
    }(e3.type)) return false;
    if (e3.config) {
      if ("object" !== n(e3.config)) return false;
      if (!function(e4, t4) {
        var n2 = Object.keys(t4);
        if (0 === n2.length) return true;
        var r3 = "invalid object in inputSettings -> video -> processor -> config";
        switch (e4) {
          case go.BGBLUR:
            return n2.length > 1 || "strength" !== n2[0] ? (console.error(r3), false) : !("number" != typeof t4.strength || t4.strength <= 0 || t4.strength > 1 || isNaN(t4.strength)) || (console.error("".concat(r3, "; expected: {0 < strength <= 1}, got: ").concat(t4.strength)), false);
          case go.BGIMAGE:
            return !(void 0 !== t4.source && !function(e5) {
              if ("default" === e5.source) return e5.type = "default", true;
              if (e5.source instanceof ArrayBuffer) return true;
              if (Z(e5.source)) return e5.type = "url", !!function(e6) {
                var t6 = new URL(e6), n4 = t6.pathname;
                if ("data:" === t6.protocol) try {
                  var r4 = n4.substring(n4.indexOf(":") + 1, n4.indexOf(";")).split("/")[1];
                  return _o.includes(r4);
                } catch (e7) {
                  return console.error("failed to deduce blob content type", e7), false;
                }
                var i3 = n4.split(".").at(-1).toLowerCase().trim();
                return _o.includes(i3);
              }(e5.source) || (console.error("invalid image type; supported types: [".concat(_o.join(", "), "]")), false);
              return t5 = e5.source, n3 = Number(t5), isNaN(n3) || !Number.isInteger(n3) || n3 <= 0 || n3 > yo ? (console.error("invalid image selection; must be an int, > 0, <= ".concat(yo)), false) : (e5.type = "daily-preselect", true);
              var t5, n3;
            }(t4));
          default:
            return true;
        }
      }(e3.type, e3.config)) return false;
    }
    return Object.keys(e3).filter(function(e4) {
      return !t3.includes(e4);
    }).forEach(function(t4) {
      console.warn("invalid key inputSettings -> video -> processor : ".concat(t4)), delete e3[t4];
    }), true;
  }(e2.video.processor))) && !(e2.audio && ("object" !== n(e2.audio) || (r2 = e2.audio.processor, i2 = ["type"], !r2 || "object" !== n(r2) || (Object.keys(r2).filter(function(e3) {
    return !i2.includes(e3);
  }).forEach(function(e3) {
    console.warn("invalid key inputSettings -> audio -> processor : ".concat(e3)), delete r2[e3];
  }), t2 = r2.type, "string" != typeof t2 || !Object.values(vo).includes(t2) && (console.error("inputSettings audio processor type invalid"), 1))))));
  var t2, r2, i2;
}
function fs(e2, t2) {
  var n2, r2 = [];
  e2.video && !Po(null !== (n2 = null == t2 ? void 0 : t2.useLegacyVideoProcessor) && void 0 !== n2 && n2) && (delete e2.video, r2.push("video")), e2.audio && !Do() && (delete e2.audio, r2.push("audio")), r2.length > 0 && console.error("Ignoring settings for browser- or platform-unsupported input processor(s): ".concat(r2.join(", ")));
}
function gs() {
  var e2 = Object.values(go).join(" | "), t2 = Object.values(vo).join(" | ");
  return "inputSettings must be of the form: { video?: { processor: { type: [ ".concat(e2, " ], config?: {} } }, audio?: { processor: {type: [ ").concat(t2, " ] } } }");
}
function vs(e2) {
  var t2 = e2.allowAllParticipantsKey;
  return "receiveSettings must be of the form { [<remote participant id> | ".concat(Rr).concat(t2 ? ' | "'.concat(Br, '"') : "", "]: ") + '{ [video: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]], [screenVideo: [{ layer: [<non-negative integer> | "inherit"] } | "inherit"]] }}}';
}
function ms() {
  return "customIntegrations should be an object of type ".concat(JSON.stringify(Ka), ".");
}
function ys(e2) {
  if (e2 && "object" !== n(e2) || Array.isArray(e2)) return console.error("customTrayButtons should be an Object of the type ".concat(JSON.stringify(Qa), ".")), false;
  if (e2) for (var t2 = 0, r2 = Object.entries(e2); t2 < r2.length; t2++) for (var i2 = g(r2[t2], 1)[0], o2 = 0, a2 = Object.entries(e2[i2]); o2 < a2.length; o2++) {
    var s2 = g(a2[o2], 2), c2 = s2[0], l2 = s2[1];
    if ("iconPath" === c2 && !Z(l2)) return console.error("customTrayButton ".concat(c2, " should be a url.")), false;
    if ("iconPathDarkMode" === c2 && !Z(l2)) return console.error("customTrayButton ".concat(c2, " should be a url.")), false;
    var u2 = Qa.id[c2];
    if (!u2) return console.error("customTrayButton does not support key ".concat(c2)), false;
    if (n(l2) !== u2) return console.error("customTrayButton ".concat(c2, " should be a ").concat(u2, ".")), false;
  }
  return true;
}
function _s(e2) {
  if (!e2 || e2 && "object" !== n(e2) || Array.isArray(e2)) return console.error(ms()), false;
  for (var t2 = function(e3) {
    return "".concat(e3, " should be ").concat(Ka.id[e3]);
  }, r2 = function(e3, t3) {
    return console.error("customIntegration ".concat(e3, ": ").concat(t3));
  }, i2 = 0, o2 = Object.entries(e2); i2 < o2.length; i2++) {
    var a2 = g(o2[i2], 1)[0];
    if (!("label" in e2[a2])) return r2(a2, "label is required"), false;
    if (!("location" in e2[a2])) return r2(a2, "location is required"), false;
    if (!("src" in e2[a2]) && !("srcdoc" in e2[a2])) return r2(a2, "src or srcdoc is required"), false;
    for (var s2 = 0, c2 = Object.entries(e2[a2]); s2 < c2.length; s2++) {
      var l2 = g(c2[s2], 2), u2 = l2[0], d2 = l2[1];
      switch (u2) {
        case "allow":
        case "csp":
        case "name":
        case "referrerPolicy":
        case "sandbox":
          if ("string" != typeof d2) return r2(a2, t2(u2)), false;
          break;
        case "iconURL":
          if (!Z(d2)) return r2(a2, "".concat(u2, " should be a url")), false;
          break;
        case "src":
          if ("srcdoc" in e2[a2]) return r2(a2, "cannot have both src and srcdoc"), false;
          if (!Z(d2)) return r2(a2, 'src "'.concat(d2, '" is not a valid URL')), false;
          break;
        case "srcdoc":
          if ("src" in e2[a2]) return r2(a2, "cannot have both src and srcdoc"), false;
          if ("string" != typeof d2) return r2(a2, t2(u2)), false;
          break;
        case "location":
          if (!["main", "sidebar"].includes(d2)) return r2(a2, t2(u2)), false;
          break;
        case "controlledBy":
          if ("*" !== d2 && "owners" !== d2 && (!Array.isArray(d2) || d2.some(function(e3) {
            return "string" != typeof e3;
          }))) return r2(a2, t2(u2)), false;
          break;
        case "shared":
          if ((!Array.isArray(d2) || d2.some(function(e3) {
            return "string" != typeof e3;
          })) && "owners" !== d2 && "boolean" != typeof d2) return r2(a2, t2(u2)), false;
          break;
        default:
          if (!Ka.id[u2]) return console.error("customIntegration does not support key ".concat(u2)), false;
      }
    }
  }
  return true;
}
function bs(e2, t2) {
  if (void 0 === t2) return false;
  switch (n(t2)) {
    case "string":
      return n(e2) === t2;
    case "object":
      if ("object" !== n(e2)) return false;
      for (var r2 in e2) if (!bs(e2[r2], t2[r2])) return false;
      return true;
    default:
      return false;
  }
}
function ws(e2, t2) {
  var n2 = e2.sessionId, r2 = e2.toEndPoint, i2 = e2.useSipRefer;
  if (!n2 || !r2) throw new Error("".concat(t2, "() requires a sessionId and toEndPoint"));
  if ("string" != typeof n2 || "string" != typeof r2) throw new Error("Invalid paramater: sessionId and toEndPoint must be of type string");
  if (i2 && !r2.startsWith("sip:")) throw new Error('"toEndPoint" must be a "sip" address');
  if (!r2.startsWith("sip:") && !r2.startsWith("+")) throw new Error("toEndPoint: ".concat(r2, ' must starts with either "sip:" or "+"'));
}
function Ss(e2) {
  if ("object" !== n(e2)) throw new Error('RemoteMediaPlayerSettings: must be "object" type');
  if (e2.state && !Object.values(mo).includes(e2.state)) throw new Error("Invalid value for RemoteMediaPlayerSettings.state, valid values are: " + JSON.stringify(mo));
  if (e2.volume) {
    if ("number" != typeof e2.volume) throw new Error('RemoteMediaPlayerSettings.volume: must be "number" type');
    if (e2.volume < 0 || e2.volume > 2) throw new Error("RemoteMediaPlayerSettings.volume: must be between 0.0 - 2.0");
  }
}
function ks(e2, t2, n2) {
  return !("number" != typeof e2 || e2 < t2 || e2 > n2);
}
function Es(e2, t2) {
  return e2 && !t2 && delete e2.data, e2;
}

// node_modules/@daily-co/daily-react/dist/daily-react.esm.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal());
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn2) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn2.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err2) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err2);
      }
      _next(void 0);
    });
  };
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2) return;
  if (typeof o2 === "string") return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor) n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set") return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) arr2[i2] = arr[i2];
  return arr2;
}
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it2 = typeof Symbol !== "undefined" && o2[Symbol.iterator] || o2["@@iterator"];
  if (it2) return (it2 = it2.call(o2)).next.bind(it2);
  if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
    if (it2) o2 = it2;
    var i2 = 0;
    return function() {
      if (i2 >= o2.length) return {
        done: true
      };
      return {
        done: false,
        value: o2[i2++]
      };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var DailyContext = (0, import_react2.createContext)(null);
var useDaily = function useDaily2() {
  var daily = (0, import_react2.useContext)(DailyContext);
  (0, import_react2.useDebugValue)(daily);
  return daily;
};
var DailyEventContext = (0, import_react2.createContext)({
  on: function on2() {
  },
  off: function off() {
  }
});
var priorityCounter = -1;
var getPriorityUnique = function getPriorityUnique2() {
  return priorityCounter--;
};
var uniqueCounter = 1;
var getUnique = function getUnique2() {
  return uniqueCounter++;
};
var useDailyEvent = function useDailyEvent2(ev, callback, INTERNAL_priority) {
  if (INTERNAL_priority === void 0) {
    INTERNAL_priority = false;
  }
  var _useContext = (0, import_react2.useContext)(DailyEventContext), off2 = _useContext.off, on3 = _useContext.on;
  var _useState = (0, import_react2.useState)(false), isBlocked = _useState[0], setIsBlocked = _useState[1];
  var reassignCount = (0, import_react2.useRef)(0);
  var eventId = (0, import_react2.useMemo)(function() {
    return INTERNAL_priority ? getPriorityUnique() : getUnique();
  }, [INTERNAL_priority]);
  (0, import_react2.useEffect)(function() {
    if (!ev || isBlocked) return;
    if (reassignCount.current > 1e5) {
      console.error("useDailyEvent called with potentially non-memoized event callback or due to too many re-renders.\n        Memoize using useCallback to avoid re-render loop or reduce the amount of state transitions the callback depends on.\n        Passed callback for '" + ev + "' event is NOT registered.", callback);
      setIsBlocked(true);
      return;
    }
    reassignCount.current++;
    var timeout = setTimeout(function() {
      reassignCount.current = 0;
    }, 50);
    on3(ev, callback, eventId);
    return function() {
      clearTimeout(timeout);
      off2(ev, eventId);
    };
  }, [callback, ev, eventId, isBlocked, off2, on3]);
  (0, import_react2.useDebugValue)({
    event: ev,
    eventId,
    isBlocked,
    callback
  });
};
var RECOIL_PREFIX = "daily-react-";
var participantPropertyPathsState = Recoil_index_10({
  key: RECOIL_PREFIX + "participant-property-paths",
  "default": []
});
var participantPropertyState = Recoil_index_10({
  key: RECOIL_PREFIX + "participant-property",
  "default": null,
  dangerouslyAllowMutability: true
});
var participantPropertiesState = Recoil_index_11({
  key: RECOIL_PREFIX + "participant-properties",
  get: function get(_ref) {
    var id = _ref.id, properties = _ref.properties;
    return function(_ref2) {
      var get5 = _ref2.get;
      return properties.map(function(path) {
        return get5(participantPropertyState({
          id,
          property: path
        }));
      });
    };
  },
  dangerouslyAllowMutability: true
});
var useParticipantProperty = function useParticipantProperty2(participantId, propertyPaths) {
  var _ref3;
  var properties = Recoil_index_20(Array.isArray(propertyPaths) ? participantPropertiesState({
    id: participantId,
    properties: propertyPaths
  }) : participantPropertyState({
    id: participantId,
    property: propertyPaths
  }));
  (0, import_react2.useDebugValue)(Array.isArray(propertyPaths) ? propertyPaths.reduce(function(o2, path, i2) {
    o2[path] = properties[i2];
    return o2;
  }, {}) : (_ref3 = {}, _ref3[propertyPaths] = properties, _ref3));
  return properties;
};
var useThrottledDailyEvent = function useThrottledDailyEvent2(ev, callback, throttleTimeout, INTERNAL_priority) {
  if (throttleTimeout === void 0) {
    throttleTimeout = 500;
  }
  if (INTERNAL_priority === void 0) {
    INTERNAL_priority = false;
  }
  var _useContext = (0, import_react2.useContext)(DailyEventContext), off2 = _useContext.off, on3 = _useContext.on;
  var eventId = (0, import_react2.useMemo)(function() {
    var _ref;
    if (Array.isArray(ev)) return ev.reduce(function(r2, e2) {
      r2[e2] = INTERNAL_priority ? getPriorityUnique() : getUnique();
      return r2;
    }, {});
    return _ref = {}, _ref[ev] = INTERNAL_priority ? getPriorityUnique() : getUnique(), _ref;
  }, [ev, INTERNAL_priority]);
  var throttledEvents = (0, import_react2.useRef)([]);
  useDailyEvent("call-instance-destroyed", (0, import_react2.useCallback)(function() {
    throttledEvents.current.length = 0;
  }, []));
  var emitEvents = (0, import_react2.useMemo)(function() {
    return (0, import_lodash.default)(function() {
      if (throttledEvents.current.length === 0) return;
      callback(throttledEvents.current);
      throttledEvents.current.length = 0;
    }, throttleTimeout, {
      trailing: true
    });
  }, [callback, throttleTimeout]);
  (0, import_react2.useEffect)(function() {
    if (!ev) return;
    var addEvent = function addEvent2(ev2) {
      throttledEvents.current.push(ev2);
      emitEvents();
    };
    if (Array.isArray(ev)) {
      ev.forEach(function(e2) {
        return on3(e2, addEvent, eventId[e2]);
      });
    } else {
      on3(ev, addEvent, eventId[ev]);
    }
    return function() {
      if (Array.isArray(ev)) {
        ev.forEach(function(e2) {
          return off2(e2, eventId[e2]);
        });
      } else {
        off2(ev, eventId[ev]);
      }
    };
  }, [emitEvents, ev, eventId, off2, on3]);
  (0, import_react2.useDebugValue)({
    event: ev,
    eventId
  });
};
function customDeepEqual(a2, b2) {
  if (a2 === b2) return true;
  if (a2 instanceof MediaStream && b2 instanceof MediaStream) {
    return a2.id === b2.id && a2.active === b2.active && a2.getTracks().length === b2.getTracks().length && a2.getTracks().every(function(track2, idx) {
      return customDeepEqual(track2, b2.getTracks()[idx]);
    });
  }
  if (a2 instanceof MediaStreamTrack && b2 instanceof MediaStreamTrack) {
    return a2.id === b2.id && a2.kind === b2.kind && a2.readyState === b2.readyState;
  }
  if (a2 instanceof Date && b2 instanceof Date) {
    return a2.getTime() === b2.getTime();
  }
  if (a2 instanceof RegExp && b2 instanceof RegExp) {
    return a2.source === b2.source && a2.flags === b2.flags;
  }
  if (a2 instanceof Set && b2 instanceof Set) {
    if (a2.size !== b2.size) {
      return false;
    }
    for (var _iterator = _createForOfIteratorHelperLoose(a2.values()), _step; !(_step = _iterator()).done; ) {
      var value = _step.value;
      if (!b2.has(value)) {
        return false;
      }
    }
    return true;
  }
  if (a2 instanceof Map && b2 instanceof Map) {
    if (a2.size !== b2.size) {
      return false;
    }
    for (var _iterator2 = _createForOfIteratorHelperLoose(a2.entries()), _step2; !(_step2 = _iterator2()).done; ) {
      var _step2$value = _step2.value, key = _step2$value[0], _value = _step2$value[1];
      if (!b2.has(key)) {
        return false;
      }
      if (!customDeepEqual(_value, b2.get(key))) {
        return false;
      }
    }
    return true;
  }
  if (typeof a2 !== "object" || a2 === null || typeof b2 !== "object" || b2 === null) {
    return false;
  }
  var keysA = Object.keys(a2);
  var keysB = Object.keys(b2);
  if (keysA.length !== keysB.length) return false;
  for (var _i2 = 0, _keysA = keysA; _i2 < _keysA.length; _i2++) {
    var _key = _keysA[_i2];
    if (
      // If key exists in a, but not in b -> not equal
      !(_key in b2) || // Both keys exist in both object -> run nested equality check
      !customDeepEqual(a2[_key], b2[_key])
    ) return false;
  }
  return true;
}
function equalSelector(options) {
  var inner = Recoil_index_9({
    key: options.key + "_inner",
    get: options.get
  });
  var prior;
  return Recoil_index_9({
    key: options.key,
    get: function get5(_ref) {
      var _get = _ref.get;
      var latest = _get(inner);
      if (prior != null && options.equals(latest, prior)) {
        return prior;
      }
      prior = latest;
      return latest;
    }
  });
}
function equalSelectorFamily(options) {
  var inner = Recoil_index_11({
    key: options.key + "_inner",
    get: options.get
  });
  var priorValues = /* @__PURE__ */ new Map();
  return Recoil_index_11(_extends({}, options, {
    key: options.key,
    get: function get5(param) {
      return function(_ref2) {
        var get6 = _ref2.get;
        var latest = get6(inner(param));
        var prior = priorValues.get(param);
        if (prior != null && options.equals(latest, prior)) {
          return prior;
        }
        priorValues.set(param, latest);
        return latest;
      };
    }
  }));
}
var getPaths = function getPaths2(o2, currentPath, visited) {
  if (currentPath === void 0) {
    currentPath = "";
  }
  if (visited === void 0) {
    visited = /* @__PURE__ */ new Set();
  }
  if (typeof o2 !== "object" || o2 === null || visited.has(o2)) {
    return [currentPath];
  }
  visited.add(o2);
  var paths = [];
  for (var key in o2) {
    if (Object.prototype.hasOwnProperty.call(o2, key)) {
      var newPath = currentPath ? currentPath + "." + key : key;
      paths.push.apply(paths, [newPath].concat(getPaths2(o2[key], newPath, visited)));
    }
  }
  visited["delete"](o2);
  return paths;
};
var getParticipantPaths = function getParticipantPaths2(p2) {
  return getPaths(p2);
};
var resolvePath = function resolvePath2(participant, path) {
  return String(path).split(".").filter(function(key) {
    return key.length;
  }).reduce(function(p2, key) {
    return p2 && p2[key];
  }, participant);
};
var resolveParticipantPaths = function resolveParticipantPaths2(participant, paths) {
  return paths.map(function(path) {
    return resolvePath(participant, path);
  });
};
var activeIdState = Recoil_index_8({
  key: RECOIL_PREFIX + "active-id",
  "default": null
});
var localIdState = Recoil_index_8({
  key: RECOIL_PREFIX + "local-id",
  "default": ""
});
var localJoinDateState = Recoil_index_8({
  key: RECOIL_PREFIX + "local-joined-date",
  "default": null
});
var participantIdsState = Recoil_index_8({
  key: RECOIL_PREFIX + "participant-ids",
  "default": []
});
var participantState = Recoil_index_10({
  key: RECOIL_PREFIX + "participant-state",
  "default": null,
  dangerouslyAllowMutability: true
});
var waitingParticipantsState = Recoil_index_8({
  key: RECOIL_PREFIX + "waiting-participants",
  "default": []
});
var waitingParticipantState = Recoil_index_10({
  key: RECOIL_PREFIX + "waiting-participant",
  "default": {
    awaitingAccess: {
      level: "full"
    },
    id: "",
    name: ""
  }
});
var allWaitingParticipantsSelector = equalSelector({
  key: RECOIL_PREFIX + "waitingParticipantsSelector",
  equals: customDeepEqual,
  get: function get2(_ref2) {
    var _get2 = _ref2.get;
    var ids = _get2(waitingParticipantsState);
    return ids.map(function(id) {
      return _get2(waitingParticipantState(id));
    });
  }
});
var DailyParticipants = function DailyParticipants2(_ref3) {
  var children = _ref3.children;
  var daily = useDaily();
  var _useState = (0, import_react2.useState)(false), initialized = _useState[0], setInitialized = _useState[1];
  var initParticipants = Recoil_index_31(function(_ref4) {
    var transact_UNSTABLE = _ref4.transact_UNSTABLE;
    return function(participants) {
      transact_UNSTABLE(function(_ref5) {
        var set = _ref5.set;
        set(localIdState, participants.local.session_id);
        var participantsArray = Object.values(participants);
        var ids = participantsArray.map(function(p2) {
          return p2.session_id;
        });
        set(participantIdsState, ids);
        participantsArray.forEach(function(p2) {
          set(participantState(p2.session_id), p2);
          var paths = getParticipantPaths(p2);
          set(participantPropertyPathsState(p2.session_id), paths);
          paths.forEach(function(property) {
            var _resolveParticipantPa = resolveParticipantPaths(p2, [property]), value = _resolveParticipantPa[0];
            set(participantPropertyState({
              id: p2.session_id,
              property
            }), value);
          });
        });
        setInitialized(true);
      });
    };
  }, []);
  (0, import_react2.useEffect)(function() {
    if (!daily || initialized) return;
    var interval = setInterval(function() {
      var participants = daily.participants();
      if (!("local" in participants)) return;
      initParticipants(participants);
      clearInterval(interval);
    }, 100);
    return function() {
      clearInterval(interval);
    };
  }, [daily, initialized, initParticipants]);
  var handleInitEvent = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    var participants = daily == null ? void 0 : daily.participants();
    if (!participants.local) return;
    initParticipants(participants);
  }, [daily, initParticipants]);
  useDailyEvent("started-camera", handleInitEvent, true);
  useDailyEvent("access-state-updated", handleInitEvent, true);
  useDailyEvent("joining-meeting", Recoil_index_31(function(_ref6) {
    var set = _ref6.set;
    return function() {
      set(localJoinDateState, /* @__PURE__ */ new Date());
      handleInitEvent();
    };
  }, [handleInitEvent]), true);
  useDailyEvent("joined-meeting", (0, import_react2.useCallback)(function(ev) {
    initParticipants(ev.participants);
  }, [initParticipants]), true);
  var handleCleanup = Recoil_index_31(function(_ref7) {
    var reset = _ref7.reset, snapshot = _ref7.snapshot;
    return _asyncToGenerator(function* () {
      reset(localIdState);
      reset(activeIdState);
      var ids = yield snapshot.getPromise(participantIdsState);
      if (Array.isArray(ids)) ids.forEach(function(id) {
        return reset(participantState(id));
      });
      reset(participantIdsState);
    });
  }, []);
  useDailyEvent("call-instance-destroyed", handleCleanup, true);
  useDailyEvent("left-meeting", handleCleanup, true);
  useThrottledDailyEvent(["active-speaker-change", "participant-joined", "participant-updated", "participant-left"], Recoil_index_31(function(_ref9) {
    var transact_UNSTABLE = _ref9.transact_UNSTABLE;
    return function(evts) {
      if (!evts.length) return;
      transact_UNSTABLE(function(_ref10) {
        var get5 = _ref10.get, reset = _ref10.reset, set = _ref10.set;
        evts.forEach(function(ev) {
          switch (ev.action) {
            case "active-speaker-change": {
              set(activeIdState, ev.activeSpeaker.peerId);
              set(participantState(ev.activeSpeaker.peerId), function(prev) {
                if (!prev) return null;
                return _extends({}, prev, {
                  last_active: /* @__PURE__ */ new Date()
                });
              });
              break;
            }
            case "participant-joined": {
              set(participantIdsState, function(prevIds) {
                return prevIds.includes(ev.participant.session_id) ? prevIds : [].concat(prevIds, [ev.participant.session_id]);
              });
              set(participantState(ev.participant.session_id), ev.participant);
              var paths = getParticipantPaths(ev.participant);
              set(participantPropertyPathsState(ev.participant.session_id), paths);
              paths.forEach(function(property) {
                var _resolveParticipantPa2 = resolveParticipantPaths(ev.participant, [property]), value = _resolveParticipantPa2[0];
                set(participantPropertyState({
                  id: ev.participant.session_id,
                  property
                }), value);
              });
              break;
            }
            case "participant-updated": {
              set(participantState(ev.participant.session_id), function(prev) {
                return _extends({}, prev, ev.participant);
              });
              if (ev.participant.local) {
                set(localIdState, function(prevId) {
                  return prevId !== ev.participant.session_id ? ev.participant.session_id : prevId;
                });
              }
              var _paths = getParticipantPaths(ev.participant);
              var oldPaths = get5(participantPropertyPathsState(ev.participant.session_id));
              set(participantPropertyPathsState(ev.participant.session_id), function(prev) {
                return customDeepEqual(prev, _paths) ? prev : _paths;
              });
              oldPaths.filter(function(p2) {
                return !_paths.includes(p2);
              }).forEach(function(property) {
                reset(participantPropertyState({
                  id: ev.participant.session_id,
                  property
                }));
              });
              _paths.forEach(function(property) {
                var _resolveParticipantPa3 = resolveParticipantPaths(ev.participant, [property]), value = _resolveParticipantPa3[0];
                set(participantPropertyState({
                  id: ev.participant.session_id,
                  property
                }), function(prev) {
                  return customDeepEqual(prev, value) ? prev : value;
                });
              });
              break;
            }
            case "participant-left": {
              set(participantIdsState, function(prevIds) {
                return prevIds.includes(ev.participant.session_id) ? [].concat(prevIds.filter(function(id) {
                  return id !== ev.participant.session_id;
                })) : prevIds;
              });
              reset(participantState(ev.participant.session_id));
              var _oldPaths = get5(participantPropertyPathsState(ev.participant.session_id));
              _oldPaths.forEach(function(property) {
                reset(participantPropertyState({
                  id: ev.participant.session_id,
                  property
                }));
              });
              reset(participantPropertyPathsState(ev.participant.session_id));
              break;
            }
          }
        });
      });
    };
  }, []), 100, true);
  useThrottledDailyEvent(["waiting-participant-added", "waiting-participant-updated", "waiting-participant-removed"], Recoil_index_31(function(_ref11) {
    var transact_UNSTABLE = _ref11.transact_UNSTABLE;
    return function(evts) {
      transact_UNSTABLE(function(_ref12) {
        var reset = _ref12.reset, set = _ref12.set;
        evts.forEach(function(ev) {
          switch (ev.action) {
            case "waiting-participant-added":
              set(waitingParticipantsState, function(wps) {
                if (!wps.includes(ev.participant.id)) {
                  return [].concat(wps, [ev.participant.id]);
                }
                return wps;
              });
              set(waitingParticipantState(ev.participant.id), ev.participant);
              break;
            case "waiting-participant-updated":
              set(waitingParticipantState(ev.participant.id), ev.participant);
              break;
            case "waiting-participant-removed":
              set(waitingParticipantsState, function(wps) {
                return wps.filter(function(wp) {
                  return wp !== ev.participant.id;
                });
              });
              reset(waitingParticipantState(ev.participant.id));
              break;
          }
        });
      });
    };
  }, []), 100, true);
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var useLocalSessionId = function useLocalSessionId2() {
  var localId = Recoil_index_20(localIdState);
  (0, import_react2.useDebugValue)(localId);
  return localId;
};
var noopFilter = function noopFilter2() {
  return true;
};
var useActiveSpeakerId = function useActiveSpeakerId2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$filter = _ref.filter, filter = _ref$filter === void 0 ? noopFilter : _ref$filter, _ref$ignoreLocal = _ref.ignoreLocal, ignoreLocal = _ref$ignoreLocal === void 0 ? false : _ref$ignoreLocal;
  var localSessionId = useLocalSessionId();
  var recentActiveId = Recoil_index_20(activeIdState);
  var isIgnoredLocalId = ignoreLocal && recentActiveId === localSessionId;
  var isFilteredOut = !(filter != null && filter(recentActiveId));
  var isRecentIdRelevant = !isIgnoredLocalId && !isFilteredOut;
  var _useState = (0, import_react2.useState)(isRecentIdRelevant ? recentActiveId : null), activeId = _useState[0], setActiveId = _useState[1];
  (0, import_react2.useEffect)(function() {
    if (isIgnoredLocalId || isFilteredOut) return;
    setActiveId(recentActiveId);
  }, [isFilteredOut, isIgnoredLocalId, recentActiveId]);
  (0, import_react2.useDebugValue)(activeId);
  return activeId;
};
var isTrackOff = function isTrackOff2(trackState) {
  return ["blocked", "off"].includes(trackState);
};
var participantIdsFilteredAndSortedState = equalSelectorFamily({
  key: RECOIL_PREFIX + "participant-ids-filtered-sorted",
  equals: customDeepEqual,
  get: function get3(_ref) {
    var filter = _ref.filter, sort = _ref.sort;
    return function(_ref2) {
      var get5 = _ref2.get;
      var ids = get5(participantIdsState);
      return ids.filter(function(id) {
        switch (filter) {
          case "local":
          case "owner":
          case "record": {
            return get5(participantPropertyState({
              id,
              property: filter
            }));
          }
          case "remote": {
            return !get5(participantPropertyState({
              id,
              property: "local"
            }));
          }
          case "screen": {
            var _get = get5(participantPropertiesState({
              id,
              properties: ["tracks.screenAudio.state", "tracks.screenVideo.state"]
            })), screenAudioState = _get[0], screenVideoState = _get[1];
            return !isTrackOff(screenAudioState) || !isTrackOff(screenVideoState);
          }
          default:
            return true;
        }
      }).sort(function(idA, idB) {
        switch (sort) {
          case "joined_at":
          case "session_id":
          case "user_id":
          case "user_name": {
            var _get2 = get5(participantPropertiesState({
              id: idA,
              properties: [sort]
            })), aSort = _get2[0];
            var _get3 = get5(participantPropertiesState({
              id: idB,
              properties: [sort]
            })), bSort = _get3[0];
            if (aSort !== void 0 || bSort !== void 0) {
              if (aSort === void 0) return -1;
              if (bSort === void 0) return 1;
              if (aSort > bSort) return 1;
              if (aSort < bSort) return -1;
            }
            return 0;
          }
          default:
            return 0;
        }
      });
    };
  }
});
var useParticipantIds = function useParticipantIds2(_temp) {
  var _ref3 = _temp === void 0 ? {} : _temp, filter = _ref3.filter, onActiveSpeakerChange = _ref3.onActiveSpeakerChange, onParticipantJoined = _ref3.onParticipantJoined, onParticipantLeft = _ref3.onParticipantLeft, onParticipantUpdated = _ref3.onParticipantUpdated, sort = _ref3.sort;
  var preFilteredSortedIds = Recoil_index_20(participantIdsFilteredAndSortedState({
    filter: typeof filter === "string" ? filter : null,
    sort: typeof sort === "string" ? sort : null
  }));
  var shouldUseCustomIds = typeof filter === "function" || typeof sort === "function";
  var getCustomFilteredIds = (0, import_react2.useCallback)(function(snapshot) {
    if (
      // Ignore if both filter and sort are not functions.
      typeof filter !== "function" && typeof sort !== "function"
    ) return [];
    var participants = preFilteredSortedIds.map(function(id) {
      return snapshot.getLoadable(participantState(id)).contents;
    });
    return participants.filter(Boolean).filter(typeof filter === "function" ? filter : function() {
      return true;
    }).sort(typeof sort === "function" ? sort : function() {
      return 0;
    }).map(function(p2) {
      return p2.session_id;
    }).filter(Boolean);
  }, [filter, preFilteredSortedIds, sort]);
  var _useState = (0, import_react2.useState)([]), customIds = _useState[0], setCustomIds = _useState[1];
  var maybeUpdateCustomIds = Recoil_index_31(function(_ref4) {
    var snapshot = _ref4.snapshot;
    return function() {
      if (!shouldUseCustomIds) return;
      var newIds = getCustomFilteredIds(snapshot);
      if (customDeepEqual(newIds, customIds)) return;
      setCustomIds(newIds);
    };
  }, [customIds, getCustomFilteredIds, shouldUseCustomIds]);
  (0, import_react2.useEffect)(function() {
    maybeUpdateCustomIds();
  }, [maybeUpdateCustomIds]);
  useThrottledDailyEvent(["participant-joined", "participant-updated", "active-speaker-change", "participant-left"], (0, import_react2.useCallback)(function(evts) {
    if (!evts.length) return;
    evts.forEach(function(ev) {
      switch (ev.action) {
        case "participant-joined":
          onParticipantJoined == null ? void 0 : onParticipantJoined(ev);
          break;
        case "participant-updated":
          onParticipantUpdated == null ? void 0 : onParticipantUpdated(ev);
          break;
        case "active-speaker-change":
          onActiveSpeakerChange == null ? void 0 : onActiveSpeakerChange(ev);
          break;
        case "participant-left":
          onParticipantLeft == null ? void 0 : onParticipantLeft(ev);
          break;
      }
    });
    maybeUpdateCustomIds();
  }, [maybeUpdateCustomIds, onActiveSpeakerChange, onParticipantJoined, onParticipantLeft, onParticipantUpdated]));
  var result = typeof filter === "function" || typeof sort === "function" ? customIds : preFilteredSortedIds;
  (0, import_react2.useDebugValue)(result);
  return result;
};
var screenSharesState = equalSelector({
  key: RECOIL_PREFIX + "screen-shares",
  equals: customDeepEqual,
  get: function get4(_ref) {
    var _get = _ref.get;
    var screenIds = _get(participantIdsFilteredAndSortedState({
      filter: "screen",
      sort: null
    }));
    return screenIds.map(function(id) {
      return {
        local: _get(participantPropertyState({
          id,
          property: "local"
        })),
        screenAudio: _get(participantPropertyState({
          id,
          property: "tracks.screenAudio"
        })),
        screenVideo: _get(participantPropertyState({
          id,
          property: "tracks.screenVideo"
        })),
        screenId: id + "-screen",
        session_id: id
      };
    });
  }
});
var useScreenShare = function useScreenShare2(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp, onError = _ref2.onError, onLocalScreenShareStarted = _ref2.onLocalScreenShareStarted, onLocalScreenShareStopped = _ref2.onLocalScreenShareStopped;
  var daily = useDaily();
  var startScreenShare = (0, import_react2.useCallback)(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    daily == null ? void 0 : daily.startScreenShare.apply(daily, args);
  }, [daily]);
  var stopScreenShare = (0, import_react2.useCallback)(function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    daily == null ? void 0 : daily.stopScreenShare.apply(daily, args);
  }, [daily]);
  useDailyEvent("local-screen-share-started", (0, import_react2.useCallback)(function() {
    return onLocalScreenShareStarted == null ? void 0 : onLocalScreenShareStarted();
  }, [onLocalScreenShareStarted]));
  useDailyEvent("local-screen-share-stopped", (0, import_react2.useCallback)(function() {
    return onLocalScreenShareStopped == null ? void 0 : onLocalScreenShareStopped();
  }, [onLocalScreenShareStopped]));
  useDailyEvent("nonfatal-error", (0, import_react2.useCallback)(function(ev) {
    if (ev.type !== "screen-share-error") return;
    onError == null ? void 0 : onError(ev);
  }, [onError]));
  var screens = Recoil_index_20(screenSharesState);
  var result = {
    isSharingScreen: screens.some(function(s2) {
      return s2.local;
    }),
    screens,
    startScreenShare,
    stopScreenShare
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useMediaTrack = function useMediaTrack2(participantId, type) {
  if (type === void 0) {
    type = "video";
  }
  var trackState = useParticipantProperty(participantId, "tracks." + type);
  var result = trackState ? _extends({}, trackState, {
    isOff: isTrackOff(trackState.state)
  }) : {
    isOff: true,
    persistentTrack: void 0,
    state: "off",
    subscribed: false
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
function useMergedRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return (0, import_react2.useCallback)(
    function(element) {
      for (var i2 = 0; i2 < refs.length; i2++) {
        var ref = refs[i2];
        if (typeof ref === "function") ref(element);
        else if (ref && typeof ref === "object") ref.current = element;
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
}
var _excluded = ["onPlayFailed", "sessionId", "type"];
var DailyAudioTrack = (0, import_react2.memo)((0, import_react2.forwardRef)(function(_ref, ref) {
  var onPlayFailed = _ref.onPlayFailed, sessionId = _ref.sessionId, _ref$type = _ref.type, type = _ref$type === void 0 ? "audio" : _ref$type, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  var audioEl = (0, import_react2.useRef)(null);
  var audio = useMediaTrack(sessionId, type);
  var audioRef = useMergedRef(audioEl, ref);
  var subscribedState = audio == null ? void 0 : audio.subscribed;
  (0, import_react2.useEffect)(function() {
    var audioTag = audioEl.current;
    if (!audioTag || !(audio != null && audio.persistentTrack)) return;
    var playTimeout;
    var handleCanPlay = function handleCanPlay2() {
      audioTag.play()["catch"](function(e2) {
        onPlayFailed == null ? void 0 : onPlayFailed({
          sessionId,
          target: audioTag,
          type,
          message: e2.message,
          name: e2.name
        });
      });
    };
    var handlePlay = function handlePlay2() {
      clearTimeout(playTimeout);
    };
    audioTag.addEventListener("canplay", handleCanPlay);
    audioTag.addEventListener("play", handlePlay);
    audioTag.srcObject = new MediaStream([audio == null ? void 0 : audio.persistentTrack]);
    return function() {
      audioTag == null ? void 0 : audioTag.removeEventListener("canplay", handleCanPlay);
      audioTag == null ? void 0 : audioTag.removeEventListener("play", handlePlay);
    };
  }, [audio == null ? void 0 : audio.persistentTrack, onPlayFailed, sessionId, type]);
  return import_react2.default.createElement("audio", Object.assign({
    autoPlay: true,
    ref: audioRef
  }, props, {
    "data-session-id": sessionId,
    "data-audio-type": type,
    "data-subscribed": subscribedState
  }));
}));
DailyAudioTrack.displayName = "DailyAudioTrack";
var DailyAudio = (0, import_react2.memo)((0, import_react2.forwardRef)(function(_ref, ref) {
  var _ref$autoSubscribeAct = _ref.autoSubscribeActiveSpeaker, autoSubscribeActiveSpeaker = _ref$autoSubscribeAct === void 0 ? false : _ref$autoSubscribeAct, _ref$maxSpeakers = _ref.maxSpeakers, maxSpeakers = _ref$maxSpeakers === void 0 ? 5 : _ref$maxSpeakers, onPlayFailed = _ref.onPlayFailed, _ref$playLocalScreenA = _ref.playLocalScreenAudio, playLocalScreenAudio = _ref$playLocalScreenA === void 0 ? false : _ref$playLocalScreenA;
  var daily = useDaily();
  var _useState = (0, import_react2.useState)(new Array(maxSpeakers).fill("")), speakers = _useState[0], setSpeakers = _useState[1];
  var _useScreenShare = useScreenShare(), screens = _useScreenShare.screens;
  var localSessionId = useLocalSessionId();
  var activeSpeakerId = useActiveSpeakerId({
    ignoreLocal: true
  });
  var containerRef = (0, import_react2.useRef)(null);
  (0, import_react2.useImperativeHandle)(ref, function() {
    return {
      getActiveSpeakerAudio: function getActiveSpeakerAudio() {
        var _containerRef$current, _containerRef$current2;
        return (_containerRef$current = (_containerRef$current2 = containerRef.current) == null ? void 0 : _containerRef$current2.querySelector('audio[data-session-id="' + activeSpeakerId + '"][data-audio-type="audio"]')) != null ? _containerRef$current : null;
      },
      getAllAudio: function getAllAudio() {
        var _containerRef$current3, _containerRef$current4;
        return Array.from((_containerRef$current3 = (_containerRef$current4 = containerRef.current) == null ? void 0 : _containerRef$current4.querySelectorAll("audio")) != null ? _containerRef$current3 : []);
      },
      getAudioBySessionId: function getAudioBySessionId(id) {
        var _containerRef$current5, _containerRef$current6;
        return (_containerRef$current5 = (_containerRef$current6 = containerRef.current) == null ? void 0 : _containerRef$current6.querySelector('audio[data-session-id="' + id + '"][data-audio-type="audio"]')) != null ? _containerRef$current5 : null;
      },
      getRmpAudio: function getRmpAudio() {
        var _containerRef$current7, _containerRef$current8;
        return Array.from((_containerRef$current7 = (_containerRef$current8 = containerRef.current) == null ? void 0 : _containerRef$current8.querySelectorAll('audio[data-audio-type="rmpAudio"]')) != null ? _containerRef$current7 : []);
      },
      getScreenAudio: function getScreenAudio() {
        var _containerRef$current9, _containerRef$current10;
        return Array.from((_containerRef$current9 = (_containerRef$current10 = containerRef.current) == null ? void 0 : _containerRef$current10.querySelectorAll('audio[data-audio-type="screenAudio"]')) != null ? _containerRef$current9 : []);
      },
      getRmpAudioBySessionId: function getRmpAudioBySessionId(id) {
        var _containerRef$current11, _containerRef$current12;
        return (_containerRef$current11 = (_containerRef$current12 = containerRef.current) == null ? void 0 : _containerRef$current12.querySelector('audio[data-session-id="' + id + '"][data-audio-type="rmpAudio"]')) != null ? _containerRef$current11 : null;
      },
      getScreenAudioBySessionId: function getScreenAudioBySessionId(id) {
        var _containerRef$current13, _containerRef$current14;
        return (_containerRef$current13 = (_containerRef$current14 = containerRef.current) == null ? void 0 : _containerRef$current14.querySelector('audio[data-session-id="' + id + '"][data-audio-type="screenAudio"]')) != null ? _containerRef$current13 : null;
      }
    };
  }, [activeSpeakerId]);
  var assignSpeaker = Recoil_index_31(function(_ref2) {
    var snapshot = _ref2.snapshot;
    return function() {
      var _ref3 = _asyncToGenerator(function* (sessionId) {
        var _daily$participants;
        var subscribedParticipants = Object.values((_daily$participants = daily == null ? void 0 : daily.participants()) != null ? _daily$participants : {}).filter(function(p2) {
          return !p2.local && Boolean(p2.tracks.audio.subscribed);
        });
        var isSubscribed = function isSubscribed2(id) {
          return subscribedParticipants.some(function(p2) {
            return p2.session_id === id;
          });
        };
        if (!isSubscribed(sessionId)) {
          if (daily && !daily.isDestroyed() && autoSubscribeActiveSpeaker && !daily.subscribeToTracksAutomatically()) {
            daily.updateParticipant(sessionId, {
              setSubscribedTracks: {
                audio: true
              }
            });
          } else {
            return;
          }
        }
        setSpeakers(function(prevSpeakers) {
          var _speakerObjects$;
          if (prevSpeakers.includes(sessionId)) return prevSpeakers;
          var freeSlotCheck = function freeSlotCheck2(id) {
            return !id || !isSubscribed(id);
          };
          if (prevSpeakers.some(freeSlotCheck)) {
            var idx = prevSpeakers.findIndex(freeSlotCheck);
            prevSpeakers[idx] = sessionId;
            return [].concat(prevSpeakers);
          }
          var mutedIdx = prevSpeakers.findIndex(function(id) {
            return subscribedParticipants.some(function(p2) {
              return p2.session_id === id && isTrackOff(p2.tracks.audio.state);
            });
          });
          if (mutedIdx >= 0) {
            prevSpeakers[mutedIdx] = sessionId;
            return [].concat(prevSpeakers);
          }
          var speakerObjects = subscribedParticipants.filter(function(p2) {
            return (
              // Only consider participants currently assigned to speaker slots
              prevSpeakers.includes(p2.session_id) && // Don't replace current active participant, to avoid audio drop-outs
              p2.session_id !== activeSpeakerId
            );
          }).sort(function(a2, b2) {
            var _snapshot$getLoadable, _snapshot$getLoadable2;
            var lastActiveA = (_snapshot$getLoadable = snapshot.getLoadable(participantPropertyState({
              id: a2.session_id,
              property: "last_active"
            })).contents) != null ? _snapshot$getLoadable : /* @__PURE__ */ new Date("1970-01-01");
            var lastActiveB = (_snapshot$getLoadable2 = snapshot.getLoadable(participantPropertyState({
              id: b2.session_id,
              property: "last_active"
            })).contents) != null ? _snapshot$getLoadable2 : /* @__PURE__ */ new Date("1970-01-01");
            if (lastActiveA > lastActiveB) return 1;
            if (lastActiveA < lastActiveB) return -1;
            return 0;
          });
          if (!speakerObjects.length) {
            var _replaceIdx = prevSpeakers.findIndex(function(id) {
              return id !== activeSpeakerId;
            });
            prevSpeakers[_replaceIdx] = sessionId;
            return [].concat(prevSpeakers);
          }
          var replaceIdx = prevSpeakers.indexOf((_speakerObjects$ = speakerObjects[0]) == null ? void 0 : _speakerObjects$.session_id);
          prevSpeakers[replaceIdx] = sessionId;
          return [].concat(prevSpeakers);
        });
      });
      return function(_x) {
        return _ref3.apply(this, arguments);
      };
    }();
  }, [activeSpeakerId, autoSubscribeActiveSpeaker, daily]);
  var removeSpeaker = (0, import_react2.useCallback)(function(sessionId) {
    setSpeakers(function(prevSpeakers) {
      if (!prevSpeakers.includes(sessionId)) return prevSpeakers;
      var newSpeakers = [].concat(prevSpeakers);
      var idx = newSpeakers.indexOf(sessionId);
      newSpeakers[idx] = "";
      return newSpeakers;
    });
  }, []);
  useThrottledDailyEvent(["active-speaker-change", "track-started", "participant-left"], (0, import_react2.useCallback)(function(evts) {
    evts.forEach(function(ev) {
      switch (ev.action) {
        case "active-speaker-change":
          if (ev.activeSpeaker.peerId === localSessionId) return;
          assignSpeaker(ev.activeSpeaker.peerId);
          break;
        case "track-started":
          if (ev.track.kind === "audio" && ev.participant && !ev.participant.local) {
            assignSpeaker(ev.participant.session_id);
          }
          break;
        case "participant-left":
          removeSpeaker(ev.participant.session_id);
          break;
      }
    });
  }, [assignSpeaker, localSessionId, removeSpeaker]), 200);
  var rmpAudioIds = useParticipantIds({
    filter: (0, import_react2.useCallback)(function(p2) {
      var _p$tracks;
      return Boolean(p2 == null ? void 0 : (_p$tracks = p2.tracks) == null ? void 0 : _p$tracks.rmpAudio);
    }, [])
  });
  return import_react2.default.createElement("div", {
    ref: containerRef
  }, speakers.map(function(sessionId, idx) {
    return import_react2.default.createElement(DailyAudioTrack, {
      key: "speaker-slot-" + idx,
      onPlayFailed,
      sessionId,
      type: "audio"
    });
  }), screens.filter(function(screen) {
    return playLocalScreenAudio ? true : !screen.local;
  }).map(function(screen) {
    return import_react2.default.createElement(DailyAudioTrack, {
      key: screen.screenId,
      onPlayFailed,
      sessionId: screen.session_id,
      type: "screenAudio"
    });
  }), rmpAudioIds.map(function(id) {
    return import_react2.default.createElement(DailyAudioTrack, {
      key: id + "-rmp",
      onPlayFailed,
      sessionId: id,
      type: "rmpAudio"
    });
  }));
}));
DailyAudio.displayName = "DailyAudio";
var _excluded$1 = ["automirror", "fit", "mirror", "onResize", "playableStyle", "sessionId", "style", "type"];
var DailyVideo = (0, import_react2.forwardRef)(function DailyVideo2(_ref, ref) {
  var automirror = _ref.automirror, _ref$fit = _ref.fit, fit = _ref$fit === void 0 ? "contain" : _ref$fit, mirror = _ref.mirror, onResize = _ref.onResize, _ref$playableStyle = _ref.playableStyle, playableStyle = _ref$playableStyle === void 0 ? {} : _ref$playableStyle, sessionId = _ref.sessionId, _ref$style = _ref.style, style = _ref$style === void 0 ? {} : _ref$style, _ref$type = _ref.type, type = _ref$type === void 0 ? "video" : _ref$type, props = _objectWithoutPropertiesLoose(_ref, _excluded$1);
  var localSessionId = useLocalSessionId();
  var isLocal = localSessionId === sessionId;
  var isScreen = type === "screenVideo";
  var isLocalCam = isLocal && !isScreen;
  var videoEl = (0, import_react2.useRef)(null);
  var videoRef = useMergedRef(videoEl, ref);
  var videoState = useMediaTrack(sessionId, type);
  var videoTrack = videoState.persistentTrack;
  var isPlayable = isLocalCam || isScreen || !videoState.isOff;
  var trackState = useParticipantProperty(sessionId, "tracks." + type);
  var subscribedState = trackState == null ? void 0 : trackState.subscribed;
  var isMirrored = (0, import_react2.useMemo)(function() {
    if (typeof mirror === "boolean") return mirror;
    if (!automirror) return false;
    if (!videoTrack) return isLocalCam;
    var videoTrackSettings = videoTrack.getSettings();
    var isUsersFrontCamera = "facingMode" in videoTrackSettings ? isLocalCam && videoTrackSettings.facingMode === "user" : isLocalCam;
    return isUsersFrontCamera;
  }, [automirror, isLocalCam, mirror, videoTrack]);
  (0, import_react2.useEffect)(function setupVideoEvents() {
    var video = videoEl.current;
    if (!video) return;
    var playVideo = function playVideo2() {
      var promise = video.play();
      if (promise !== void 0) {
        promise.then(function() {
          video.controls = false;
        })["catch"](function(error) {
          video.controls = true;
          console.warn("Failed to play video", error);
        });
      }
    };
    var handleCanPlay = function handleCanPlay2() {
      if (!video.paused) return;
      playVideo();
    };
    var handleEnterPIP = function handleEnterPIP2() {
      video.style.transform = "scale(1)";
    };
    var handleLeavePIP = function handleLeavePIP2() {
      video.style.transform = "";
      setTimeout(function() {
        if (video.paused) playVideo();
      }, 100);
    };
    var handleVisibilityChange = function handleVisibilityChange2() {
      if (document.visibilityState === "hidden") return;
      if (!video.paused) return;
      playVideo();
    };
    video.addEventListener("canplay", handleCanPlay);
    video.addEventListener("enterpictureinpicture", handleEnterPIP);
    video.addEventListener("leavepictureinpicture", handleLeavePIP);
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return function() {
      video.removeEventListener("canplay", handleCanPlay);
      video.removeEventListener("enterpictureinpicture", handleEnterPIP);
      video.removeEventListener("leavepictureinpicture", handleLeavePIP);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, []);
  (0, import_react2.useEffect)(function updateSrcObject() {
    var video = videoEl.current;
    if (!video || !videoTrack) return;
    video.srcObject = new MediaStream([videoTrack]);
    video.load();
    return function() {
      video.srcObject = null;
      video.load();
    };
  }, [videoTrack, videoTrack == null ? void 0 : videoTrack.id]);
  (0, import_react2.useEffect)(function reportVideoDimensions() {
    var video = videoEl.current;
    if (!onResize || !video) return;
    var frame;
    function handleResize() {
      if (frame) cancelAnimationFrame(frame);
      frame = requestAnimationFrame(function() {
        var video2 = videoEl.current;
        if (!video2 || document.hidden) return;
        var videoWidth = video2.videoWidth;
        var videoHeight = video2.videoHeight;
        if (videoWidth && videoHeight) {
          onResize == null ? void 0 : onResize({
            aspectRatio: videoWidth / videoHeight,
            height: videoHeight,
            width: videoWidth
          });
        }
      });
    }
    handleResize();
    video.addEventListener("loadedmetadata", handleResize);
    video.addEventListener("resize", handleResize);
    return function() {
      if (frame) cancelAnimationFrame(frame);
      video.removeEventListener("loadedmetadata", handleResize);
      video.removeEventListener("resize", handleResize);
    };
  }, [onResize]);
  return import_react2.default.createElement("video", Object.assign({
    autoPlay: true,
    muted: true,
    playsInline: true,
    ref: videoRef,
    "data-local": isLocal,
    "data-mirrored": isMirrored || void 0,
    "data-playable": isPlayable || void 0,
    "data-session-id": sessionId,
    "data-subscribed": subscribedState,
    "data-video-type": type,
    style: _extends({
      objectFit: fit,
      transform: isMirrored ? "scale(-1, 1)" : ""
    }, style, isPlayable ? playableStyle : {})
  }, props));
});
DailyVideo.displayName = "DailyVideo";
var DailyDevicesContext = (0, import_react2.createContext)({
  refreshDevices: function refreshDevices() {
    return Promise.resolve();
  }
});
var generalCameraState = Recoil_index_8({
  key: RECOIL_PREFIX + "general-camera-state",
  "default": "idle"
});
var generalMicrophoneState = Recoil_index_8({
  key: RECOIL_PREFIX + "general-microphone-state",
  "default": "idle"
});
var cameraDevicesState = Recoil_index_8({
  key: RECOIL_PREFIX + "camera-devices",
  "default": []
});
var microphoneDevicesState = Recoil_index_8({
  key: RECOIL_PREFIX + "microphone-devices",
  "default": []
});
var speakerDevicesState = Recoil_index_8({
  key: RECOIL_PREFIX + "speaker-devices",
  "default": []
});
var lastCameraErrorState = Recoil_index_8({
  key: RECOIL_PREFIX + "last-camera-error",
  "default": null
});
var DailyDevices = function DailyDevices2(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  var refreshDevices2 = Recoil_index_31(function(_ref2) {
    var transact_UNSTABLE = _ref2.transact_UNSTABLE;
    return _asyncToGenerator(function* () {
      var _navigator, _navigator$mediaDevic, _navigator2, _navigator2$mediaDevi;
      if (typeof ((_navigator = navigator) == null ? void 0 : (_navigator$mediaDevic = _navigator.mediaDevices) == null ? void 0 : _navigator$mediaDevic.getUserMedia) === "undefined" || typeof ((_navigator2 = navigator) == null ? void 0 : (_navigator2$mediaDevi = _navigator2.mediaDevices) == null ? void 0 : _navigator2$mediaDevi.enumerateDevices) === "undefined") {
        transact_UNSTABLE(function(_ref4) {
          var set = _ref4.set;
          set(generalCameraState, "not-supported");
          set(generalMicrophoneState, "not-supported");
        });
        return;
      }
      if (!daily) return;
      try {
        var _yield$daily$enumerat = yield daily.enumerateDevices(), devices = _yield$daily$enumerat.devices;
        var cams = devices.filter(function(d2) {
          return d2.kind === "videoinput" && d2.deviceId !== "";
        });
        var mics = devices.filter(function(d2) {
          return d2.kind === "audioinput" && d2.deviceId !== "";
        });
        var speakers = devices.filter(function(d2) {
          return d2.kind === "audiooutput" && d2.deviceId !== "";
        });
        var _yield$daily$getInput = yield daily.getInputDevices(), camera = _yield$daily$getInput.camera, mic = _yield$daily$getInput.mic, speaker = _yield$daily$getInput.speaker;
        var mapDevice = function mapDevice2(device, d2, prevDevices) {
          var _prevDevices$find$sta, _prevDevices$find;
          return {
            device: d2,
            selected: "deviceId" in device && d2.deviceId === device.deviceId,
            state: (_prevDevices$find$sta = (_prevDevices$find = prevDevices.find(function(p2) {
              return p2.device.deviceId === d2.deviceId;
            })) == null ? void 0 : _prevDevices$find.state) != null ? _prevDevices$find$sta : "granted"
          };
        };
        var sortDeviceByLabel = function sortDeviceByLabel2(a2, b2) {
          if (a2.device.deviceId === "default") return -1;
          if (b2.device.deviceId === "default") return 1;
          if (a2.device.label < b2.device.label) return -1;
          if (a2.device.label > b2.device.label) return 1;
          return 0;
        };
        transact_UNSTABLE(function(_ref5) {
          var set = _ref5.set;
          set(cameraDevicesState, function(prevCams) {
            return cams.filter(Boolean).map(function(d2) {
              return mapDevice(camera, d2, prevCams);
            }).sort(sortDeviceByLabel);
          });
          set(microphoneDevicesState, function(prevMics) {
            return mics.filter(Boolean).map(function(d2) {
              return mapDevice(mic, d2, prevMics);
            }).sort(sortDeviceByLabel);
          });
          set(speakerDevicesState, function(prevSpeakers) {
            return speakers.filter(Boolean).map(function(d2) {
              return mapDevice(speaker, d2, prevSpeakers);
            }).sort(sortDeviceByLabel);
          });
        });
      } catch (e2) {
        transact_UNSTABLE(function(_ref6) {
          var set = _ref6.set;
          set(generalCameraState, "not-supported");
          set(generalMicrophoneState, "not-supported");
        });
      }
    });
  }, [daily]);
  var updateDeviceStates = Recoil_index_31(function(_ref7) {
    var set = _ref7.set, snapshot = _ref7.snapshot, transact_UNSTABLE = _ref7.transact_UNSTABLE;
    return _asyncToGenerator(function* () {
      var _tracks$video$off, _tracks$audio$off, _tracks$audio, _tracks$audio$blocked, _tracks$audio2, _tracks$audio2$blocke, _tracks$audio3, _tracks$audio3$blocke, _tracks$video, _tracks$video$blocked, _tracks$video2, _tracks$video2$blocke, _tracks$video3, _tracks$video3$blocke;
      if (!daily) return;
      var currentCamState = yield snapshot.getPromise(generalCameraState);
      var currentMicState = yield snapshot.getPromise(generalMicrophoneState);
      var participants = daily.participants();
      if (!participants.local) return;
      var tracks = participants.local.tracks;
      var camPermissionState = "prompt";
      var micPermissionState = "prompt";
      if (navigator.permissions) {
        try {
          var camPermission = yield navigator.permissions.query({
            // @ts-ignore
            name: "camera"
          });
          camPermissionState = camPermission.state;
          var micPermission = yield navigator.permissions.query({
            // @ts-ignore
            name: "microphone"
          });
          micPermissionState = micPermission.state;
        } catch (_unused) {
        }
      }
      var awaitingCamAccess = camPermissionState === "prompt" && ["idle", "pending"].includes(currentCamState) && tracks.video.state === "interrupted" && !tracks.video.persistentTrack;
      var initialCamOff = ["idle", "pending"].includes(currentCamState) && !tracks.video.persistentTrack && Boolean((_tracks$video$off = tracks.video.off) == null ? void 0 : _tracks$video$off.byUser);
      var awaitingMicAccess = micPermissionState === "prompt" && ["idle", "pending"].includes(currentMicState) && tracks.audio.state === "interrupted" && !tracks.audio.persistentTrack;
      var initialMicOff = ["idle", "pending"].includes(currentMicState) && !tracks.audio.persistentTrack && Boolean((_tracks$audio$off = tracks.audio.off) == null ? void 0 : _tracks$audio$off.byUser);
      if ((_tracks$audio = tracks.audio) != null && (_tracks$audio$blocked = _tracks$audio.blocked) != null && _tracks$audio$blocked.byDeviceInUse) {
        transact_UNSTABLE(function(_ref9) {
          var set2 = _ref9.set;
          set2(generalMicrophoneState, "in-use");
          set2(microphoneDevicesState, function(mics) {
            return mics.map(function(m2) {
              return m2.selected ? _extends({}, m2, {
                state: "in-use"
              }) : m2;
            });
          });
        });
      } else if ((_tracks$audio2 = tracks.audio) != null && (_tracks$audio2$blocke = _tracks$audio2.blocked) != null && _tracks$audio2$blocke.byDeviceMissing) {
        set(generalMicrophoneState, "not-found");
      } else if ((_tracks$audio3 = tracks.audio) != null && (_tracks$audio3$blocke = _tracks$audio3.blocked) != null && _tracks$audio3$blocke.byPermissions || micPermissionState === "denied") {
        set(generalMicrophoneState, "blocked");
      } else if (awaitingMicAccess) {
        set(generalMicrophoneState, "pending");
      } else if (initialMicOff) {
        set(generalMicrophoneState, "idle");
      } else {
        transact_UNSTABLE(function(_ref10) {
          var set2 = _ref10.set;
          set2(generalMicrophoneState, "granted");
          set2(microphoneDevicesState, function(mics) {
            return mics.map(function(m2) {
              return m2.selected ? _extends({}, m2, {
                state: "granted"
              }) : m2;
            });
          });
        });
      }
      if ((_tracks$video = tracks.video) != null && (_tracks$video$blocked = _tracks$video.blocked) != null && _tracks$video$blocked.byDeviceInUse) {
        transact_UNSTABLE(function(_ref11) {
          var set2 = _ref11.set;
          set2(generalCameraState, "in-use");
          set2(cameraDevicesState, function(cams) {
            return cams.map(function(m2) {
              return m2.selected ? _extends({}, m2, {
                state: "in-use"
              }) : m2;
            });
          });
        });
      } else if ((_tracks$video2 = tracks.video) != null && (_tracks$video2$blocke = _tracks$video2.blocked) != null && _tracks$video2$blocke.byDeviceMissing) {
        set(generalCameraState, "not-found");
      } else if ((_tracks$video3 = tracks.video) != null && (_tracks$video3$blocke = _tracks$video3.blocked) != null && _tracks$video3$blocke.byPermissions || camPermissionState === "denied") {
        set(generalCameraState, "blocked");
      } else if (awaitingCamAccess) {
        set(generalCameraState, "pending");
      } else if (initialCamOff) {
        set(generalCameraState, "idle");
      } else {
        transact_UNSTABLE(function(_ref12) {
          var set2 = _ref12.set;
          set2(generalCameraState, "granted");
          set2(cameraDevicesState, function(cams) {
            return cams.map(function(m2) {
              return m2.selected ? _extends({}, m2, {
                state: "granted"
              }) : m2;
            });
          });
        });
      }
      refreshDevices2();
    });
  }, [daily, refreshDevices2]);
  useDailyEvent("participant-updated", (0, import_react2.useCallback)(function(ev) {
    if (!ev.participant.local) return;
    updateDeviceStates();
  }, [updateDeviceStates]));
  useDailyEvent("available-devices-updated", refreshDevices2);
  useDailyEvent("selected-devices-updated", refreshDevices2);
  useDailyEvent("camera-error", Recoil_index_31(function(_ref13) {
    var transact_UNSTABLE = _ref13.transact_UNSTABLE;
    return function(ev) {
      transact_UNSTABLE(function(_ref14) {
        var _ev$error, _ev$error2, _ev$error3, _ev$error4, _ev$error5, _ev$error6, _ev$error7;
        var set = _ref14.set;
        set(lastCameraErrorState, ev.error);
        switch ((_ev$error = ev.error) == null ? void 0 : _ev$error.type) {
          case "cam-in-use":
            set(generalCameraState, "in-use");
            break;
          case "mic-in-use":
            set(generalMicrophoneState, "in-use");
            break;
          case "cam-mic-in-use":
            set(generalCameraState, "in-use");
            set(generalMicrophoneState, "in-use");
            break;
          case "not-found":
            if ((_ev$error2 = ev.error) != null && _ev$error2.missingMedia.includes("video")) set(generalCameraState, "not-found");
            if ((_ev$error3 = ev.error) != null && _ev$error3.missingMedia.includes("audio")) set(generalMicrophoneState, "not-found");
            break;
          case "permissions":
            if ((_ev$error4 = ev.error) != null && _ev$error4.blockedMedia.includes("video")) set(generalCameraState, "blocked");
            if ((_ev$error5 = ev.error) != null && _ev$error5.blockedMedia.includes("audio")) set(generalMicrophoneState, "blocked");
            break;
          case "constraints":
            if (((_ev$error6 = ev.error) == null ? void 0 : _ev$error6.reason) === "invalid") {
              set(generalCameraState, "constraints-invalid");
              set(generalMicrophoneState, "constraints-invalid");
            } else if (((_ev$error7 = ev.error) == null ? void 0 : _ev$error7.reason) === "none-specified") {
              set(generalCameraState, "constraints-none-specified");
              set(generalMicrophoneState, "constraints-none-specified");
            }
            break;
          case "undefined-mediadevices":
            set(generalCameraState, "undefined-mediadevices");
            set(generalMicrophoneState, "undefined-mediadevices");
            break;
          case "unknown":
          default:
            set(generalCameraState, "unknown");
            set(generalMicrophoneState, "unknown");
            break;
        }
      });
    };
  }, []));
  useDailyEvent("started-camera", Recoil_index_31(function(_ref15) {
    var transact_UNSTABLE = _ref15.transact_UNSTABLE;
    return function() {
      transact_UNSTABLE(function(_ref16) {
        var set = _ref16.set;
        set(generalCameraState, "granted");
        set(generalMicrophoneState, "granted");
      });
      updateDeviceStates();
    };
  }, [updateDeviceStates]));
  return import_react2.default.createElement(DailyDevicesContext.Provider, {
    value: {
      refreshDevices: refreshDevices2
    }
  }, children);
};
var liveStreamingState = Recoil_index_8({
  key: RECOIL_PREFIX + "live-streaming",
  "default": {
    errorMsg: void 0,
    isLiveStreaming: false,
    layout: void 0
  }
});
var DailyLiveStreaming = function DailyLiveStreaming2(_ref) {
  var children = _ref.children;
  useDailyEvent("live-streaming-started", Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return function(ev) {
      set(liveStreamingState, {
        isLiveStreaming: true,
        layout: ev == null ? void 0 : ev.layout
      });
    };
  }, []));
  useDailyEvent("live-streaming-stopped", Recoil_index_31(function(_ref3) {
    var set = _ref3.set;
    return function() {
      set(liveStreamingState, function(prevState) {
        return _extends({}, prevState, {
          isLiveStreaming: false,
          layout: void 0
        });
      });
    };
  }, []));
  useDailyEvent("live-streaming-error", Recoil_index_31(function(_ref4) {
    var set = _ref4.set;
    return function(ev) {
      set(liveStreamingState, function(prevState) {
        return _extends({}, prevState, {
          errorMsg: ev.errorMsg
        });
      });
    };
  }, []));
  useDailyEvent("left-meeting", Recoil_index_31(function(_ref5) {
    var reset = _ref5.reset;
    return function() {
      reset(liveStreamingState);
    };
  }, []));
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var meetingStateState = Recoil_index_8({
  key: RECOIL_PREFIX + "meeting-state",
  "default": "new"
});
var meetingErrorState = Recoil_index_8({
  key: RECOIL_PREFIX + "meeting-error",
  "default": null
});
var nonFatalErrorState = Recoil_index_8({
  key: RECOIL_PREFIX + "non-fatal-error",
  "default": null
});
var meetingSessionDataState = Recoil_index_8({
  key: "meeting-session-data",
  "default": {
    data: void 0,
    topology: "none"
  }
});
var DailyMeeting = function DailyMeeting2(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  var updateMeetingState = Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return function() {
      if (!daily) return;
      var meetingState = daily.meetingState();
      set(meetingStateState, meetingState);
      return meetingState;
    };
  }, [daily]);
  useDailyEvent("loading", updateMeetingState);
  useDailyEvent("loaded", updateMeetingState);
  useDailyEvent("joining-meeting", updateMeetingState);
  useDailyEvent("joined-meeting", updateMeetingState);
  useDailyEvent("left-meeting", updateMeetingState);
  useDailyEvent("error", Recoil_index_31(function(_ref3) {
    var set = _ref3.set;
    return function(ev) {
      set(meetingErrorState, ev);
      updateMeetingState();
    };
  }, [updateMeetingState]));
  useDailyEvent("nonfatal-error", Recoil_index_31(function(_ref4) {
    var set = _ref4.set;
    return function(ev) {
      set(nonFatalErrorState, ev);
    };
  }, []));
  var initMeetingSessionState = Recoil_index_31(function(_ref5) {
    var set = _ref5.set;
    return function() {
      if (!daily) return;
      set(meetingSessionDataState, daily.meetingSessionState());
    };
  }, [daily]);
  useDailyEvent("joined-meeting", initMeetingSessionState);
  useDailyEvent("meeting-session-state-updated", Recoil_index_31(function(_ref6) {
    var set = _ref6.set;
    return function(ev) {
      set(meetingSessionDataState, ev.meetingSessionState);
    };
  }, []));
  useDailyEvent("left-meeting", Recoil_index_31(function(_ref7) {
    var reset = _ref7.reset;
    return function() {
      reset(meetingSessionDataState);
    };
  }, []));
  useDailyEvent("call-instance-destroyed", Recoil_index_31(function(_ref8) {
    var transact_UNSTABLE = _ref8.transact_UNSTABLE;
    return function() {
      transact_UNSTABLE(function(_ref9) {
        var reset = _ref9.reset;
        reset(meetingStateState);
        reset(meetingErrorState);
        reset(nonFatalErrorState);
        reset(meetingSessionDataState);
      });
    };
  }, []));
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var topologyState = Recoil_index_8({
  key: RECOIL_PREFIX + "topology",
  "default": "none"
});
var networkQualityState = Recoil_index_8({
  key: RECOIL_PREFIX + "networkQuality",
  "default": 100
});
var networkThresholdState = Recoil_index_8({
  key: RECOIL_PREFIX + "networkThreshold",
  "default": "good"
});
var DailyNetwork = function DailyNetwork2(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  var topology = Recoil_index_20(topologyState);
  var initTopology = Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return _asyncToGenerator(function* () {
      if (!daily) return;
      var topology2 = yield daily.getNetworkTopology();
      if (!topology2 || (topology2 == null ? void 0 : topology2.topology) === "none") return;
      set(topologyState, topology2.topology);
    });
  }, [daily]);
  useDailyEvent("joined-meeting", initTopology);
  useDailyEvent("network-connection", Recoil_index_31(function(_ref4) {
    var set = _ref4.set;
    return function(ev) {
      switch (ev.event) {
        case "connected":
          if (ev.type === "peer-to-peer") set(topologyState, "peer");
          if (ev.type === "sfu") set(topologyState, "sfu");
          break;
      }
    };
  }, []));
  useDailyEvent("network-quality-change", Recoil_index_31(function(_ref5) {
    var transact_UNSTABLE = _ref5.transact_UNSTABLE;
    return function(ev) {
      transact_UNSTABLE(function(_ref6) {
        var set = _ref6.set;
        set(networkQualityState, function(prevQuality) {
          return prevQuality !== ev.quality ? ev.quality : prevQuality;
        });
        set(networkThresholdState, function(prevThreshold) {
          return prevThreshold !== ev.threshold ? ev.threshold : prevThreshold;
        });
      });
    };
  }, []));
  useDailyEvent("left-meeting", Recoil_index_31(function(_ref7) {
    var transact_UNSTABLE = _ref7.transact_UNSTABLE;
    return function() {
      transact_UNSTABLE(function(_ref8) {
        var reset = _ref8.reset;
        reset(topologyState);
        reset(networkQualityState);
        reset(networkThresholdState);
      });
    };
  }, []));
  (0, import_react2.useEffect)(function() {
    if (!daily || topology !== "none") return;
    initTopology();
  }, [daily, initTopology, topology]);
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var recordingState = Recoil_index_8({
  key: RECOIL_PREFIX + "recording",
  "default": {
    isLocalParticipantRecorded: false,
    isRecording: false
  }
});
var DailyRecordings = function DailyRecordings2(_ref) {
  var children = _ref.children;
  var setState = Recoil_index_24(recordingState);
  var localSessionId = useLocalSessionId();
  var recordingParticipantIds = useParticipantIds({
    filter: "record"
  });
  (0, import_react2.useEffect)(function() {
    var hasRecordingParticipants = recordingParticipantIds.length > 0;
    var isLocalParticipantRecording = recordingParticipantIds.includes(localSessionId || "local");
    setState(function(s2) {
      return _extends({}, s2, {
        // In case type is local or not set, determine based on recording participants
        isLocalParticipantRecorded: (s2 == null ? void 0 : s2.type) === "local" || !(s2 != null && s2.type) ? hasRecordingParticipants : s2.isLocalParticipantRecorded,
        isRecording: (s2 == null ? void 0 : s2.type) === "local" || !(s2 != null && s2.type) ? hasRecordingParticipants : s2.isRecording,
        local: ((s2 == null ? void 0 : s2.type) === "local" || !(s2 != null && s2.type)) && hasRecordingParticipants ? isLocalParticipantRecording : s2 == null ? void 0 : s2.local,
        /**
         * Set type in case recording participants are detected.
         * We only set `record` on participants, when recording type is 'local'.
         */
        type: hasRecordingParticipants ? "local" : s2 == null ? void 0 : s2.type
      });
    });
  }, [localSessionId, recordingParticipantIds, setState]);
  useDailyEvent("recording-started", Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return function(ev) {
      var isLocalParticipantRecorded = true;
      switch (ev.type) {
        case "cloud-beta":
        case "cloud": {
          var _ev$layout;
          if (localSessionId && ((_ev$layout = ev.layout) == null ? void 0 : _ev$layout.preset) === "single-participant" && ev.layout.session_id !== localSessionId) {
            isLocalParticipantRecorded = false;
          }
          break;
        }
      }
      set(recordingState, {
        error: false,
        isLocalParticipantRecorded,
        isRecording: true,
        layout: ev == null ? void 0 : ev.layout,
        local: ev == null ? void 0 : ev.local,
        recordingId: ev == null ? void 0 : ev.recordingId,
        recordingStartedDate: /* @__PURE__ */ new Date(),
        startedBy: ev == null ? void 0 : ev.startedBy,
        type: ev == null ? void 0 : ev.type
      });
    };
  }, [localSessionId]));
  useDailyEvent("recording-stopped", Recoil_index_31(function(_ref3) {
    var set = _ref3.set;
    return function() {
      set(recordingState, function(prevState) {
        return _extends({}, prevState, {
          isLocalParticipantRecorded: false,
          isRecording: false
        });
      });
    };
  }, []));
  useDailyEvent("recording-error", Recoil_index_31(function(_ref4) {
    var set = _ref4.set;
    return function() {
      set(recordingState, function(prevState) {
        return _extends({}, prevState, {
          error: true,
          isLocalParticipantRecorded: false,
          isRecording: false
        });
      });
    };
  }, []));
  useDailyEvent("left-meeting", Recoil_index_31(function(_ref5) {
    var reset = _ref5.reset;
    return function() {
      reset(recordingState);
    };
  }, []));
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var useMeetingState = function useMeetingState2() {
  var meetingState = Recoil_index_20(meetingStateState);
  (0, import_react2.useDebugValue)(meetingState);
  return meetingState;
};
var roomState = Recoil_index_8({
  key: RECOIL_PREFIX + "room",
  "default": null
});
var DailyRoom = function DailyRoom2(_ref) {
  var children = _ref.children;
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateRoom = Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return _asyncToGenerator(function* () {
      if (!daily || meetingState === "left-meeting") return;
      var room = yield daily.room();
      if (room && "id" in room) {
        set(roomState, room);
      }
      return room;
    });
  }, [daily, meetingState]);
  useDailyEvent("access-state-updated", updateRoom);
  useDailyEvent("left-meeting", Recoil_index_31(function(_ref4) {
    var reset = _ref4.reset;
    return function() {
      reset(roomState);
    };
  }, []));
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var transcriptionState = Recoil_index_8({
  key: RECOIL_PREFIX + "transcription",
  "default": {
    isTranscribing: false,
    model: "general",
    language: "en",
    transcriptions: []
  }
});
var DailyTranscriptions = function DailyTranscriptions2(_ref) {
  var children = _ref.children;
  useDailyEvent("transcription-started", Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return function(ev) {
      set(transcriptionState, _extends({
        error: false,
        isTranscribing: true,
        transcriptionStartDate: /* @__PURE__ */ new Date(),
        transcriptions: []
      }, ev));
    };
  }, []));
  useDailyEvent("transcription-stopped", Recoil_index_31(function(_ref3) {
    var set = _ref3.set;
    return function(ev) {
      set(transcriptionState, function(prevState) {
        return _extends({}, prevState, {
          updatedBy: ev == null ? void 0 : ev.updatedBy,
          isTranscribing: false
        });
      });
    };
  }, []));
  useDailyEvent("transcription-error", Recoil_index_31(function(_ref4) {
    var set = _ref4.set;
    return function() {
      set(transcriptionState, function(prevState) {
        return _extends({}, prevState, {
          error: true,
          isTranscribing: false
        });
      });
    };
  }, []));
  useDailyEvent("left-meeting", Recoil_index_31(function(_ref5) {
    var set = _ref5.set;
    return function() {
      set(transcriptionState, function(prevState) {
        return _extends({}, prevState, {
          isTranscribing: false
        });
      });
    };
  }, []));
  useDailyEvent("app-message", Recoil_index_31(function(_ref6) {
    var set = _ref6.set;
    return function(ev) {
      if ((ev == null ? void 0 : ev.fromId) === "transcription") {
        set(transcriptionState, function(prevState) {
          return _extends({}, prevState, {
            // setting it to true whenever a new message is received
            // as the participants who joined after the transcription-started event
            // won't be knowing if transcription is started or not
            isTranscribing: true,
            transcriptions: [].concat(prevState.transcriptions, [ev.data])
          });
        });
      }
    };
  }, []));
  return import_react2.default.createElement(import_react2.default.Fragment, null, children);
};
var defaultOptions = {};
var defaultShouldCreateInstance = function defaultShouldCreateInstance2() {
  return true;
};
var defaultProps = {
  options: defaultOptions,
  shouldCreateInstance: defaultShouldCreateInstance
};
var useCallInstance = function useCallInstance2(type, _temp) {
  var _ref = _temp === void 0 ? defaultProps : _temp, parentElRef = _ref.parentElRef, _ref$options = _ref.options, options = _ref$options === void 0 ? defaultOptions : _ref$options, _ref$shouldCreateInst = _ref.shouldCreateInstance, shouldCreateInstance = _ref$shouldCreateInst === void 0 ? defaultShouldCreateInstance : _ref$shouldCreateInst;
  var _useState = (0, import_react2.useState)(null), callInstance = _useState[0], setCallInstance = _useState[1];
  var lastUsedOptions = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(function() {
    if (type === "callFrame" && (parentElRef == null ? void 0 : parentElRef.current) === null || !shouldCreateInstance()) return;
    function destroyCallInstance(_x) {
      return _destroyCallInstance.apply(this, arguments);
    }
    function _destroyCallInstance() {
      _destroyCallInstance = _asyncToGenerator(function* (co3) {
        yield co3.destroy();
      });
      return _destroyCallInstance.apply(this, arguments);
    }
    var handleDestroyedInstance = function handleDestroyedInstance2() {
      setTimeout(function() {
        return setCallInstance(null);
      }, 0);
    };
    var co2 = es.getCallInstance();
    if (!callInstance && co2 && !co2.isDestroyed()) {
      co2.once("call-instance-destroyed", handleDestroyedInstance);
      setCallInstance(co2);
      return;
    }
    if (callInstance) {
      if (!customDeepEqual(lastUsedOptions.current, options)) {
        destroyCallInstance(callInstance);
      }
      return;
    }
    if (!co2 || co2.isDestroyed()) {
      switch (type) {
        case "callFrame":
          co2 = parentElRef != null && parentElRef.current ? es.createFrame(parentElRef.current, _extends({}, options)) : es.createFrame(_extends({}, options));
          break;
        case "callObject":
          co2 = es.createCallObject(_extends({}, options));
          break;
      }
      lastUsedOptions.current = options;
    }
    setCallInstance(co2);
    co2.once("call-instance-destroyed", handleDestroyedInstance);
  }, [callInstance, options, parentElRef, shouldCreateInstance, type]);
  return callInstance;
};
var useCallObject = function useCallObject2(props) {
  return useCallInstance("callObject", props);
};
var _excluded$2 = ["children", "recoilRootProps"];
var DailyProvider = function DailyProvider2(_ref) {
  var children = _ref.children, _ref$recoilRootProps = _ref.recoilRootProps, recoilRootProps = _ref$recoilRootProps === void 0 ? {} : _ref$recoilRootProps, props = _objectWithoutPropertiesLoose(_ref, _excluded$2);
  var eventsMap = (0, import_react2.useRef)({});
  var handleEvent = (0, import_react2.useCallback)(function(ev) {
    var _eventsMap$current$ev, _eventsMap$current;
    if (!("action" in ev)) return;
    var event = ev.action;
    var allHandlers = Array.from((_eventsMap$current$ev = (_eventsMap$current = eventsMap.current) == null ? void 0 : _eventsMap$current[event]) != null ? _eventsMap$current$ev : []);
    var priorityHandlers = allHandlers.filter(function(_ref2) {
      var key = _ref2[0];
      return key < 0;
    });
    var normalHandlers = allHandlers.filter(function(_ref3) {
      var key = _ref3[0];
      return key > 0;
    });
    var sortedHandlers = [].concat(priorityHandlers, normalHandlers);
    for (var _iterator = _createForOfIteratorHelperLoose(sortedHandlers), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, cb = _step$value[1];
      cb(ev);
    }
  }, []);
  var initEventHandlers = (0, import_react2.useCallback)(function(daily) {
    if (!daily) return;
    Object.keys(eventsMap.current).forEach(function(event) {
      daily.off(event, handleEvent);
      if (!daily.isDestroyed()) {
        daily.on(event, handleEvent);
      }
    });
  }, [handleEvent]);
  var externalCallObject = "callObject" in props ? props.callObject : null;
  var memoizedOptions = (0, import_react2.useMemo)(function() {
    return "callObject" in props ? {} : props;
  }, [props]);
  var internalCallObject = useCallObject({
    options: memoizedOptions,
    shouldCreateInstance: (0, import_react2.useCallback)(function() {
      return !("callObject" in props);
    }, [props])
  });
  var callObject = externalCallObject != null ? externalCallObject : internalCallObject;
  (0, import_react2.useEffect)(function() {
    if (!callObject) return;
    initEventHandlers(callObject);
  }, [callObject, initEventHandlers]);
  var on3 = (0, import_react2.useCallback)(function(ev, cb, key) {
    var _eventsMap$current$ev2;
    if (!eventsMap.current[ev]) {
      eventsMap.current[ev] = /* @__PURE__ */ new Map();
      if (callObject) {
        callObject.off(ev, handleEvent);
        if (!callObject.isDestroyed()) {
          callObject.on(ev, handleEvent);
        }
      }
    }
    if (!((_eventsMap$current$ev2 = eventsMap.current[ev]) != null && _eventsMap$current$ev2.has(key))) {
      var _eventsMap$current$ev3;
      (_eventsMap$current$ev3 = eventsMap.current[ev]) == null ? void 0 : _eventsMap$current$ev3.set(key, cb);
    }
  }, [callObject, handleEvent]);
  var off2 = (0, import_react2.useCallback)(function(ev, key) {
    var _eventsMap$current$ev4, _eventsMap$current$ev5;
    (_eventsMap$current$ev4 = eventsMap.current[ev]) == null ? void 0 : _eventsMap$current$ev4["delete"](key);
    if (((_eventsMap$current$ev5 = eventsMap.current[ev]) == null ? void 0 : _eventsMap$current$ev5.size) === 0) {
      callObject == null ? void 0 : callObject.off(ev, handleEvent);
      delete eventsMap.current[ev];
    }
  }, [callObject, handleEvent]);
  return import_react2.default.createElement(Recoil_index_5, Object.assign({}, recoilRootProps), import_react2.default.createElement(DailyContext.Provider, {
    value: callObject
  }, import_react2.default.createElement(DailyEventContext.Provider, {
    value: {
      on: on3,
      off: off2
    }
  }, import_react2.default.createElement(DailyRoom, null, import_react2.default.createElement(DailyMeeting, null, import_react2.default.createElement(DailyNetwork, null, import_react2.default.createElement(DailyParticipants, null, import_react2.default.createElement(DailyRecordings, null, import_react2.default.createElement(DailyLiveStreaming, null, import_react2.default.createElement(DailyTranscriptions, null, import_react2.default.createElement(DailyDevices, null, children)))))))))));
};
var useParticipant = function useParticipant2(sessionId, _temp) {
  var _ref = _temp === void 0 ? {} : _temp, onParticipantLeft = _ref.onParticipantLeft, onParticipantUpdated = _ref.onParticipantUpdated;
  var participant = Recoil_index_20(participantState(sessionId));
  useThrottledDailyEvent(["participant-updated", "participant-left"], (0, import_react2.useCallback)(function(evts) {
    var filteredEvts = evts.filter(function(ev) {
      return ev.participant.session_id === sessionId;
    });
    if (!filteredEvts.length) return;
    filteredEvts.forEach(function(ev) {
      switch (ev.action) {
        case "participant-updated":
          onParticipantUpdated == null ? void 0 : onParticipantUpdated(ev);
          break;
        case "participant-left":
          onParticipantLeft == null ? void 0 : onParticipantLeft(ev);
          break;
      }
    });
  }, [onParticipantLeft, onParticipantUpdated, sessionId]));
  (0, import_react2.useDebugValue)(participant);
  return participant;
};
var useActiveParticipant = function useActiveParticipant2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$ignoreLocal = _ref.ignoreLocal, ignoreLocal = _ref$ignoreLocal === void 0 ? false : _ref$ignoreLocal, onActiveSpeakerChange = _ref.onActiveSpeakerChange;
  var daily = useDaily();
  var recentActiveId = Recoil_index_20(activeIdState);
  var _useState = (0, import_react2.useState)(""), activeId = _useState[0], setActiveId = _useState[1];
  var activeParticipant = useParticipant(activeId);
  (0, import_react2.useEffect)(function() {
    var _daily$participants;
    if (!daily) return;
    var local = daily == null ? void 0 : (_daily$participants = daily.participants()) == null ? void 0 : _daily$participants.local;
    if (ignoreLocal && recentActiveId === (local == null ? void 0 : local.session_id)) return;
    setActiveId(recentActiveId != null ? recentActiveId : "");
  }, [daily, ignoreLocal, recentActiveId]);
  useDailyEvent("active-speaker-change", (0, import_react2.useCallback)(function(ev) {
    onActiveSpeakerChange == null ? void 0 : onActiveSpeakerChange(ev);
  }, [onActiveSpeakerChange]));
  (0, import_react2.useDebugValue)(activeParticipant);
  return activeParticipant;
};
var useAppMessage = function useAppMessage2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onAppMessage = _ref.onAppMessage;
  var daily = useDaily();
  var sendAppMessage = (0, import_react2.useCallback)(function(data, to2) {
    if (to2 === void 0) {
      to2 = "*";
    }
    if (!daily) return;
    daily.sendAppMessage(data, to2);
  }, [daily]);
  var handleAppMessage = (0, import_react2.useCallback)(function(ev) {
    onAppMessage == null ? void 0 : onAppMessage(ev, sendAppMessage);
  }, [onAppMessage, sendAppMessage]);
  useDailyEvent("app-message", handleAppMessage);
  return sendAppMessage;
};
var audioLevelProcessor = "\n    class AudioLevelProcessor extends AudioWorkletProcessor {\n    volume;\n    interval;\n    nextFrame;\n    \n    constructor() {\n      super();\n      this.volume = 0;\n      this.interval = 25;\n      this.nextFrame = this.interval;\n    }\n    \n    get intervalInFrames() {\n      // sampleRate is globally defined in AudioWorklets.\n      // See https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletGlobalScope\n      // eslint-disable-next-line no-undef\n      return (this.interval / 1000) * sampleRate;\n    }\n    \n    process(inputList) {\n      const firstInput = inputList[0];\n    \n      if (firstInput.length > 0) {\n        const inputData = firstInput[0];\n        let total = 0;\n    \n        for (let i = 0; i < inputData.length; ++i) {\n          total += Math.abs(inputData[i]);\n        }\n    \n        const rms = Math.sqrt(total / inputData.length);\n        this.volume = Math.max(0, Math.min(1, rms));\n    \n        this.nextFrame -= inputData.length;\n        if (this.nextFrame < 0) {\n          this.nextFrame += this.intervalInFrames;\n          this.port.postMessage({ volume: this.volume });\n        }\n      }\n    \n      return true;\n    }\n    }\n    \n    registerProcessor('audiolevel', AudioLevelProcessor);              \n";
var inlineAudioWorklet = "data:application/javascript;charset=utf8," + encodeURIComponent(audioLevelProcessor);
var useAudioLevel = function useAudioLevel2(mediaTrack, onVolumeChange) {
  var audioCtx = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(function setupStreamAndStartProcessing() {
    if (!mediaTrack) return;
    var AudioCtx = typeof AudioContext !== "undefined" ? AudioContext : typeof window.webkitAudioContext !== "undefined" ? window.webkitAudioContext : null;
    if (!AudioCtx) return;
    if (!audioCtx.current) {
      audioCtx.current = new AudioCtx();
    }
    var audioContext = audioCtx.current;
    if (!audioContext) return;
    var mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([mediaTrack]));
    var node;
    var gainNode;
    var startProcessing = function() {
      var _ref = _asyncToGenerator(function* () {
        try {
          node = new AudioWorkletNode(audioContext, "audiolevel");
          gainNode = audioContext.createGain();
        } catch (_unused) {
          try {
            yield audioContext.audioWorklet.addModule(inlineAudioWorklet);
            node = new AudioWorkletNode(audioContext, "audiolevel");
            gainNode = audioContext.createGain();
          } catch (e2) {
            console.error(e2);
          }
        }
        if (!(node && gainNode)) return;
        node.port.onmessage = function(event) {
          var volume = 0;
          if (event.data.volume) volume = event.data.volume;
          if (!node) return;
          onVolumeChange(volume);
        };
        gainNode.gain.value = 0;
        try {
          mediaStreamSource.connect(node).connect(gainNode).connect(audioContext.destination);
        } catch (e2) {
          console.warn(e2);
        }
      });
      return function startProcessing2() {
        return _ref.apply(this, arguments);
      };
    }();
    startProcessing();
    return function() {
      var _node;
      (_node = node) == null ? void 0 : _node.disconnect();
      node = null;
      mediaStreamSource == null ? void 0 : mediaStreamSource.disconnect();
    };
  }, [onVolumeChange, mediaTrack]);
};
var useAudioLevelObserver = function useAudioLevelObserver2(id, cb) {
  var daily = useDaily();
  var localSessionId = useLocalSessionId();
  var isLocal = id === localSessionId;
  useDailyEvent("local-audio-level", (0, import_react2.useCallback)(function(ev) {
    if (!isLocal) return;
    cb(ev.audioLevel);
  }, [cb, isLocal]));
  useDailyEvent("remote-participants-audio-level", (0, import_react2.useCallback)(function(ev) {
    if (isLocal) return;
    cb(ev.participantsAudioLevel[id]);
  }, [cb, id, isLocal]));
  (0, import_react2.useEffect)(function maybeStartLocalAudioObserver() {
    if (!daily || daily.isDestroyed() || !isLocal) return;
    if (daily.isLocalAudioLevelObserverRunning()) return;
    daily.startLocalAudioLevelObserver();
  }, [daily, isLocal]);
  (0, import_react2.useEffect)(function maybeStartRemoteAudioObserver() {
    if (!daily || daily.isDestroyed() || isLocal) return;
    if (daily.isRemoteParticipantsAudioLevelObserverRunning()) return;
    daily.startRemoteParticipantsAudioLevelObserver();
  }, [daily, isLocal]);
};
var useAudioTrack = function useAudioTrack2(participantId) {
  return useMediaTrack(participantId, "audio");
};
var useCallFrame = function useCallFrame2(props) {
  return useCallInstance("callFrame", props);
};
var CPULoadState = Recoil_index_8({
  key: "cpu-load-state",
  "default": {
    state: "low",
    reason: "none"
  }
});
var useCPULoad = function useCPULoad2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onCPULoadChange = _ref.onCPULoadChange;
  var cpu = Recoil_index_20(CPULoadState);
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateCPULoadState = Recoil_index_31(function(_ref2) {
    var set = _ref2.set, snapshot = _ref2.snapshot;
    return function() {
      var _ref3 = _asyncToGenerator(function* (cpu2) {
        var prev = yield snapshot.getPromise(CPULoadState);
        if ((0, import_fast_deep_equal.default)(prev, cpu2)) return;
        set(CPULoadState, cpu2);
      });
      return function(_x) {
        return _ref3.apply(this, arguments);
      };
    }();
  }, []);
  (0, import_react2.useEffect)(function() {
    var mounted = true;
    if (!daily || daily.isDestroyed() || meetingState !== "joined-meeting") return;
    daily.getCpuLoadStats().then(function(stats) {
      if (!mounted) return;
      updateCPULoadState({
        state: stats.cpuLoadState,
        reason: stats.cpuLoadStateReason
      });
    });
    return function() {
      mounted = false;
    };
  }, [daily, meetingState, updateCPULoadState]);
  useDailyEvent("cpu-load-change", (0, import_react2.useCallback)(function(ev) {
    updateCPULoadState({
      state: ev.cpuLoadState,
      reason: ev.cpuLoadStateReason
    });
    onCPULoadChange == null ? void 0 : onCPULoadChange(ev);
  }, [onCPULoadChange, updateCPULoadState]));
  (0, import_react2.useDebugValue)(cpu);
  return cpu;
};
var useDailyError = function useDailyError2() {
  var meetingError = Recoil_index_20(meetingErrorState);
  var nonFatalError = Recoil_index_20(nonFatalErrorState);
  var result = {
    meetingError,
    nonFatalError
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useDevices = function useDevices2() {
  var daily = useDaily();
  var camState = Recoil_index_20(generalCameraState);
  var micState = Recoil_index_20(generalMicrophoneState);
  var camDevices = Recoil_index_20(cameraDevicesState);
  var micDevices = Recoil_index_20(microphoneDevicesState);
  var speakerDevices = Recoil_index_20(speakerDevicesState);
  var cameraError = Recoil_index_20(lastCameraErrorState);
  var _useContext = (0, import_react2.useContext)(DailyDevicesContext), refreshDevices2 = _useContext.refreshDevices;
  var setCamera = (0, import_react2.useCallback)(function() {
    var _ref = _asyncToGenerator(function* (deviceId) {
      yield daily == null ? void 0 : daily.setInputDevicesAsync({
        audioDeviceId: null,
        videoDeviceId: deviceId
      });
    });
    return function(_x) {
      return _ref.apply(this, arguments);
    };
  }(), [daily]);
  var setMicrophone = (0, import_react2.useCallback)(function() {
    var _ref2 = _asyncToGenerator(function* (deviceId) {
      yield daily == null ? void 0 : daily.setInputDevicesAsync({
        audioDeviceId: deviceId,
        videoDeviceId: null
      });
    });
    return function(_x2) {
      return _ref2.apply(this, arguments);
    };
  }(), [daily]);
  var setSpeaker = (0, import_react2.useCallback)(function() {
    var _ref3 = _asyncToGenerator(function* (deviceId) {
      yield daily == null ? void 0 : daily.setOutputDeviceAsync({
        outputDeviceId: deviceId
      });
    });
    return function(_x3) {
      return _ref3.apply(this, arguments);
    };
  }(), [daily]);
  var errorStates = ["blocked", "in-use", "not-found", "constraints-invalid", "constraints-none-specified", "undefined-mediadevices", "unknown"];
  var result = {
    /**
     * Most recent error object emitted via [camera-error event](https://docs.daily.co/reference/daily-js/events/meeting-events#camera-error).
     */
    cameraError,
    /**
     * A list of the user's camera (videoinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    cameras: camDevices,
    /**
     * The general state for camera access.
     */
    camState,
    /**
     * Holds the currently selected camera.
     */
    currentCam: camDevices.find(function(cam) {
      return cam.selected;
    }),
    /**
     * Holds the currently selected microphone.
     */
    currentMic: micDevices.find(function(mic) {
      return mic.selected;
    }),
    /**
     * Holds the currently selected speaker.
     */
    currentSpeaker: speakerDevices.find(function(speaker) {
      return speaker.selected;
    }),
    /**
     * Indicates that there's an issue with camera devices.
     */
    hasCamError: errorStates.includes(camState),
    /**
     * Indicates that there's an issue with microphone devices.
     */
    hasMicError: errorStates.includes(micState),
    /**
     * A list of the user's microphone (audioinput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    microphones: micDevices,
    /**
     * The general state for microphone access.
     */
    micState,
    /**
     * Refreshes the list of devices using [enumerateDevices](https://docs.daily.co/reference/daily-js/instance-methods/enumerate-devices).
     */
    refreshDevices: refreshDevices2,
    /**
     * Allows to switch to the camera with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.
     */
    setCamera,
    /**
     * Allows to switch to the microphone with the specified deviceId. Calls [setInputDevicesAsync](https://docs.daily.co/reference/daily-js/instance-methods/set-input-devices-async) internally.
     */
    setMicrophone,
    /**
     * Allows to switch to the speaker with the specified deviceId. Calls [setOutputDevice](https://docs.daily.co/reference/daily-js/instance-methods/set-output-device) internally.
     */
    setSpeaker,
    /**
     * A list of the user's speaker (audiooutput) devices. See [MediaDeviceInfo](https://developer.mozilla.org/en-US/docs/Web/API/MediaDeviceInfo) for more info.
     */
    speakers: speakerDevices
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var inputSettingsState = Recoil_index_8({
  key: RECOIL_PREFIX + "input-settings",
  "default": null
});
var useInputSettings = function useInputSettings2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onError = _ref.onError, onInputSettingsUpdated = _ref.onInputSettingsUpdated;
  var inputSettings = Recoil_index_20(inputSettingsState);
  var _useDailyError = useDailyError(), nonFatalError = _useDailyError.nonFatalError;
  var daily = useDaily();
  var updateInputSettingsState = Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return function(inputSettings2) {
      set(inputSettingsState, inputSettings2);
    };
  }, []);
  (0, import_react2.useEffect)(function() {
    if (!daily) return;
    daily.getInputSettings().then(updateInputSettingsState);
  }, [daily, updateInputSettingsState]);
  useDailyEvent("input-settings-updated", (0, import_react2.useCallback)(function(ev) {
    updateInputSettingsState(ev.inputSettings);
    onInputSettingsUpdated == null ? void 0 : onInputSettingsUpdated(ev);
  }, [onInputSettingsUpdated, updateInputSettingsState]));
  useDailyEvent("nonfatal-error", (0, import_react2.useCallback)(function(ev) {
    if (ev.type !== "input-settings-error") return;
    onError == null ? void 0 : onError(ev);
  }, [onError]));
  var updateInputSettings = (0, import_react2.useCallback)(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return daily == null ? void 0 : daily.updateInputSettings.apply(daily, args);
  }, [daily]);
  var result = {
    errorMsg: (nonFatalError == null ? void 0 : nonFatalError.type) === "input-settings-error" ? nonFatalError.errorMsg : null,
    inputSettings,
    updateInputSettings
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useLiveStreaming = function useLiveStreaming2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onLiveStreamingError = _ref.onLiveStreamingError, onLiveStreamingStarted = _ref.onLiveStreamingStarted, onLiveStreamingStopped = _ref.onLiveStreamingStopped, onLiveStreamingUpdated = _ref.onLiveStreamingUpdated, onLiveStreamingWarning = _ref.onLiveStreamingWarning;
  var daily = useDaily();
  var state = Recoil_index_20(liveStreamingState);
  useDailyEvent("live-streaming-started", (0, import_react2.useCallback)(function(ev) {
    onLiveStreamingStarted == null ? void 0 : onLiveStreamingStarted(ev);
  }, [onLiveStreamingStarted]));
  useDailyEvent("live-streaming-stopped", (0, import_react2.useCallback)(function(ev) {
    onLiveStreamingStopped == null ? void 0 : onLiveStreamingStopped(ev);
  }, [onLiveStreamingStopped]));
  useDailyEvent("live-streaming-updated", (0, import_react2.useCallback)(function(ev) {
    onLiveStreamingUpdated == null ? void 0 : onLiveStreamingUpdated(ev);
  }, [onLiveStreamingUpdated]));
  useDailyEvent("live-streaming-error", (0, import_react2.useCallback)(function(ev) {
    onLiveStreamingError == null ? void 0 : onLiveStreamingError(ev);
  }, [onLiveStreamingError]));
  useDailyEvent("nonfatal-error", (0, import_react2.useCallback)(function(ev) {
    if (ev.type !== "live-streaming-warning") return;
    onLiveStreamingWarning == null ? void 0 : onLiveStreamingWarning(ev);
  }, [onLiveStreamingWarning]));
  var startLiveStreaming = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.startLiveStreaming.apply(daily, arguments);
  }, [daily]);
  var stopLiveStreaming = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.stopLiveStreaming.apply(daily, arguments);
  }, [daily]);
  var updateLiveStreaming = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.updateLiveStreaming.apply(daily, arguments);
  }, [daily]);
  var result = _extends({}, state, {
    startLiveStreaming,
    stopLiveStreaming,
    updateLiveStreaming
  });
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useLocalParticipant = function useLocalParticipant2() {
  var localId = Recoil_index_20(localIdState);
  var localParticipant = useParticipant(localId);
  (0, import_react2.useDebugValue)(localParticipant);
  return localParticipant;
};
var useMeetingSessionState = function useMeetingSessionState2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onError = _ref.onError;
  var meetingSessionState = Recoil_index_20(meetingSessionDataState);
  useDailyEvent("nonfatal-error", (0, import_react2.useCallback)(function(ev) {
    if (ev.type !== "meeting-session-data-error") return;
    onError == null ? void 0 : onError(ev);
  }, [onError]));
  var result = {
    data: meetingSessionState == null ? void 0 : meetingSessionState.data,
    topology: meetingSessionState == null ? void 0 : meetingSessionState.topology
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useNetwork = function useNetwork2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onNetworkConnection = _ref.onNetworkConnection, onNetworkQualityChange = _ref.onNetworkQualityChange;
  var daily = useDaily();
  var topology = Recoil_index_20(topologyState);
  var quality = Recoil_index_20(networkQualityState);
  var threshold = Recoil_index_20(networkThresholdState);
  useDailyEvent("network-connection", (0, import_react2.useCallback)(function(ev) {
    onNetworkConnection == null ? void 0 : onNetworkConnection(ev);
  }, [onNetworkConnection]));
  useDailyEvent("network-quality-change", (0, import_react2.useCallback)(function(ev) {
    onNetworkQualityChange == null ? void 0 : onNetworkQualityChange(ev);
  }, [onNetworkQualityChange]));
  var getStats = (0, import_react2.useCallback)(_asyncToGenerator(function* () {
    var newStats = yield daily == null ? void 0 : daily.getNetworkStats();
    return newStats == null ? void 0 : newStats.stats;
  }), [daily]);
  var result = {
    getStats,
    quality,
    threshold,
    topology
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var participantCountsState = Recoil_index_8({
  key: RECOIL_PREFIX + "participant-counts",
  "default": {
    hidden: 0,
    present: 0
  }
});
var useParticipantCounts = function useParticipantCounts2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onParticipantCountsUpdated = _ref.onParticipantCountsUpdated;
  var daily = useDaily();
  var participantCounts = Recoil_index_20(participantCountsState);
  var updateCounts = Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return function(counts) {
      set(participantCountsState, counts);
    };
  }, []);
  useDailyEvent("participant-counts-updated", (0, import_react2.useCallback)(function(ev) {
    updateCounts(ev.participantCounts);
    onParticipantCountsUpdated == null ? void 0 : onParticipantCountsUpdated(ev);
  }, [onParticipantCountsUpdated, updateCounts]));
  (0, import_react2.useEffect)(function() {
    if (!daily || daily.isDestroyed()) return;
    updateCounts(daily.participantCounts());
  }, [daily, updateCounts]);
  (0, import_react2.useDebugValue)(participantCounts);
  return participantCounts;
};
var usePermissions = function usePermissions2(sessionId) {
  var _permissions$canSend, _permissions$canSend2, _permissions$canSend3, _permissions$canSend4, _permissions$canSend5, _permissions$canSend6, _permissions$canAdmin, _permissions$canAdmin2, _permissions$canAdmin3;
  var localSessionId = useLocalSessionId();
  var permissions = useParticipantProperty(sessionId != null ? sessionId : localSessionId, "permissions");
  var canSendAudio = typeof (permissions == null ? void 0 : permissions.canSend) === "boolean" ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend = permissions.canSend) == null ? void 0 : _permissions$canSend.has("audio"));
  var canSendVideo = typeof (permissions == null ? void 0 : permissions.canSend) === "boolean" ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend2 = permissions.canSend) == null ? void 0 : _permissions$canSend2.has("video"));
  var canSendCustomAudio = typeof (permissions == null ? void 0 : permissions.canSend) === "boolean" ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend3 = permissions.canSend) == null ? void 0 : _permissions$canSend3.has("customAudio"));
  var canSendCustomVideo = typeof (permissions == null ? void 0 : permissions.canSend) === "boolean" ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend4 = permissions.canSend) == null ? void 0 : _permissions$canSend4.has("customVideo"));
  var canSendScreenAudio = typeof (permissions == null ? void 0 : permissions.canSend) === "boolean" ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend5 = permissions.canSend) == null ? void 0 : _permissions$canSend5.has("screenAudio"));
  var canSendScreenVideo = typeof (permissions == null ? void 0 : permissions.canSend) === "boolean" ? permissions == null ? void 0 : permissions.canSend : Boolean(permissions == null ? void 0 : (_permissions$canSend6 = permissions.canSend) == null ? void 0 : _permissions$canSend6.has("screenVideo"));
  var canAdminParticipants = typeof (permissions == null ? void 0 : permissions.canAdmin) === "boolean" ? permissions == null ? void 0 : permissions.canAdmin : Boolean(permissions == null ? void 0 : (_permissions$canAdmin = permissions.canAdmin) == null ? void 0 : _permissions$canAdmin.has("participants"));
  var canAdminStreaming = typeof (permissions == null ? void 0 : permissions.canAdmin) === "boolean" ? permissions == null ? void 0 : permissions.canAdmin : Boolean(permissions == null ? void 0 : (_permissions$canAdmin2 = permissions.canAdmin) == null ? void 0 : _permissions$canAdmin2.has("streaming"));
  var canAdminTranscription = typeof (permissions == null ? void 0 : permissions.canAdmin) === "boolean" ? permissions == null ? void 0 : permissions.canAdmin : Boolean(permissions == null ? void 0 : (_permissions$canAdmin3 = permissions.canAdmin) == null ? void 0 : _permissions$canAdmin3.has("transcription"));
  var result = {
    canAdminParticipants,
    canAdminStreaming,
    canAdminTranscription,
    canSendAudio,
    canSendCustomAudio,
    canSendCustomVideo,
    canSendScreenAudio,
    canSendScreenVideo,
    canSendVideo,
    hasPresence: permissions == null ? void 0 : permissions.hasPresence,
    permissions
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var participantReceiveSettingsState = Recoil_index_10({
  key: RECOIL_PREFIX + "participant-receive-settings",
  "default": {}
});
var useReceiveSettings = function useReceiveSettings2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$id = _ref.id, id = _ref$id === void 0 ? "base" : _ref$id, onReceiveSettingsUpdated = _ref.onReceiveSettingsUpdated;
  var baseSettings = Recoil_index_20(participantReceiveSettingsState("base"));
  var receiveSettings = Recoil_index_20(participantReceiveSettingsState(id));
  var daily = useDaily();
  var meetingState = useMeetingState();
  var updateReceiveSettingsState = Recoil_index_31(function(_ref2) {
    var transact_UNSTABLE = _ref2.transact_UNSTABLE;
    return function(receiveSettings2) {
      transact_UNSTABLE(function(_ref3) {
        var reset = _ref3.reset, set = _ref3.set;
        var ids = _extends({}, receiveSettings2);
        for (var _i2 = 0, _Object$entries = Object.entries(ids); _i2 < _Object$entries.length; _i2++) {
          var _Object$entries$_i = _Object$entries[_i2], _id = _Object$entries$_i[0], settings = _Object$entries$_i[1];
          set(participantReceiveSettingsState(_id), settings);
        }
        if (!(id in ids)) {
          reset(participantReceiveSettingsState(id));
        }
      });
    };
  }, [id]);
  useDailyEvent("receive-settings-updated", (0, import_react2.useCallback)(function(ev) {
    updateReceiveSettingsState(ev.receiveSettings);
    onReceiveSettingsUpdated == null ? void 0 : onReceiveSettingsUpdated(ev);
  }, [onReceiveSettingsUpdated, updateReceiveSettingsState]));
  (0, import_react2.useEffect)(function() {
    if (!daily || daily.isDestroyed()) return;
    daily.getReceiveSettings().then(updateReceiveSettingsState);
  }, [daily, updateReceiveSettingsState]);
  var updateReceiveSettings = (0, import_react2.useCallback)(function() {
    if (!daily || meetingState !== "joined-meeting") return;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    daily == null ? void 0 : daily.updateReceiveSettings == null ? void 0 : daily.updateReceiveSettings.apply(daily, args);
  }, [daily, meetingState]);
  var result = {
    receiveSettings: id === "base" || Object.keys(receiveSettings).length === 0 ? baseSettings : receiveSettings,
    updateReceiveSettings
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useRecording = function useRecording2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onRecordingData = _ref.onRecordingData, onRecordingError = _ref.onRecordingError, onRecordingStarted = _ref.onRecordingStarted, onRecordingStopped = _ref.onRecordingStopped;
  var daily = useDaily();
  var state = Recoil_index_20(recordingState);
  useDailyEvent("recording-started", (0, import_react2.useCallback)(function(ev) {
    onRecordingStarted == null ? void 0 : onRecordingStarted(ev);
  }, [onRecordingStarted]));
  useDailyEvent("recording-stopped", (0, import_react2.useCallback)(function(ev) {
    onRecordingStopped == null ? void 0 : onRecordingStopped(ev);
  }, [onRecordingStopped]));
  useDailyEvent("recording-error", (0, import_react2.useCallback)(function(ev) {
    onRecordingError == null ? void 0 : onRecordingError(ev);
  }, [onRecordingError]));
  useDailyEvent("recording-data", (0, import_react2.useCallback)(function(ev) {
    onRecordingData == null ? void 0 : onRecordingData(ev);
  }, [onRecordingData]));
  var startRecording = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.startRecording.apply(daily, arguments);
  }, [daily]);
  var stopRecording = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.stopRecording.apply(daily, arguments);
  }, [daily]);
  var updateRecording = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.updateRecording.apply(daily, arguments);
  }, [daily]);
  var result = _extends({}, state, {
    startRecording,
    stopRecording,
    updateRecording
  });
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useRoom = function useRoom2() {
  var room = Recoil_index_20(roomState);
  (0, import_react2.useDebugValue)(room);
  return room;
};
var useRoomExp = function useRoomExp2(_temp) {
  var _room$config4, _room$config5, _room$config6, _room$tokenConfig4, _room$tokenConfig5, _room$tokenConfig6;
  var _ref = _temp === void 0 ? {} : _temp, onCountdown = _ref.onCountdown;
  var localJoinDate = Recoil_index_20(localJoinDateState);
  var room = useRoom();
  var _useState = (0, import_react2.useState)(null), ejectDate = _useState[0], setEjectDate = _useState[1];
  (0, import_react2.useEffect)(function() {
    var _ref2, _room$tokenConfig$eje, _room$tokenConfig, _room$config, _ref3, _room$tokenConfig$exp, _room$tokenConfig2, _room$config2, _ref4, _room$tokenConfig$eje2, _room$tokenConfig3, _room$config3;
    var ejectAfterElapsed = (_ref2 = (_room$tokenConfig$eje = room == null ? void 0 : (_room$tokenConfig = room.tokenConfig) == null ? void 0 : _room$tokenConfig.eject_after_elapsed) != null ? _room$tokenConfig$eje : room == null ? void 0 : (_room$config = room.config) == null ? void 0 : _room$config.eject_after_elapsed) != null ? _ref2 : 0;
    var expUTCTimeStamp = (_ref3 = (_room$tokenConfig$exp = room == null ? void 0 : (_room$tokenConfig2 = room.tokenConfig) == null ? void 0 : _room$tokenConfig2.exp) != null ? _room$tokenConfig$exp : room == null ? void 0 : (_room$config2 = room.config) == null ? void 0 : _room$config2.exp) != null ? _ref3 : 0;
    var ejectAtExp = (_ref4 = (_room$tokenConfig$eje2 = room == null ? void 0 : (_room$tokenConfig3 = room.tokenConfig) == null ? void 0 : _room$tokenConfig3.eject_at_token_exp) != null ? _room$tokenConfig$eje2 : room == null ? void 0 : (_room$config3 = room.config) == null ? void 0 : _room$config3.eject_at_room_exp) != null ? _ref4 : false;
    var newEjectDate = /* @__PURE__ */ new Date(0);
    if (ejectAfterElapsed && localJoinDate) {
      newEjectDate = new Date(localJoinDate.getTime() + 1e3 * ejectAfterElapsed);
    }
    if (ejectAtExp && expUTCTimeStamp) {
      var expDate = new Date(expUTCTimeStamp * 1e3);
      if (!newEjectDate.getTime() || newEjectDate.getTime() > 0 && expDate < newEjectDate) newEjectDate = expDate;
    }
    if (newEjectDate.getTime() === 0) return;
    setEjectDate(function(oldEjectDate) {
      return (oldEjectDate == null ? void 0 : oldEjectDate.getTime()) !== newEjectDate.getTime() ? newEjectDate : oldEjectDate;
    });
  }, [localJoinDate, room == null ? void 0 : (_room$config4 = room.config) == null ? void 0 : _room$config4.eject_after_elapsed, room == null ? void 0 : (_room$config5 = room.config) == null ? void 0 : _room$config5.eject_at_room_exp, room == null ? void 0 : (_room$config6 = room.config) == null ? void 0 : _room$config6.exp, room == null ? void 0 : (_room$tokenConfig4 = room.tokenConfig) == null ? void 0 : _room$tokenConfig4.eject_after_elapsed, room == null ? void 0 : (_room$tokenConfig5 = room.tokenConfig) == null ? void 0 : _room$tokenConfig5.eject_at_token_exp, room == null ? void 0 : (_room$tokenConfig6 = room.tokenConfig) == null ? void 0 : _room$tokenConfig6.exp]);
  (0, import_react2.useEffect)(function() {
    if (!ejectDate || ejectDate.getTime() === 0) return;
    var interval = setInterval(function() {
      var _ejectDate$getTime;
      var eject = ((_ejectDate$getTime = ejectDate == null ? void 0 : ejectDate.getTime()) != null ? _ejectDate$getTime : 0) / 1e3;
      var now = Date.now() / 1e3;
      var diff = eject - now;
      if (diff < 0) return;
      var hours = Math.max(0, Math.floor(diff / 3600));
      var minutes = Math.max(0, Math.floor(diff % 3600 / 60));
      var seconds = Math.max(0, Math.floor(diff % 60));
      onCountdown == null ? void 0 : onCountdown({
        hours,
        minutes,
        seconds
      });
    }, 1e3);
    return function() {
      clearInterval(interval);
    };
  }, [ejectDate, onCountdown]);
  var result = {
    ejectDate
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useScreenAudioTrack = function useScreenAudioTrack2(participantId) {
  return useMediaTrack(participantId, "screenAudio");
};
var useScreenVideoTrack = function useScreenVideoTrack2(participantId) {
  return useMediaTrack(participantId, "screenVideo");
};
var sendSettingsState = Recoil_index_8({
  key: RECOIL_PREFIX + "send-settings",
  "default": null
});
var useSendSettings = function useSendSettings2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onSendSettingsUpdated = _ref.onSendSettingsUpdated;
  var daily = useDaily();
  var sendSettings = Recoil_index_20(sendSettingsState);
  useDailyEvent("send-settings-updated", Recoil_index_31(function(_ref2) {
    var set = _ref2.set;
    return function(ev) {
      set(sendSettingsState, ev.sendSettings);
      onSendSettingsUpdated == null ? void 0 : onSendSettingsUpdated(ev);
    };
  }, [onSendSettingsUpdated]));
  var storeSendSettings = Recoil_index_31(function(_ref3) {
    var set = _ref3.set;
    return function(sendSettings2) {
      set(sendSettingsState, sendSettings2);
    };
  }, []);
  (0, import_react2.useEffect)(function() {
    if (!daily || daily.isDestroyed()) return;
    storeSendSettings(daily.getSendSettings());
  }, [daily, storeSendSettings]);
  var updateSendSettings = (0, import_react2.useCallback)(_asyncToGenerator(function* () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var newSendSettings = yield daily == null ? void 0 : daily.updateSendSettings.apply(daily, args);
    if (!newSendSettings) return;
    storeSendSettings(newSendSettings);
    return newSendSettings;
  }), [daily, storeSendSettings]);
  var result = {
    sendSettings,
    updateSendSettings
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useTranscription = function useTranscription2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onTranscriptionAppData = _ref.onTranscriptionAppData, onTranscriptionError = _ref.onTranscriptionError, onTranscriptionMessage = _ref.onTranscriptionMessage, onTranscriptionStarted = _ref.onTranscriptionStarted, onTranscriptionStopped = _ref.onTranscriptionStopped;
  var daily = useDaily();
  var state = Recoil_index_20(transcriptionState);
  useDailyEvent("transcription-started", (0, import_react2.useCallback)(function(ev) {
    onTranscriptionStarted == null ? void 0 : onTranscriptionStarted(ev);
  }, [onTranscriptionStarted]));
  useDailyEvent("transcription-stopped", (0, import_react2.useCallback)(function(ev) {
    onTranscriptionStopped == null ? void 0 : onTranscriptionStopped(ev);
  }, [onTranscriptionStopped]));
  useDailyEvent("transcription-error", (0, import_react2.useCallback)(function(ev) {
    onTranscriptionError == null ? void 0 : onTranscriptionError(ev);
  }, [onTranscriptionError]));
  useDailyEvent("transcription-message", (0, import_react2.useCallback)(function(ev) {
    onTranscriptionMessage == null ? void 0 : onTranscriptionMessage(ev);
  }, [onTranscriptionMessage]));
  useDailyEvent("app-message", (0, import_react2.useCallback)(function(ev) {
    if ((ev == null ? void 0 : ev.fromId) === "transcription") {
      onTranscriptionAppData == null ? void 0 : onTranscriptionAppData(ev);
    }
  }, [onTranscriptionAppData]));
  var startTranscription = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.startTranscription.apply(daily, arguments);
  }, [daily]);
  var stopTranscription = (0, import_react2.useCallback)(function() {
    if (!daily) return;
    daily.stopTranscription.apply(daily, arguments);
  }, [daily]);
  var result = _extends({}, state, {
    startTranscription,
    stopTranscription
  });
  (0, import_react2.useDebugValue)(result);
  return result;
};
var useVideoTrack = function useVideoTrack2(participantId) {
  return useMediaTrack(participantId, "video");
};
var useWaitingParticipants = function useWaitingParticipants2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, onWaitingParticipantAdded = _ref.onWaitingParticipantAdded, onWaitingParticipantRemoved = _ref.onWaitingParticipantRemoved, onWaitingParticipantUpdated = _ref.onWaitingParticipantUpdated;
  var daily = useDaily();
  var waitingParticipants = Recoil_index_20(allWaitingParticipantsSelector);
  useDailyEvent("waiting-participant-added", (0, import_react2.useCallback)(function(ev) {
    onWaitingParticipantAdded == null ? void 0 : onWaitingParticipantAdded(ev);
  }, [onWaitingParticipantAdded]));
  useDailyEvent("waiting-participant-removed", (0, import_react2.useCallback)(function(ev) {
    onWaitingParticipantRemoved == null ? void 0 : onWaitingParticipantRemoved(ev);
  }, [onWaitingParticipantRemoved]));
  useDailyEvent("waiting-participant-updated", (0, import_react2.useCallback)(function(ev) {
    onWaitingParticipantUpdated == null ? void 0 : onWaitingParticipantUpdated(ev);
  }, [onWaitingParticipantUpdated]));
  var updateWaitingParticipantAccess = (0, import_react2.useCallback)(function(id, grantRequestedAccess) {
    if (id === "*") {
      daily == null ? void 0 : daily.updateWaitingParticipants({
        "*": {
          grantRequestedAccess
        }
      });
      return;
    }
    daily == null ? void 0 : daily.updateWaitingParticipant(id, {
      grantRequestedAccess
    });
  }, [daily]);
  var grantAccess = (0, import_react2.useCallback)(function(id) {
    updateWaitingParticipantAccess(id, true);
  }, [updateWaitingParticipantAccess]);
  var denyAccess = (0, import_react2.useCallback)(function(id) {
    updateWaitingParticipantAccess(id, false);
  }, [updateWaitingParticipantAccess]);
  var result = {
    waitingParticipants,
    grantAccess,
    denyAccess
  };
  (0, import_react2.useDebugValue)(result);
  return result;
};
export {
  DailyAudio,
  DailyAudioTrack,
  DailyProvider,
  DailyVideo,
  useActiveParticipant,
  useActiveSpeakerId,
  useAppMessage,
  useAudioLevel,
  useAudioLevelObserver,
  useAudioTrack,
  useCPULoad,
  useCallFrame,
  useCallObject,
  useDaily,
  useDailyError,
  useDailyEvent,
  useDevices,
  useInputSettings,
  useLiveStreaming,
  useLocalParticipant,
  useLocalSessionId,
  useMediaTrack,
  useMeetingSessionState,
  useMeetingState,
  useNetwork,
  useParticipant,
  useParticipantCounts,
  useParticipantIds,
  useParticipantProperty,
  usePermissions,
  useReceiveSettings,
  useRecording,
  useRoom,
  useRoomExp,
  useScreenAudioTrack,
  useScreenShare,
  useScreenVideoTrack,
  useSendSettings,
  useThrottledDailyEvent,
  useTranscription,
  useVideoTrack,
  useWaitingParticipants
};
/*! Bundled license information:

@daily-co/daily-js/dist/daily-esm.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=@daily-co_daily-react.js.map
